<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8255A&amp;&amp;8253</title>
      <link href="/2021/08/05/8255A&amp;&amp;8253/"/>
      <url>/2021/08/05/8255A&amp;&amp;8253/</url>
      
        <content type="html"><![CDATA[<p>对Intel的可编程并行I/O接口芯片8255和可编程计数器/定时器8253的笔记。</p><a id="more"></a><h2 id="8255A（8255的改进型）"><a href="#8255A（8255的改进型）" class="headerlink" title="8255A（8255的改进型）"></a>8255A（8255的改进型）</h2><p>8255芯片是Intel公司生产的可编程并行I/O接口芯片，有3个8位并行I/O口。具有3个通道3种工作方式的可编程并行接口芯片（40引脚）。 其各口功能可由软件选择，使用灵活，通用性强。8255可作为单片机与多种外设连接时的中间接口电路。</p><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><img src="/2021/08/05/8255A&&8253/%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt></p><p>8255A由<code>数据总线缓冲器</code>、<code>数据端口A</code>、<code>数据端口B</code>、<code>数据端口C</code>、<code>A组控制电路</code>、<code>B组控制电路</code>和<code>读/写控制电路</code>组成。</p><h3 id="引脚功能"><a href="#引脚功能" class="headerlink" title="引脚功能"></a>引脚功能</h3><p><img src="/2021/08/05/8255A&&8253/%E5%BC%95%E8%84%9A%E5%8A%9F%E8%83%BD.png" alt></p><ul><li>可存取数据的端口<code>A</code>、端口<code>B</code>、端口<code>C</code>，分别对应<code>PA</code>、<code>PB</code>、<code>PC</code>；</li><li><code>RESET</code>：复位引脚，低电平有效；当该引脚检测到<strong>低电平</strong>信号时，8255A<strong>内部寄存器清零</strong>，<code>PA</code>、<code>PB</code>、<code>PC</code>端口被设置为<strong>输入状态</strong>；</li><li><code>CS&#39;</code>：片选引脚，低电平有效；地址总线的高位译码后连接该引脚，用于选中8255A。引脚上的信号有效时，才可以对8255A进行读、写等操作；</li><li><code>RD&#39;</code>：<code>读</code>控制，低电平有效；用于CPU从8255A读取数据或状态；</li><li><code>WR&#39;</code>：<code>写</code>控制，低电平有效；用于CPU向8255A写入数据或控制字；</li><li><code>D0~D7</code>：与数据总线相连，CPU通过这8个引脚与8255A进行数据通信；</li><li><code>A0、A1</code>：用于<code>A</code>、<code>B</code>、<code>C</code>端口与控制寄存器的选择。</li></ul><h3 id="读写-amp-控制逻辑"><a href="#读写-amp-控制逻辑" class="headerlink" title="读写&amp;控制逻辑"></a>读写&amp;控制逻辑</h3><p><img src="/2021/08/05/8255A&&8253/%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91.png" alt></p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>端口<code>A</code>可工作于方式0、方式1、方式2；</li><li>端口<code>B</code>可工作于方式0、方式1；</li><li>端口<code>C</code>只能工作于方式0。</li></ul><h4 id="方式0——基本输入输出"><a href="#方式0——基本输入输出" class="headerlink" title="方式0——基本输入输出"></a>方式0——基本输入输出</h4><p>每一个端口都作为基本的I/O口，端口<code>C</code>的高4位、端口<code>C</code>的低4位、端口<code>A</code>和端口<code>B</code>均可独立设置为I/O口。</p><p>CPU可采用<strong>无条件传输方式</strong>与8255A进行数据交换。</p><p>方式0<strong>输出</strong>时<strong>有</strong>锁存能力，<strong>输入</strong>时<strong>无</strong>锁存能力。</p><h4 id="方式1——单向选通输入输出"><a href="#方式1——单向选通输入输出" class="headerlink" title="方式1——单向选通输入输出"></a>方式1——单向选通输入输出</h4><p>三个数据端口分为A、B两组，当端口<code>A</code>工作于方式1时，<code>PC3</code>、<code>PC4</code>、<code>PC5</code>用于端口<code>A</code>的选通控制信号；当端口<code>B</code>工作于方式1时，<code>PC0</code>、<code>PC1</code>、<code>PC2</code>用于端口<code>B</code>的选通控制信号；<code>PC6</code>、<code>PC7</code>可工作于方式0。</p><p><code>PC6</code>和<code>PC7</code>由方式选择控制字中的<strong><code>D3</code></strong>位来定义其<strong>传送方向</strong>，当<code>D3</code>为<strong><code>1</code></strong>时，用于<strong>输入</strong>；当<code>D3</code>为<strong><code>0</code></strong>时，用于<strong>输出</strong>。</p><p>方式1适合用于<strong>中断方式</strong>下的输入输出。</p><p>方式1<strong>输入和输出</strong>时均<strong>有</strong>锁存能力。</p><h5 id="方式1：输入"><a href="#方式1：输入" class="headerlink" title="方式1：输入"></a>方式1：输入</h5><p><img src="/2021/08/05/8255A&&8253/1%E8%BE%93%E5%85%A5.png" alt></p><h5 id="方式1：输出"><a href="#方式1：输出" class="headerlink" title="方式1：输出"></a>方式1：输出</h5><p><img src="/2021/08/05/8255A&&8253/1%E8%BE%93%E5%87%BA.png" alt></p><h4 id="方式2——双向选通输入输出"><a href="#方式2——双向选通输入输出" class="headerlink" title="方式2——双向选通输入输出"></a>方式2——双向选通输入输出</h4><p>在用作输入的同时，又能用作输出，<strong>只有端口<code>A</code>可工作于方式2</strong>，占用端口<code>C</code>的<strong>5位</strong>用作<strong>选通控制</strong>。</p><p>方式2可采用<strong>查询方式</strong>和<strong>中断方式</strong>进行数据传输。</p><p>当端口<code>A</code>工作于方式2、端口<code>B</code>工作于方式1时，<code>PC7~PC3</code>作为端口<code>A</code>的联络信号，<code>PC2~PC0</code>作为端口<code>B</code>的联络信号；</p><p>当端口<code>A</code>工作于方式2、端口<code>B</code>工作于方式0时，<code>PC7~PC3</code>作为端口<code>A</code>的联络信号，<code>PC2~PC0</code>可工作于方式0。</p><p><img src="/2021/08/05/8255A&&8253/%E6%96%B9%E5%BC%8F2.png" alt></p><h3 id="控制字"><a href="#控制字" class="headerlink" title="控制字"></a>控制字</h3><h4 id="方式选择控制字"><a href="#方式选择控制字" class="headerlink" title="方式选择控制字"></a>方式选择控制字</h4><p><img src="/2021/08/05/8255A&&8253/%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9%E6%8E%A7%E5%88%B6%E5%AD%97.png" alt></p><h4 id="端口C置位-复位控制字"><a href="#端口C置位-复位控制字" class="headerlink" title="端口C置位/复位控制字"></a>端口C置位/复位控制字</h4><p><img src="/2021/08/05/8255A&&8253/%E7%AB%AF%E5%8F%A3C%E6%8E%A7%E5%88%B6%E5%AD%97.png" alt></p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>设某8255的控制端口地址为63H，若要其端口A工作于方式1输出，允许中断，则必须使INTE（PC6）为1，为此，可向控制字寄存器写入按位置位/复位操作命令：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">00001101B</span></span><br><span class="line"><span class="keyword">OUT</span><span class="number">63H</span>,<span class="built_in">AL</span></span><br></pre></td></tr></table></figure><p>若要端口B工作于方式1输入，允许中断，则必须使INTE（PC2）为1，为此，可向控制字寄存器写入以下的按位置位/复位操作命令：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">00000101B</span></span><br><span class="line"><span class="keyword">OUT</span><span class="number">63H</span>,<span class="built_in">AL</span></span><br></pre></td></tr></table></figure><p>若将8255A的端口A作为输出，端口B作为输入，端口A和端口B均工作于方式0。已知8255A端口地址为60H～63H，则对8255A进行初始化，并将PC1置位，PC2复位的操作命令如下：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">82H</span><span class="comment">;方式选择控制字10000010B=82H</span></span><br><span class="line"><span class="keyword">OUT</span><span class="number">63H</span>,<span class="built_in">AL</span><span class="comment">;将控制字写入8255A控制端口,设置各端口工作方式</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">03H</span><span class="comment">;端口C置位控制字00000011B=03H,设置PC1=1</span></span><br><span class="line"><span class="keyword">OUT</span><span class="number">63H</span>,<span class="built_in">AL</span><span class="comment">;将控制字写入8255A控制端口</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">04H</span><span class="comment">;端口C置位控制字00000100B=04H,设置PC2=0</span></span><br><span class="line"><span class="keyword">OUT</span><span class="number">63H</span>,<span class="built_in">AL</span><span class="comment">;将控制字写入8255A控制端口</span></span><br></pre></td></tr></table></figure><h2 id="8253"><a href="#8253" class="headerlink" title="8253"></a>8253</h2><p>8253芯片是可编程计数器/定时器。8253的读/写操作对系统时钟没有特殊的要求，可应用于由任何一种微处理器组成的系统中，可作为可编程的方波频率发生器、分频器、实时时钟和单脉冲发生器等。</p><h3 id="内部结构-1"><a href="#内部结构-1" class="headerlink" title="内部结构"></a>内部结构</h3><p>每片8253有3个独立的16位计数通道，每个计数通道最高计数速率可达2.6MHZ。每个计数器可编程设定6种工作方式，使用时可以根据需要选择其中的一种工作方式。每个计数通道可按<strong>二进制</strong>或<strong>十进制</strong>来计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt></p><h3 id="引脚功能-1"><a href="#引脚功能-1" class="headerlink" title="引脚功能"></a>引脚功能</h3><p><img src="/2021/08/05/8255A&&8253/8253%E5%BC%95%E8%84%9A%E5%8A%9F%E8%83%BD.png" alt></p><ul><li><code>D7~D0</code>：8位三态双向缓冲器，与系统的数据总线连接，接收CPU送来的计数值和控制字，高阻态时隔离8253与系统总线；</li><li><code>WR&#39;</code>：<code>写</code>信号输入引脚，低电平有效；</li><li><code>RD&#39;</code>：<code>读</code>信号输入引脚，低电平有效；</li><li><code>CS&#39;</code>：片选信号输入引脚，低电平有效；</li><li><code>A1、A0</code>：端口选择信号输入引脚。</li></ul><h3 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h3><h4 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h4><p>8253完成计数功能，且<strong>只作一遍计数</strong>。控制字写入后，输出端<code>OUT</code>变为低电平；计数初值写入后，下一个<code>CLK</code>脉冲的下降沿，开始计数，输出端<code>OUT</code>维持低电平。</p><p>当计数值减到<strong>0</strong>时，输出端<strong><code>OUT</code></strong>变为<strong>高电平</strong>，可作为中断请求信号，并可保持到重新写入新的控制字或新的计数初值为止。</p><p>在计数过程中，若<strong><code>GATE</code></strong>信号变为<strong>低电平</strong>，则<strong>暂停计数</strong>；当<strong><code>GATE</code></strong>信号<strong>重新变为高电平</strong>时，则<strong>从暂停时的计数值开始继续计数</strong>；若<strong>写入新的计数初值</strong>，则<strong>在下一个<code>CLK</code>脉冲的下降沿</strong>，以新的计数初值重新开始计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F0.png" alt></p><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><p>方式1是硬件触发单稳态方式，<strong>输出单个负脉冲信号</strong>，脉冲宽度为可编程。</p><p>写入控制字后，输出端<strong><code>OUT</code></strong>变为<strong>高电平</strong>并保持此状态。写入计数初值后，在<strong><code>GATE</code>信号的上升沿之后的下一个<code>CLK</code>脉冲的下降沿</strong>，输出端<strong><code>OUT</code></strong>变为<strong>低电平</strong>，开始计数。</p><p>当计数值减到<strong>0</strong>时，输出端<strong><code>OUT</code></strong>变为<strong>高电平</strong>。</p><p>计数过程中，若CPU送来<strong>新的计数初值</strong>，<strong>不影响当前的计数过程</strong>；直到计数值减到<strong>0</strong>时，输出端<strong><code>OUT</code></strong>输出<strong>高电平</strong>且出现<strong>新的一次<code>GATE</code>信号的触发</strong>时，才会<strong>开始新的计数</strong>。</p><p>如果在输出端<strong><code>OUT</code>输出低电平期间，接收到一个<code>GATE</code>信号上升沿触发，则在下一个<code>CLK</code>脉冲的下降沿重新开始计数</strong>。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F1.png" alt></p><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>方式2可产生<strong>连续的负脉冲信号</strong>，可用作频率发生器。<strong>负脉冲宽度为一个时钟周期</strong>。</p><p>写入控制字后，输出端<strong><code>OUT</code></strong>变为<strong>高电平</strong>。若<code>GATE</code>为高电平，则在写入计数初值后，在<strong>下一个<code>CLK</code>脉冲的下降沿</strong>开始计数。当计数值减为<strong>1</strong>时，输出端<strong><code>OUT</code></strong>输出<strong>低电平</strong>，经过<strong>一个<code>CLK</code>时钟周期</strong>，输出端<strong><code>OUT</code></strong>输出<strong>高电平</strong>，并<strong>自动开始一个新的计数过程</strong>。</p><p>在计数过程中，若计数值<strong>未减到1</strong>时，<strong><code>GATE</code></strong>信号<strong>由高电平变为低电平</strong>，则<strong>停止计数</strong>；但当<code>GATE</code>信号<strong>由低电平变为高电平</strong>时，则<strong>从计数初值开始重新计数</strong>。</p><p>若<strong><code>GATE</code>信号保持高电平</strong>，<strong>在计数过程中重新写入计数初值</strong>，则要<strong>在该轮计数结束并输出一个<code>CLK</code>周期的负脉冲后</strong>，才以<strong>新的计数初值</strong>进行计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F2.png" alt></p><h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><p>方式3可产生<strong>连续的方波信号</strong>，可用作方波发生器。计数初值为<strong>偶数</strong>时，输出<strong>对称方波</strong>；计数初值为<strong>奇数</strong>时，输出<strong>不对称方波</strong>。</p><p>控制字写入后，输出端<code>OUT</code>输出高电平。当写入计数初值后，在下一个<code>CLK</code>脉冲的下降沿开始计数。计数值减为计数初值的<strong>1/2</strong>时，<strong>输出端<code>OUT</code>变为低电平</strong>。此时<strong>继续计数</strong>，当计数值减为<strong>0</strong>时，<strong>输出端<code>OUT</code>变为高电平</strong>。之后，自动开始一个新的计数过程。</p><p>在计数过程中，若<strong><code>GATE</code>信号变为低电平</strong>，则<strong>停止计数</strong>；当<strong><code>GATE</code>信号由低电平变为高电平</strong>时，则<strong>从计数初值开始计数</strong>。若在<strong>输出端<code>OUT</code>为低电平</strong>时，<strong><code>GATE</code>信号变为低电平</strong>，则<strong>停止计数</strong>，同时<strong>输出端<code>OUT</code>立即变为高电平</strong>。<strong>在<code>GATE</code>信号又变为高电平后的下一个时钟脉冲的下降沿，重新开始计数</strong>。</p><p>在计数过程中，若写入新的计数初值，不影响当前输出周期。但若在<strong>写入新的计数初值</strong>后，又受到<strong><code>GATE</code>信号上升沿</strong>的触发，则<strong>结束当前输出周期</strong>，而在下一个时钟脉冲的下降沿，以新的计数初值开始计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F3.png" alt></p><h4 id="方式4"><a href="#方式4" class="headerlink" title="方式4"></a>方式4</h4><p>方式4可产生<strong>软件触发</strong>的<strong>单个负脉冲信号</strong>，负脉冲宽度为<strong>一个时钟周期</strong>。</p><p>写入控制字后，输出端<code>OUT</code>变为高电平，若<code>GATE</code>信号为高电平，则在写入计数初值后的下一个<code>CLK</code>下降沿开始计数。当计数值减为0时，输出端<code>OUT</code>变为低电平，在一个<code>CLK</code>时钟周期后，输出端<code>OUT</code>变为高电平。</p><p>若在计数过程中，写入新的计数初值，则在下一个<code>CLK</code>脉冲的下降沿以新的计数初值开始计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F4.png" alt></p><h5 id="方式5"><a href="#方式5" class="headerlink" title="方式5"></a>方式5</h5><p>方式5可产生<strong>硬件触发</strong>的<strong>单个负脉冲信号</strong>，负脉冲宽度为<strong>一个时钟周期</strong>。</p><p>方式5的计数过程由<code>GATE</code>信号的上升沿触发。当控制字写入后，输出端<code>OUT</code>输出高电平并保持此状态。写入计数初值后，只有在<code>GATE</code>信号的上升沿之后的下一个<code>CLK</code>脉冲下降沿开始计数。当计数值减为<strong>0</strong>时，<strong>输出端<code>OUT</code>变为低电平并持续一个<code>CLK</code>周期</strong>，随后<strong>自动变为高电平</strong>。</p><p>在计数过程中，若<code>GATE</code>引脚接收到一个上升沿触发，则在下一个<code>CLK</code>脉冲下降沿重新开始计数。</p><p>在计数过程中，若<strong>写入新的计数初值，但没有触发脉冲，则当前输出周期不受影响</strong>；当前周期结束后，在再次触发的情况下，才以新的计数初值开始计数；若<strong>写入新的计数初值，并在当前周期结束前受到触发</strong>，则在<strong>下一个<code>CLK</code>脉冲下降沿</strong>以新的计数初值开始计数。</p><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F5.png" alt></p><h3 id="方式控制字"><a href="#方式控制字" class="headerlink" title="方式控制字"></a>方式控制字</h3><p><img src="/2021/08/05/8255A&&8253/8253%E6%96%B9%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%AD%97.png" alt></p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>在8086系统中，设8253的计数器0工作在方式2，二进制计数，计数初值为2000；8253的计数器1工作在方式3，BCD码计数，计数初值为10，8253端口地址为40H～43H，则初始化如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">;<span class="number">8253</span>计数器<span class="number">0</span>的初始化如下：</span><br><span class="line">MOVAL,<span class="number">34</span>H;方式控制字<span class="number">00110100</span>B=<span class="number">34</span>H</span><br><span class="line">OUT<span class="number">43</span>H,AL;将控制字送入<span class="number">8253</span>控制端口<span class="number">43</span>H</span><br><span class="line">MOVAX,<span class="number">2000</span>;初值送入AX寄存器</span><br><span class="line">OUT<span class="number">40</span>H,AL;将初值的低<span class="number">8</span>位输出计数通道<span class="number">0</span>端口<span class="number">40</span>H</span><br><span class="line">MOVAL,AH;初值的高<span class="number">8</span>位送入AL寄存器</span><br><span class="line">OUT<span class="number">40</span>H,AL;将初值的高<span class="number">8</span>位输出计数通道<span class="number">0</span>端口<span class="number">40</span>H</span><br><span class="line"></span><br><span class="line">;<span class="number">8253</span>计数器<span class="number">1</span>的初始化如下：</span><br><span class="line">MOVAL,<span class="number">57</span>H;方式控制字<span class="number">01010111</span>B=<span class="number">57</span>H</span><br><span class="line">OUT<span class="number">43</span>H,AL;将控制字送入<span class="number">8253</span>控制端口<span class="number">43</span>H</span><br><span class="line">MOVAL,<span class="number">10</span>H;将初值<span class="number">10</span>送入AL寄存器,因为BCD码计数,所以为<span class="number">10</span>H</span><br><span class="line">OUT<span class="number">41</span>H,AL;将初值的低<span class="number">8</span>位输出计数通道<span class="number">1</span>端口<span class="number">41</span>H</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料</strong>：</p><p><a href="https://baike.baidu.com/item/8255%E8%8A%AF%E7%89%87/3699882" target="_blank" rel="noopener">8255芯片_百度百科</a></p><p><a href="https://blog.csdn.net/sinat_36945592/article/details/85684680?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162778376116780274162876%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162778376116780274162876&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-85684680.pc_v2_rank_blog_default&utm_term=8255&spm=1018.2226.3001.4450" target="_blank" rel="noopener">微机原理笔记（2）——8255A芯片</a></p><p><a href="https://baike.baidu.com/item/8253%E8%8A%AF%E7%89%87/3699917" target="_blank" rel="noopener">8253芯片_百度百科</a></p><p><a href="https://blog.csdn.net/sinat_36945592/article/details/85705184" target="_blank" rel="noopener">微机原理笔记（3）——8253芯片</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>51单片机——DS18B20简要记录</title>
      <link href="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>对DS18B20的使用作一个简单记录。</p><a id="more"></a><h2 id="DS18B20内部组成"><a href="#DS18B20内部组成" class="headerlink" title="DS18B20内部组成"></a>DS18B20内部组成</h2><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90.png" alt></p><h3 id="64位ROM"><a href="#64位ROM" class="headerlink" title="64位ROM"></a>64位ROM</h3><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/64%E4%BD%8DROM.png" alt></p><ul><li><p><strong>8位FAMILY CODE</strong>：DS18B20的64位ROM中的前8位统一为<code>28H</code>；</p></li><li><p><strong>48位SERIAL NUMBER</strong>：唯一序列号；</p></li><li><p><strong>8位CRC</strong>：对ROM中前56位编码的校验码。</p></li></ul><h3 id="高速暂存存储器"><a href="#高速暂存存储器" class="headerlink" title="高速暂存存储器"></a>高速暂存存储器</h3><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E9%AB%98%E9%80%9F%E6%9A%82%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.png" alt></p><ul><li><p><strong>字节0</strong>：存储温度值的低8位；</p></li><li><p><strong>字节1</strong>：存储温度值的高8位；</p></li><li><p><strong>字节2</strong>：存储报警触发的温度上限值，也可作为一般用途的存储器（EEPROM）使用；</p></li><li><p><strong>字节3</strong>：存储报警触发的温度下限值，也可作为一般用途的存储器（EEPROM）使用；</p></li><li><p><strong>字节4</strong>：配置寄存器；通过<code>R0</code>位和<code>R1</code>位可以设置转换分辨率，默认分辨率为12位；</p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%88%86%E8%BE%A8%E7%8E%87.png" alt></p></li><li><p><strong>字节5~7</strong>：保留字段；</p></li><li><p><strong>字节8</strong>：CRC。</p></li></ul><h2 id="DS18B20温度数据"><a href="#DS18B20温度数据" class="headerlink" title="DS18B20温度数据"></a>DS18B20温度数据</h2><h3 id="获取温度"><a href="#获取温度" class="headerlink" title="获取温度"></a>获取温度</h3><p>DS18B20以<strong>16位补码</strong>的形式将温度数据存储于温度寄存器，单位为摄氏度。</p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E8%A1%A5%E7%A0%81.png" alt></p><p>从<code>11位</code>到<code>15位</code>为符号位，温度值为正数时，符号位均为<code>0</code>；温度值为负数时，符号位均为<code>1</code>。</p><p>剩下的11位当中，对于12位分辨率，所有位全部有效；对于11位分辨率，<code>0位</code>无意义；对于10位分辨率，<code>0位</code>和<code>1位</code>无意义；对于9位分辨率，<code>0位</code>、<code>1位</code>和<code>2位</code>无意义。</p><p>12位分辨率的精度为0.0625摄氏度；11位分辨率的精度为0.125摄氏度；10位分辨率的精度为0.25摄氏度；9位分辨率的精度为0.5摄氏度。</p><h4 id="温度计算"><a href="#温度计算" class="headerlink" title="温度计算"></a>温度计算</h4><p>当温度值为正数时，将温度寄存器从<code>0位</code>到<code>10位</code>的11位二进制数转换为十进制数，再与分辨率的精度相乘，即可得到实际温度值；当温度值为负数时，先将温度寄存器的11位二进制补码转换为原码，再将原码转换为十进制数，最后再与分辨率的精度相乘，即可得到实际温度值。</p><h3 id="温度阈值"><a href="#温度阈值" class="headerlink" title="温度阈值"></a>温度阈值</h3><p>对于两个温度阈值触发寄存器（<code>TH</code>和<code>TL</code>），由于均为8位寄存器，因此仅能将温度寄存器<code>4位</code>到<code>11位</code>所表示的温度值与设定的阈值进行比较。</p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E9%98%88%E5%80%BC.png" alt></p><p>对于正数，<code>7位</code>为<code>0</code>；对于负数，<code>7位</code>为<code>1</code>。</p><h2 id="DS18B20操作指令"><a href="#DS18B20操作指令" class="headerlink" title="DS18B20操作指令"></a>DS18B20操作指令</h2><h3 id="ROM指令"><a href="#ROM指令" class="headerlink" title="ROM指令"></a>ROM指令</h3><p>当同一总线上挂载多个DS18B20时，需要通过ROM指令来控制某个DS18B20；当总线上只挂载单个DS18B20时，使用<code>跳过ROM</code>指令（<code>0xCC</code>）即可。</p><ul><li><strong>读ROM</strong>（<code>0x33</code>）：读取DS18B20的64位ROM中的编码；</li><li><strong>ROM匹配</strong>（<code>0x55</code>）：发出此指令后，接着发出64位ROM中的编码，选中总线上与编码对应的DS18B20，为下一步对该DS18B20的读写作准备；</li><li><strong>搜索ROM</strong>（<code>0xF0</code>）：用于确定挂载在同一总线上DS18B20的个数和识别64位ROM地址，为操作各器件作准备；</li><li><strong>跳过ROM</strong>（<code>0xCC</code>）：忽略64位ROM地址，直接向DS18B20发送温度转换指令；</li><li><strong>警报搜索</strong>（<code>0xEC</code>）：查找总线上温度超过阈值的DS18B20。</li></ul><h3 id="RAM指令"><a href="#RAM指令" class="headerlink" title="RAM指令"></a>RAM指令</h3><ul><li><strong>温度转换</strong>（<code>0x44</code>）：启动DS18B20进行温度转换，转换结果存储于内部的9字节RAM中；</li><li><strong>读暂存器</strong>（<code>0xBE</code>）：读取内部RAM中9字节的内容；</li><li><strong>写暂存器</strong>（<code>0x4E</code>）：发出此指令向内部RAM的第3、4字节写温度上、下限的阈值，紧跟该命令之后，发送两字节的数据；</li><li><strong>复制暂存器</strong>（<code>0x48</code>）：将内部RAM中第3、4字节的内容复制到EEPROM中；</li><li><strong>重调EEPROM</strong>（<code>0xB8</code>）：将EEPROM中相应的内容恢复到RAM中的第3、4字节；</li><li><strong>读供电方式</strong>（<code>0xB4</code>）：读DS18B20的供电模式；若为寄生供电，则DS18B20发送<code>0</code>；若为外接电源供电，则DS18B20发送<code>1</code>。</li></ul><h2 id="DS18B20时序"><a href="#DS18B20时序" class="headerlink" title="DS18B20时序"></a>DS18B20时序</h2><h3 id="初始化DS18B20"><a href="#初始化DS18B20" class="headerlink" title="初始化DS18B20"></a>初始化DS18B20</h3><ul><li>MCU拉低电平最少480us，产生复位脉冲，然后释放总线；</li><li>DS18B20检测到请求后，拉低电平60~240us表示应答；</li><li>在DS18B20拉低电平的60~240us期间，MCU读取总线的电平，若为低电平，则表示DS18B20初始化成功；</li><li>在DS18B20拉低电平60~240us之后，释放总线。</li></ul><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt></p><h3 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h3><ul><li><strong>写<code>0</code></strong>：MCU拉低电平60~120us，然后释放总线；</li><li><strong>写<code>1</code></strong>：MCU拉低电平大于1us，然后在15us内释放总线。</li></ul><p>在写时序起始后15~60us内，DS18B20处于电平采样状态；若此时总线为高电平，则向DS18B20写<code>1</code>；若此时总线为低电平，则向DS18B20写<code>0</code>。</p><p>两次写周期之间最少间隔1us。</p><h3 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h3><p>MCU拉低电平最少1us，然后释放总线；DS18B20检测到电平被拉低1us后，若发送<code>0</code>，则将电平拉低直到读周期结束，若发送<code>1</code>，则释放总线。读时序必须最少需要60us，且两次读时序之间最少需要间隔1us。</p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E6%97%B6%E5%BA%8F.png" alt></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>通过DS18B20采集环境温度，并在开发板的数码管模块上的左三位显示（带1位小数）。</p><p>MCU：AT89S52</p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/MCU.png" alt></p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/DS18B20.png" alt></p><p><img src="/2021/07/15/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94DS18B20%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E6%95%B0%E7%A0%81%E7%AE%A1%E6%A8%A1%E5%9D%97.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line"></span><br><span class="line">sbit DS=P2^<span class="number">2</span>;</span><br><span class="line">sbit DU=P2^<span class="number">6</span>;</span><br><span class="line">sbit WE=P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">unsigned char table0[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;<span class="comment">//无小数点</span></span><br><span class="line">unsigned char table1[]=&#123;<span class="number">0xbf</span>,<span class="number">0x86</span>,<span class="number">0xdb</span>,<span class="number">0xcf</span>,<span class="number">0xe6</span>,<span class="number">0xed</span>,<span class="number">0xfd</span>,<span class="number">0x87</span>,<span class="number">0xff</span>,<span class="number">0xef</span>&#125;;<span class="comment">//有小数点</span></span><br><span class="line">unsigned <span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay(unsigned <span class="built_in">int</span> x)<span class="comment">//延时一定时间</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> i;</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    i=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    x--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> DS18B20_init()<span class="comment">//DS18B20初始化</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> i;</span><br><span class="line">  DS=<span class="number">0</span>;<span class="comment">//MCU拉低电平最少480us，产生复位脉冲，然后释放总线</span></span><br><span class="line">  i=<span class="number">103</span>;<span class="comment">//延时480us~960us</span></span><br><span class="line">  <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  DS=<span class="number">1</span>;<span class="comment">//释放总线</span></span><br><span class="line">  i=<span class="number">4</span>;<span class="comment">//等待15~60us，然后DS18B20拉低电平60~240us表示应答</span></span><br><span class="line">  <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(DS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bit Read_bit()<span class="comment">//读取1比特的数据；“读”时序最少需要60us</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> i;</span><br><span class="line">  bit dat;</span><br><span class="line">  DS=<span class="number">0</span>;</span><br><span class="line">  i++;<span class="comment">//拉低电平最少1us，然后再释放总线</span></span><br><span class="line">  DS=<span class="number">1</span>;</span><br><span class="line">  i++;<span class="comment">//等待一定时间后，再读取电平状态</span></span><br><span class="line">  i++;</span><br><span class="line">  dat=DS;</span><br><span class="line">  i=<span class="number">8</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    i--;<span class="comment">//等待最少60us</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char Read_byte()<span class="comment">//读取1字节的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned char i,j;</span><br><span class="line">  unsigned char dat=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    j=Read_bit();</span><br><span class="line">    dat=(j&lt;&lt;<span class="number">7</span>)|(dat&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_byte(unsigned char dat)<span class="comment">//往DS18B20中写入1字节的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> i;</span><br><span class="line">  unsigned char j;</span><br><span class="line">  bit x;</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)</span><br><span class="line">  &#123;</span><br><span class="line">    x=dat&amp;<span class="number">0x01</span>;<span class="comment">//依次将dat的每一位赋值给x</span></span><br><span class="line">    dat=dat&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x)<span class="comment">//写入“1”</span></span><br><span class="line">    &#123;</span><br><span class="line">      DS=<span class="number">0</span>;<span class="comment">//拉低电平大于1us，在15us内拉高电平</span></span><br><span class="line">      i++;</span><br><span class="line">      i++;</span><br><span class="line">      DS=<span class="number">1</span>;<span class="comment">//“写”时序起始后的15~60us内，DS18B20处于采样状态，在此期间，若总线为高电平，则表示“1”</span></span><br><span class="line">      i=<span class="number">8</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        i--;<span class="comment">//等待最少60us</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//写入“0”；拉低电平60~120us，然后释放总线</span></span><br><span class="line">    &#123;</span><br><span class="line">      DS=<span class="number">0</span>;</span><br><span class="line">      i=<span class="number">8</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;<span class="number">0</span>)<span class="comment">//最少60us</span></span><br><span class="line">      &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      DS=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Change(<span class="built_in">void</span>)<span class="comment">//温度转换，即测量温度</span></span><br><span class="line">&#123;</span><br><span class="line">  DS18B20_init();</span><br><span class="line">  Delay(<span class="number">1</span>);</span><br><span class="line">  Write_byte(<span class="number">0xcc</span>);<span class="comment">//“跳过ROM”操作</span></span><br><span class="line">  Write_byte(<span class="number">0x44</span>);  <span class="comment">//“温度转换”操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned <span class="built_in">int</span> GET()<span class="comment">//获取温度数据</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">float</span> x;</span><br><span class="line">  unsigned char a,b;</span><br><span class="line">  DS18B20_init();</span><br><span class="line">  Delay(<span class="number">1</span>);</span><br><span class="line">  Write_byte(<span class="number">0xcc</span>);</span><br><span class="line">  Write_byte(<span class="number">0xbe</span>);<span class="comment">//读取DS18B20内的RAM的内容</span></span><br><span class="line">  a=Read_byte();<span class="comment">//读取温度值的低8位</span></span><br><span class="line">  b=Read_byte();<span class="comment">//读取温度值的高8位</span></span><br><span class="line">  temp=b;</span><br><span class="line">  temp&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">  temp=temp|a;</span><br><span class="line">  x=temp*<span class="number">0.0625</span>;<span class="comment">//DS18B20默认设置为12位分辨率，即表示分辨率为0.0625摄氏度</span></span><br><span class="line">  temp=x*<span class="number">10</span>+<span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> OUTPUT(unsigned <span class="built_in">int</span> temp)<span class="comment">//数码管显示</span></span><br><span class="line">&#123;</span><br><span class="line">  unsigned char x0,x1,y,x2;</span><br><span class="line">  x0=temp/<span class="number">100</span>;</span><br><span class="line">  y=temp%<span class="number">100</span>;</span><br><span class="line">  x1=y/<span class="number">10</span>;</span><br><span class="line">  x2=y%<span class="number">10</span>;</span><br><span class="line">  DU=<span class="number">0</span>;</span><br><span class="line">  P0=table0[x0];<span class="comment">//显示温度值的十位</span></span><br><span class="line">  DU=<span class="number">1</span>;</span><br><span class="line">  DU=<span class="number">0</span>;</span><br><span class="line">  WE=<span class="number">0</span>;</span><br><span class="line">  P0=<span class="number">0xfe</span>;</span><br><span class="line">  WE=<span class="number">1</span>;</span><br><span class="line">  WE=<span class="number">0</span>;</span><br><span class="line">  Delay(<span class="number">1</span>);</span><br><span class="line">  DU=<span class="number">0</span>;</span><br><span class="line">  P0=table1[x1];<span class="comment">//显示温度值的个位</span></span><br><span class="line">  DU=<span class="number">1</span>;</span><br><span class="line">  DU=<span class="number">0</span>;</span><br><span class="line">  WE=<span class="number">0</span>;</span><br><span class="line">  P0=<span class="number">0xfd</span>;</span><br><span class="line">  WE=<span class="number">1</span>;</span><br><span class="line">  WE=<span class="number">0</span>;</span><br><span class="line">  Delay(<span class="number">1</span>);</span><br><span class="line">  P0=table0[x2];<span class="comment">//显示温度值的十分位</span></span><br><span class="line">  DU=<span class="number">1</span>;</span><br><span class="line">  DU=<span class="number">0</span>;</span><br><span class="line">  P0=<span class="number">0xfb</span>;</span><br><span class="line">  WE=<span class="number">1</span>;</span><br><span class="line">  WE=<span class="number">0</span>;</span><br><span class="line">  Delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Change();</span><br><span class="line">    OUTPUT(GET());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料</strong>：</p><p><a href="https://blog.csdn.net/as480133937/article/details/112604303?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162622984916780357287600%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162622984916780357287600&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112604303.first_rank_v2_pc_rank_v29&utm_term=DS18B20&spm=1018.2226.3001.4187" target="_blank" rel="noopener">【常用传感器】DS18B20温度传感器原理详解及例程代码</a></p><p><a href="https://blog.csdn.net/qq_41422043/article/details/89214676?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162625513816780271524742%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162625513816780271524742&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-6-89214676.pc_v2_rank_blog_default&utm_term=DS18B20&spm=1018.2226.3001.4450" target="_blank" rel="noopener">DS18B20温度传感器</a></p><p><a href="https://blog.csdn.net/qq_37707218/article/details/80529365?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162625513816780271524742%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162625513816780271524742&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-10-80529365.pc_v2_rank_blog_default&utm_term=DS18B20&spm=1018.2226.3001.4450" target="_blank" rel="noopener">Ds18b20的使用</a></p><p><a href="https://blog.csdn.net/u013151320/article/details/50253199?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162625513816780271524742%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162625513816780271524742&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-11-50253199.pc_v2_rank_blog_default&utm_term=DS18B20&spm=1018.2226.3001.4450" target="_blank" rel="noopener">51单片机DS18B20温度传感器详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议简要整理记录</title>
      <link href="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一，是一种网络层协议。ICMP的主要功能是<strong>确认IP包是否成功送达目的地址，通知发送过程中IP包被丢弃的原因</strong>，可用于检查网络是否正常、网络配置是否正确、设备是否异常等信息，方便进行网络问题诊断。</p><p>ICMP消息通过IP进行传输，但并不是让IP成为一种可靠的协议，而是对传输中发生的问题进行反馈。ICMP消息的传输同样得不到可靠性保证，也有可能在传输过程中丢失。</p><a id="more"></a><h2 id="ICMP消息封装"><a href="#ICMP消息封装" class="headerlink" title="ICMP消息封装"></a>ICMP消息封装</h2><h3 id="ICMP报文结构"><a href="#ICMP报文结构" class="headerlink" title="ICMP报文结构"></a>ICMP报文结构</h3><h4 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h4><p>ICMP报头从IP报头的第160位开始（IP首部20字节）（除非使用了IP报头的可选部分）。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/ICMP%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E6%8A%A5%E5%A4%B4.png" alt></p><ul><li><strong>Type</strong>：ICMP的类型，标识生成的错误报文；</li><li><strong>Code</strong>：进一步划分ICMP的类型，该字段用来查找产生错误的原因；</li><li><strong>Checksum</strong>：Internet校验和，用于进行错误检查；</li><li><strong>Rest of Header</strong>：报头的其余部分，四字节字段，内容根据<strong>Type</strong>和<strong>Code</strong>而有所不同。</li></ul><h4 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h4><p>填充的数据紧接在ICMP报头的后面（以8位为一组）：</p><ul><li>Linux的<code>ping</code>工具填充的ICMP除了8个8位组的报头以外，默认情况下还另外填充数据使得总大小为64字节；</li><li>Windows的<code>ping.exe</code>填充的ICMP除了8个8位组的报头以外，默认情况下还另外填充数据使得总大小为40字节。</li></ul><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/ICMP%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/0.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/3.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/5.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/8.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/11.png" alt></p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/9.png" alt></p><h3 id="常见的ICMP消息类型"><a href="#常见的ICMP消息类型" class="headerlink" title="常见的ICMP消息类型"></a>常见的ICMP消息类型</h3><ul><li><p><strong>回送请求信息</strong>（Echo Request）：由源设备（主机或路由器等）向一个指定的目的设备发出的请求，用于测试目的设备是否可达。</p></li><li><p><strong>回送响应信息</strong>（Echo Reply）：对<code>Echo Request</code>的响应；目的设备发送<code>Echo Reply</code>来响应收到的<code>Echo Request</code>；<code>ping</code>命令就是使用<code>Echo Request</code>和<code>Echo Reply</code>来实现的。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E5%9B%9E%E9%80%81%E4%BF%A1%E6%81%AF.png" alt></p></li><li><p><strong>目的不可达</strong>（Destination Unreachable）：路由器无法将IP包发送给目的地址时，会给源设备返回一个<code>Destination Unreachable</code>消息，该消息包含不可达的具体原因。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BE.png" alt></p></li><li><p><strong>参数问题</strong>（Parameter Problem）：路由器发现IP包头出现错误或非法值后，向源设备发送一个<code>Parameter Problem</code>消息，该信息包含有问题的IP头、或错误字段的提示信息。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%E6%B6%88%E6%81%AF.png" alt></p></li><li><p><strong>重定向</strong>（Redirect）：若路由器发现一条更优的路径发送数据，就会返回一个<code>Redirect</code>消息给主机，该消息包含最合适的路由信息和源数据。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt></p></li><li><p><strong>超时</strong>（Time Exceeded）：IP包中有一个字段是<code>TTL</code>（生存周期），它的值每经过一次路由器就减1，直到减到0时，IP包会被丢弃。此时，路由器会发送一个<code>Time Exceeded</code>消息给源设备，并通知IP包已被丢弃。可以通过设置一个较小的<code>TTL</code>值来控制IP包的可达范围。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E8%B6%85%E6%97%B6.png" alt></p></li><li><p><strong>时间戳请求/时间戳响应</strong>（Timestamp Request / Timestamp Reply）：时间戳可以记录ICMP消息一次往返所需的时间。源设备发送一个带有发送时间的<code>Timestamp Request</code>消息，目的设备收到后，发送一个带有源设备发送时间、目的设备接收时间以及目的设备发送时间的<code>Timestamp Reply</code>消息。源设备收到<code>Timestamp Reply</code>时，记录到达时间。这些时间戳可以估计网络上的传输时间。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E6%97%B6%E9%97%B4%E6%88%B3.png" alt></p></li></ul><h2 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h2><p>ICMP被广泛应用于网络测试，例如网络测试工具<code>ping</code>和<code>tracert</code>。</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>通过<code>ping</code>可以测试网络的可达性。使用<code>ping</code>命令时，源设备向目的设备发送<code>Echo request</code>消息，目的设备收到<code>Echo request</code>消息后，向源设备回应一个<code>Echo reply</code>消息，可知目的设备是可达的。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/ping.png" alt></p><p>若中间某个路由器没有到达目的网络的路由，就会向源设备回应一个<code>Destination Unreachable</code>消息，告知目的设备不可达。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/ping%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BE.png" alt></p><p>若源主机在一定时间内无法收到回应报文，就认为目的设备不可达，并显示超时。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/%E8%B6%85%E6%97%B60.png" alt></p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>工具<code>tracert</code>可以查看数据包的整条传输路径，包括途中经过的中间设备。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/tracert.png" alt></p><p>使用<code>tracert</code>命令时，源设备的<code>tracert</code>逐跳发送数据包，并等待每一个响应报文。发送第一个数据包时，<code>TTL</code>值设为1，第一个路由器收到数据包后，<code>TTL</code>值减1，随即丢弃数据包，并返回一个<code>Time Exceeded</code>消息。源设备的<code>tracert</code>收到响应报文后，即可获得该响应报文的源IP地址（路径上的第一个路由器地址）。然后，<code>tracert</code>发送一个<code>TTL</code>值为2的数据包，第一个路由器将<code>TTL</code>值减1，并转发数据包。第二个路由器再将<code>TTL</code>值减1，丢弃数据包并返回一个<code>Time Exceeded</code>消息。<code>tracert</code>收到响应报文后，即可获得该响应报文的源IP地址（路径上的第二个路由器地址）。以此类推，<code>tracert</code>逐跳获得每一个路由器的地址，并探测到目的设备的可达性。</p><p><img src="/2021/07/09/ICMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/tracert0.png" alt></p><hr><p><strong>参考资料</strong>：</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">互联网控制消息协议- 维基百科，自由的百科全书</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDYxNDU2Ng==&mid=2247503110&idx=1&sn=f04e4641e08d4007a4f7cf052d758e50&chksm=c01e604ff769e959ba4fe5b2c450bb81bf23bb1f577b5e78d9fc687f3d589a89ac0db86ccb8d&scene=178&cur_album_id=1877121685477195781#rd" target="_blank" rel="noopener">24 张图搞定 ICMP ：最常用的网络命令 ping 和 tracert</a></p><p><a href="https://blog.csdn.net/qq_31967569/article/details/90673732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162576126616780255222868%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162576126616780255222868&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-11-90673732.first_rank_v2_pc_rank_v29&utm_term=icmp%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187" target="_blank" rel="noopener">完全理解icmp协议</a></p><p><a href="https://blog.csdn.net/qq_21231413/article/details/88171590?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162576126616780269868847%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162576126616780269868847&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88171590.first_rank_v2_pc_rank_v29&utm_term=icmp%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4187" target="_blank" rel="noopener">ICMP协议</a></p><p><a href="https://blog.csdn.net/baidu_37964071/article/details/80514340" target="_blank" rel="noopener">ICMP协议详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议简要记录</title>
      <link href="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>地址解析协议（英语：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址（IP地址）来找寻数据链路层地址（MAC地址）的网络传输协议；ARP协议是以IP地址为线索，定位下一个应接收数据包的主机MAC地址，若目标主机不在同一链路上，则会查找下一跳路由器的MAC地址。ARP协议在IPv4中极其重要，<strong>只适用于IPv4</strong>，而IPv6使用邻居发现协议（英语：Neighbor Discovery Protocol简称：NDP或ND）。</p><a id="more"></a><h2 id="ARP的工作机制"><a href="#ARP的工作机制" class="headerlink" title="ARP的工作机制"></a>ARP的工作机制</h2><p>假设主机<code>A</code>向同一网段上的主机<code>B</code>发送数据。主机<code>A</code>的IP地址为<code>10.0.0.1</code>，主机<code>B</code>的IP地址为<code>10.0.0.2</code>，主机<code>C</code>的IP地址为<code>10.0.0.3</code>。三台主机均不知道对方的MAC地址。ARP地址解析过程如下：</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt></p><p>主机<code>A</code>首先检查自己的ARP缓存表，确定是否有主机<code>B</code>的IP地址对应表项。如果有，则直接使用表项中的MAC地址进行封装，封装成帧后发送给主机<code>B</code>。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E4%B8%BB%E6%9C%BAA%E6%9F%A5%E7%9C%8BARP%E8%A1%A8.png" alt></p><p>若主机<code>A</code>的ARP缓存表没有对应的表项，就<strong>广播</strong>发送一个<strong>ARP请求报文</strong>，源IP地址和源MAC地址是主机<code>A</code>，目的IP地址是主机<code>B</code>，<strong>目的MAC地址</strong>是广播MAC地址，即<strong><code>FFFF-FFFF-FFFF</code></strong>。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E8%AF%B7%E6%B1%82.png" alt></p><p>当主机<code>B</code>发现ARP请求报文中的目的IP地址是自己时，主机<code>B</code>发送<strong>ARP响应报文</strong>给主机<code>A</code>，源IP地址和源MAC地址是主机<code>B</code>，目的IP地址和目的MAC地址是主机<code>A</code>；同时，<strong>主机<code>B</code>的ARP缓存表记录主机<code>A</code>的IP地址和MAC地址的对应关系</strong>。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E5%93%8D%E5%BA%94.png" alt></p><p>主机<code>C</code>也收到了ARP请求报文，但目的IP地址不是自己，所以不会进行响应。但<strong>主机<code>C</code>会将主机<code>A</code>的映射关系添加到自己的ARP缓存表中</strong>，并丢弃ARP请求报文。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E8%A1%A8.png" alt></p><p>主机<code>A</code>收到ARP响应报文后，添加主机<code>B</code>的映射关系，<strong>同时用主机<code>B</code>的MAC地址作为目的MAC地址封装成帧，并发送给主机<code>B</code></strong>。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E8%8E%B7%E5%8F%96MAC%E5%9C%B0%E5%9D%80.png" alt></p><p>ARP缓存表中的表项在老化时间（aging time）内是有效的，若老化时间内未被使用，表项就会被删除。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E7%BC%93%E5%AD%98.png" alt></p><p>ARP表项分为<strong>动态ARP表项</strong>和<strong>静态ARP表项</strong>：</p><ul><li><strong>动态ARP表项</strong>由ARP动态获取，<strong>若老化时间内未被使用，表项就会被自动删除</strong>；</li><li><strong>静态ARP表项</strong>是<strong>手动</strong>配置，<strong>不会老化</strong>，<strong>优先级高于动态ARP表项</strong>，<strong>可以将相应的动态ARP表项覆盖</strong>。</li></ul><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E8%A1%A8%E9%A1%B9%E7%B1%BB%E5%9E%8B.png" alt></p><h2 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h2><p>ARP广播报文会被路由器隔离，没有默认网关、网段不同的主机互相通信时，连接这两个网络的路由器可以响应这个ARP请求，该过程叫做<code>代理ARP</code>（Proxy ARP）。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E4%BB%A3%E7%90%86ARP.png" alt></p><p>主机<code>A</code>与另一网段的主机<code>B</code>通信，主机<code>A</code>直接发送ARP请求，解析主机<code>B</code>的MAC地址。运行了代理ARP的路由器收到ARP请求后，代替主机<code>A</code>在<code>20.0.0.0</code>网段发出ARP请求，解析主机<code>B</code>的地址。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E4%BB%A3%E7%90%86ARP%E8%AF%B7%E6%B1%82.png" alt></p><p>主机B收到路由器发出的ARP请求后，返回ARP响应报文，告知自己的MAC地址是<code>2222-2222-2222</code>。路由器收到ARP响应后，也向主机<code>A</code>返回ARP响应报文，但目的MAC地址是与<code>10.0.0.0</code>网段连接的端口MAC地址<code>1010-1010-1010</code>。主机<code>A</code>收到报文后，在ARP缓存表中添加IP地址<code>20.0.0.1</code>和MAC地址<code>1010-1010-1010</code>的映射表项。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E4%BB%A3%E7%90%86ARP%E5%93%8D%E5%BA%94.png" alt></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>主机不用了解网络的物理详情，可以假定是一个平面网络，只需通过发送ARP请求就能达到目标；</li><li>屏蔽了分离的网络，主机不用修改IP地址和子网掩码就可以与现有的网络互通。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>增加了网段中的ARP流量，不适合用于大规模网络；</li><li>主机需要更大的ARP缓存表才能处理IP地址和MAC地址的映射；</li><li>安全性降低。</li></ul><h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p><strong>免费ARP</strong>是一种特殊的ARP请求，当主机启动的时候，通过发送一个免费ARP请求来请求<strong>自己</strong>的IP地址的MAC地址。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%85%8D%E8%B4%B9ARP.png" alt></p><p>普通ARP报文中的目的IP地址是其它主机的IP地址；而免费ARP报文中的<strong>目的IP地址是自己的IP地址</strong>。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%B9%BF%E6%92%AD%E5%85%8D%E8%B4%B9ARP.png" alt></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>起到一个<strong>宣告</strong>作用。免费ARP将数据包广播发送，<strong>不需要回应</strong>，只为告知其它主机自己的IP地址和MAC地址。</li><li><strong>检测IP地址冲突</strong>。当一台主机发送了免费ARP请求报文后，若<strong>收到ARP响应报文</strong>，则说明网络内已存在使用该IP地址的主机。</li><li>更新其它主机的ARP缓存表。若某主机因某些原因导致MAC地址变更，而其它主机的ARP缓存表仍保留着该主机原来的MAC地址，则可以通过免费ARP来更新其它主机的ARP缓存表。</li></ul><h2 id="ARP报文"><a href="#ARP报文" class="headerlink" title="ARP报文"></a>ARP报文</h2><p>ARP报文分为<strong>ARP请求报文</strong>和<strong>ARP响应报文</strong>，它们的报文格式相同，但各字段的取值不同。</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt></p><p>ARP报文中各字段的含义如下：</p><p><img src="/2021/07/02/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/ARP%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89.png" alt></p><hr><p><strong>参考资料</strong>：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDYxNDU2Ng==&mid=2247503273&idx=1&sn=5ed5b29d9fbf3b92b5863f44719410c7&chksm=c01e60e0f769e9f609b9db5335919906a5a4fb01cbde8aa4f7689cf7829def3a85536008e6e4&scene=178&cur_album_id=1877121685477195781#rd" target="_blank" rel="noopener">36 张图详解 ARP ：网络世界没有我，你哪也别想去</a></p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/dynamic-address-allocation-resolution/13718-5.pdf" target="_blank" rel="noopener">代理ARP - Cisco</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/14265315.html" target="_blank" rel="noopener">一文详解 ARP 协议</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DHCP协议简要记录</title>
      <link href="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>动态主机设置协议（英语：Dynamic Host Configuration Protocol，缩写：DHCP），又称动态主机组态协定，是一个用于IP网络的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要有两个用途：</p><ul><li>用于内部网或网络服务供应商自动分配IP地址给用户；</li><li>用于内部网管理员对所有电脑作中央管理。</li></ul><a id="more"></a><h2 id="DHCP分配机制"><a href="#DHCP分配机制" class="headerlink" title="DHCP分配机制"></a>DHCP分配机制</h2><p>DHCP提供了两种地址分配机制，可以根据网络需求为不同的客户端选择不同的分配策略。</p><ul><li><strong>动态分配机制</strong>：通过DHCP为客户端分配一个<strong>有使用期限</strong>的IP地址。若客户端没有及时续约，到达使用期限后，该IP地址则可能会被其它客户端使用。</li><li><strong>静态分配机制</strong>：通过DHCP为特定的客户端分配<strong>固定</strong>的IP地址。该IP地址可被此客户端<strong>永久使用</strong>。</li></ul><p>DHCP服务端为DHCP客户端分配IP地址时，采用的顺序如下：</p><ul><li>DHCP服务端中与DHCP客户端的MAC地址<strong>静态绑定</strong>的IP地址；</li><li>DHCP客户端<strong>曾经使用过</strong>的IP地址；</li><li>最先找到的可用IP地址；</li><li>若无可用的IP地址，则依次查询<strong>超过租期、发生冲突</strong>的IP地址，若找到就进行分配，否则报错处理。</li></ul><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E9%A1%BA%E5%BA%8F.png" alt></p><p>因此，DHCP客户端重启后，也能获得相同的IP地址。</p><h2 id="DHCP基本流程"><a href="#DHCP基本流程" class="headerlink" title="DHCP基本流程"></a>DHCP基本流程</h2><p>DHCP协议报文采用<strong>UDP</strong>方式封装，DHCP<strong>服务端</strong>侦听<strong>67</strong>号端口，DHCP<strong>客户端</strong>侦听<strong>68</strong>号端口。</p><p>DHCP的基本工作流程分为4个阶段：发现阶段、提供阶段、请求阶段、确认阶段。</p><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80.png" alt></p><h3 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h3><p>DHCP客户端在本地网段中<strong>广播</strong>一个<strong><code>DHCP Discover</code></strong>报文来寻找能够分配IP地址的DHCP服务端。</p><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/Discover%E6%8A%A5%E6%96%87.png" alt></p><p>因为客户端此时还不知道自己以及服务端的地址，所以<strong>源IP地址</strong>为<strong><code>0.0.0.0</code></strong>，<strong>目标MAC地址</strong>为<strong><code>255.255.255.255</code></strong>，本地网段中的每一台主机均能收到报文，但只有DHCP服务端才会响应。</p><p><code>DHCP Discover</code>报文还带有一个<strong><code>XID</code></strong>字段用于辨别发送端和接收端。</p><h3 id="提供阶段"><a href="#提供阶段" class="headerlink" title="提供阶段"></a>提供阶段</h3><p>本地网段的DHCP服务端收到<code>Discover报文</code>后，通过<strong>广播</strong>发送<strong><code>DHCP Offer</code></strong>报文，<strong>目标MAC地址</strong>为<strong><code>255.255.255.255</code></strong>，报文中包含了服务端提供的IP地址、租期等信息。</p><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/Offer%E6%8A%A5%E6%96%87.png" alt></p><p>DHCP客户端通过对比<code>DHCP Discover</code>报文和<code>DHCP Offer</code>报文中的<code>XID</code>字段是否相同，来判断<code>DHCP Offer</code>是否发送给自己。</p><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><p>若本地网段中存在多个DHCP服务端，则每个DHCP服务端均会回应<code>DHCP Offer</code>报文。通常，DHCP客户端会选择最先收到的<code>DHCP Offer</code>报文，并<strong>广播<code>DHCP Request</code></strong>报文来表明选择哪个DHCP服务端。</p><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/Request%E6%8A%A5%E6%96%87.png" alt></p><p>由于还没得到DHCP服务端的最终确认，<strong>DHCP客户端依然以<code>0.0.0.0</code>为源IP地址、<code>255.255.255.255</code>为目标MAC地址来进行广播</strong>。</p><p>若DHCP客户端在一定时间内一直没收到<code>DHCP Offer</code>报文，则重新发送<code>DHCP Discover</code>报文。</p><h3 id="确认阶段"><a href="#确认阶段" class="headerlink" title="确认阶段"></a>确认阶段</h3><p>DHCP服务端收到<code>DHCP Request</code>广播报文后，发送<strong><code>DHCP Ack</code></strong>报文作为回应，<code>DHCP Ack</code>报文包含有服务端提供的IP地址和其它网络参数。<code>DHCP Ack</code>报文和<code>DHCP Offer</code>报文的参数不能有冲突，否则DHCP服务端会回应<strong><code>DHCP Nak</code></strong>报文。</p><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/Ack%E6%8A%A5%E6%96%87.png" alt></p><p>当DHCP客户端收到<code>DHCP Ack</code>报文后，会发送<strong><code>免费ARP</code></strong>报文来探测IP地址是否正被其它客户端使用。</p><p>另外，除了DHCP客户端选择的DHCP服务端外，其它服务端都将收回此前为客户端提供的IP地址。</p><h2 id="DHCP租期"><a href="#DHCP租期" class="headerlink" title="DHCP租期"></a>DHCP租期</h2><p>DHCP服务端每次为DHCP客户端分配一个IP地址时，会约定一个IP地址的租期，通常是24小时。</p><p>若设定<code>T1</code>时刻是租期到一半的时候，<code>T2</code>时刻是租期到87.5%的时候；在<code>T1</code>时刻，DHCP客户端会<strong>单播</strong>一个<strong><code>DHCP Request</code></strong>报文给DHCP服务端，请求续租IP地址，若客户端收到服务端回应的<code>DHCP Ack</code>报文，则表示续租成功；若直到<code>T2</code>时刻，DHCP客户端还没收到<code>DHCP Ack</code>报文，就会<strong>广播</strong>一个<strong><code>DHCP Request</code></strong>报文，继续请求续租IP地址，若客户端收到<code>DHCP Ack</code>报文，则表示续租成功；</p><p>若直到租期到期，DHCP客户端都没收到<code>DHCP Ack</code>报文，就必须停止使用原来的IP地址。DHCP客户端将从发现阶段开始，<strong>重新申请</strong>一个IP地址。</p><h2 id="DHCP报文（补充）"><a href="#DHCP报文（补充）" class="headerlink" title="DHCP报文（补充）"></a>DHCP报文（补充）</h2><p>DHCP主要的报文类型有8种，常见的5种报文类型有：<code>DHCP Discover</code>、<code>DHCP Offer</code>、<code>DHCP Request</code>、<code>DHCP Ack</code>和<code>DHCP Release</code>，用得少的3种报文类型有：<code>DHCP Nak</code>、<code>DHCP Decline</code>和<code>DHCP Inform</code>。</p><ul><li><p><code>DHCP Decline</code>报文</p><p>当DHCP客户端收到<code>DHCP Ack</code>报文后，会发送<code>免费ARP</code>报文，若检测到申请的IP地址正被其它客户端使用，则DHCP客户端发送<code>DHCP Decline</code>报文，拒绝分配的IP地址，并重新向DHCP服务端申请IP地址。</p></li><li><p><code>DHCP Release</code>报文</p><p>当DHCP客户端想要释放获得的IP地址时，就向DHCP服务端发送<code>DHCP Release</code>报文，DHCP服务端收到报文后，可将该IP地址分配给其它客户端。</p></li><li><p><code>DHCP Inform</code>报文</p><p>DHCP客户端通过手动方式获得IP地址后，还想向DHCP服务端获取更多网络参数（例如默认网关地址、DNS服务器地址）时，客户端就向服务端发送<code>DHCP Inform</code>报文进行申请。</p></li></ul><h2 id="客户端状态机"><a href="#客户端状态机" class="headerlink" title="客户端状态机"></a>客户端状态机</h2><p><img src="/2021/06/29/DHCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt></p><hr><p><strong>参考资料</strong>：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDYxNDU2Ng==&mid=2247503018&idx=1&sn=0157d859b119114988c2212653ac1c75&chksm=c01e61e3f769e8f58aba69037eb56d9f34f68fb2e2fb622336cf8a50f1d999156ce71ec490b2&scene=178&cur_album_id=1877121685477195781#rd" target="_blank" rel="noopener">37 张图详解 DHCP ：给你 IP 地址的隐形人</a></p><p><a href="https://blog.csdn.net/viphl/article/details/90711587?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162488698116780274162221%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162488698116780274162221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-19-90711587.pc_search_result_cache&utm_term=DHCP&spm=1018.2226.3001.4187" target="_blank" rel="noopener">DHCP工作原理</a></p><p><a href="https://blog.csdn.net/qq_41636653/article/details/81751060?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162488698116780274162221%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162488698116780274162221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-81751060.pc_search_result_cache&utm_term=DHCP&spm=1018.2226.3001.4187" target="_blank" rel="noopener">DHCP原理及配置</a></p><p><a href="https://blog.csdn.net/u011857683/article/details/83019895?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162488698116780274162221%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162488698116780274162221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-83019895.pc_search_result_cache&utm_term=DHCP&spm=1018.2226.3001.4187" target="_blank" rel="noopener">DHCP基本概念</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">动态主机设置协议- 维基百科，自由的百科全书</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS解析简要笔记</title>
      <link href="/2021/06/26/DNS%E8%A7%A3%E6%9E%90%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/26/DNS%E8%A7%A3%E6%9E%90%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>DNS域名解析包括两种查询方式，一种是<code>递归查询</code>，另一种是<code>迭代查询</code>。客户端在查询IP地址时，向本地域名服务器进行递归查询；若本地域名服务器的数据库有相应数据，则直接返回相应数据；若无相应数据，则本地域名服务器从向根域名服务器开始，进行迭代查询，直至获得最终结果。</p><a id="more"></a><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>DNS服务器若不能直接响应解析请求，它将继续请求其它的DNS服务器，直到获得最终的查询结果。查询结果可以是<strong>域名主机的IP地址</strong>，或者是<strong>域名无法解析</strong>。无论哪种结果，DNS服务器都会将结果返回给客户端。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>当本地域名服务器接收了客户端的查询请求后，本地域名服务器将以客户端的身份向其它DNS服务器查询结果，最后本地域名服务器将最终结果反馈给客户端。<strong>客户端只需要等待最终结果，不需要理会查询过程和中间结果。</strong></p><p><img src="/2021/06/26/DNS%E8%A7%A3%E6%9E%90%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt></p><h2 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h2><p>如果DNS服务器查找不到相应记录，则会向客户端返回一个可能知道结果的域名服务器IP地址，由客户端继续向该可能知道结果的域名服务器发送查询请求，该域名服务器可能会返回给客户端另一个域名服务器IP地址，或返回最终查询结果。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>本地域名服务器向根域名服务器发送查询请求，根域名服务器并没有相应记录，只向本地服务器返回一个顶级域名服务器IP地址，引导本地域名服务器向该顶级域名服务器进行查询······直至最后，本地域名服务器获得最终结果。</p><p><img src="/2021/06/26/DNS%E8%A7%A3%E6%9E%90%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" alt></p><h2 id="DNS传输层协议"><a href="#DNS传输层协议" class="headerlink" title="DNS传输层协议"></a>DNS传输层协议</h2><p>DNS域名服务器使用53号端口，且同时支持UDP和TCP协议。DNS在进行区域传输（即主服务器与用作冗余备份的从服务器进行数据同步）的时候，因为传送的数据量大，所以使用TCP协议；DNS在进行域名解析的时候，因为数据传送量小，所以使用UDP协议，不需要经过TCP的三次握手，响应速度更快，服务器负载更低。</p><hr><p><strong>参考资料</strong>：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDYxNDU2Ng==&mid=2247503177&idx=1&sn=b09bf1cb0644a9ff5b33c7858b7fb4ac&chksm=c01e6000f769e916e3c2f27cebd794c19c9fef73d0e7c859d95de6937829f15e4edd2ae3ae3c&scene=178&cur_album_id=1877121685477195781#rd" target="_blank" rel="noopener">36 张图详解 DNS ：网络世界的导航</a></p><p><a href="https://blog.csdn.net/baidu_37964071/article/details/80500825?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162469543016780264022376%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162469543016780264022376&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~baidu_landing_v2~default-6-80500825.nonecase&utm_term=DNS%E6%9F%A5%E8%AF%A2&spm=1018.2226.3001.4450" target="_blank" rel="noopener">DNS（域名解析协议）详解</a></p><p><a href="https://www.cnblogs.com/wuyepeng/p/9835839.html" target="_blank" rel="noopener">DNS用的是TCP协议还是UDP协议</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于51单片机的红外解码</title>
      <link href="/2021/06/04/%E5%9F%BA%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81/"/>
      <url>/2021/06/04/%E5%9F%BA%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>记录一次使用NEC协议编码的红外遥控信号的解码方式。</p><a id="more"></a><h2 id="NEC协议简要记录"><a href="#NEC协议简要记录" class="headerlink" title="NEC协议简要记录"></a>NEC协议简要记录</h2><p>NEC协议是红外遥控协议的一种，由其编码的数据帧分别由引导码、用户码、用户码（或者是用户码的反码）、数据码（即按键码）和数据码的反码这五部分组成，最后还有一个停止位。引导码表示即将开始传输32位的二进制数据；引导码之后的部分长度为4字节一共32位；第一字节为用户码；第二字节可能是用户码，也可能是用户码的反码，具体由厂商决定；第三字节是当前按键的按键码；第四字节是按键码的反码；停止位主要起隔离作用，一般不进行判断，也不需要理会。每一字节的数据从低位到高位依次发送。</p><h3 id="NEC协议编码方式"><a href="#NEC协议编码方式" class="headerlink" title="NEC协议编码方式"></a>NEC协议编码方式</h3><p>NEC协议的每一比特数据本身也需要进行编码，编码后再进行载波调制。</p><ul><li><strong>引导码</strong>：9ms的高电平 + 4.5ms的低电平</li><li><strong>比特值<code>0</code></strong>：0.56ms的高电平 + 0.56ms的低电平</li><li><strong>比特值<code>1</code></strong>：0.56ms的高电平 + 1.68ms的低电平</li></ul><p>发射端和接收端的电平相反，即：</p><ul><li><strong>引导码</strong>：9ms的低电平 + 4.5ms的高电平</li><li><strong>比特值<code>0</code></strong>：0.56ms的低电平 + 0.56ms的高电平</li><li><strong>比特值<code>1</code></strong>：0.56ms的低电平 + 1.68ms的高电平</li></ul><h2 id="源程序记录"><a href="#源程序记录" class="headerlink" title="源程序记录"></a>源程序记录</h2><p>按下红外遥控器的任一按键<code>1</code>~<code>9</code>，即可在开发板的数码管模块的左边第一位上显示对应的按键数字。</p><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">sbit OUTPUT=P3^<span class="number">2</span>;<span class="comment">//P3.2引脚为单片机外部中断0的触发引脚，同时连接红外接收模块IR 1838的输出端，在模块输出信号的同时进入外部中断0的服务函数</span></span><br><span class="line">sbit Wei=P2^<span class="number">7</span>;<span class="comment">//数码管模块位锁存</span></span><br><span class="line"></span><br><span class="line">unsigned char Code[<span class="number">9</span>]=&#123;<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;<span class="comment">//数码管显示从“1”到“9”的段码</span></span><br><span class="line">unsigned char Code0[<span class="number">4</span>];</span><br><span class="line">unsigned char Code1[<span class="number">33</span>];</span><br><span class="line">unsigned char time;</span><br><span class="line"></span><br><span class="line">bit m,n;<span class="comment">//定义两个标志位；标志位m表示一帧数据解码完毕，标志位n表示一帧数据接收完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> ET_0() <span class="built_in">int</span>errupt <span class="number">1</span> using <span class="number">1</span><span class="comment">//定时器0中断</span></span><br><span class="line">&#123;</span><br><span class="line">time++;<span class="comment">//对两个下降沿之间的时间间隔进行计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> EX_0() <span class="built_in">int</span>errupt <span class="number">0</span><span class="comment">//外部中断0</span></span><br><span class="line">&#123;</span><br><span class="line">static unsigned char i;</span><br><span class="line">static bit START;</span><br><span class="line"><span class="keyword">if</span>(START)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(time&lt;<span class="number">63</span>&amp;&amp;time&gt;=<span class="number">33</span>)<span class="comment">//引导码，9ms+4.5ms</span></span><br><span class="line">&#123;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Code1[i]=time;<span class="comment">//存储两个下降沿之间的时间间隔，将用于数据帧的“0”和“1”</span></span><br><span class="line">time=<span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">33</span>)</span><br><span class="line">&#123;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">time=<span class="number">0</span>;</span><br><span class="line">START=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> ET0_init()<span class="comment">//定时器0中断初始化</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD=<span class="number">0x02</span>;<span class="comment">//定时器0工作在方式2</span></span><br><span class="line">TH0=<span class="number">0x00</span>;<span class="comment">//重载值</span></span><br><span class="line">TL0=<span class="number">0x00</span>;<span class="comment">//初始值</span></span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">//开启定时器0中断</span></span><br><span class="line">TR0=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> EX0_init()<span class="comment">//外部中断0初始化</span></span><br><span class="line">&#123;</span><br><span class="line">IT0=<span class="number">1</span>;<span class="comment">//设置外部中断0为下降沿触发</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//开启外部中断0</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开启总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> DECODE()<span class="comment">//红外解码</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j,k;</span><br><span class="line">unsigned char x,y;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//对数据帧中的4个字节进行处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)<span class="comment">//对一个字节中的8位进行处理</span></span><br><span class="line">&#123;</span><br><span class="line">x=Code1[k];</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">7</span>)<span class="comment">//时间间隔大于某值则为1，与晶振（12MHz）相关，允许误差</span></span><br><span class="line">&#123;</span><br><span class="line">y|=<span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&lt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">Code0[i]=y;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> NUMBER()<span class="comment">//将红外遥控器的按键值转换为数码管的段值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(Code0[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0c</span>:P0=Code[<span class="number">0</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x18</span>:P0=Code[<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x5e</span>:P0=Code[<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x08</span>:P0=Code[<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1c</span>:P0=Code[<span class="number">4</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x5a</span>:P0=Code[<span class="number">5</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x42</span>:P0=Code[<span class="number">6</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x52</span>:P0=Code[<span class="number">7</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x4a</span>:P0=Code[<span class="number">8</span>];<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">ET0_init();</span><br><span class="line">EX0_init();</span><br><span class="line"></span><br><span class="line">P0=<span class="number">0xfe</span>;<span class="comment">//取数码管模块左边第一位选通</span></span><br><span class="line">Wei=<span class="number">1</span>;</span><br><span class="line">Wei=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">DECODE();</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m)</span><br><span class="line">&#123;</span><br><span class="line">NUMBER();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/2021/06/04/%E5%9F%BA%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F.png" alt></p><p><img src="/2021/06/04/%E5%9F%BA%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81/%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6%E6%A8%A1%E5%9D%97.png" alt></p><p><img src="/2021/06/04/%E5%9F%BA%E4%BA%8E51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81/6%E4%BD%8D%E5%85%B1%E9%98%B4%E6%95%B0%E7%A0%81%E7%AE%A1%E6%A8%A1%E5%9D%97.png" alt></p><hr><p><strong>参考资料</strong>：</p><p><a href="https://blog.csdn.net/qq_42012736/article/details/80555951?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162277608116780357211528%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162277608116780357211528&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80555951.first_rank_v2_pc_rank_v29&utm_term=51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81&spm=1018.2226.3001.4187" target="_blank" rel="noopener">51单片机红外通信解码教程</a></p><p><a href="https://blog.csdn.net/qq_43743762/article/details/89421704?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162277608116780357211528%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162277608116780357211528&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-89421704.first_rank_v2_pc_rank_v29&utm_term=51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81&spm=1018.2226.3001.4187" target="_blank" rel="noopener">51单片机—红外遥控</a></p><p><a href="https://blog.csdn.net/hltx666/article/details/98317628?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162277619416780261996871%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162277619416780261996871&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-7-98317628.nonecase&utm_term=51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81&spm=1018.2226.3001.4450" target="_blank" rel="noopener">51单片机红外通讯</a></p><p><a href="https://blog.csdn.net/yannanxiu/article/details/26171705?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162277634016780265479139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162277634016780265479139&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-3-26171705.nonecase&utm_term=NEC%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4450" target="_blank" rel="noopener">红外遥控NEC协议使用总结</a></p><p><a href="https://blog.csdn.net/huan447882949/article/details/79743142?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162277634016780265479139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162277634016780265479139&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-79743142.nonecase&utm_term=NEC%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4450" target="_blank" rel="noopener">IR–NEC协议</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP&amp;UDP简要整理</title>
      <link href="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/"/>
      <url>/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>简要记录一下TCP/IP模型、TCP的三次握手与四次挥手、TCP&amp;UDP的比较。</p><a id="more"></a><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>TCP/IP模型是互联网的基础，包括了一系列网络协议，例如TCP、UDP、IP、FTP、HTTP等，这些协议可以分为四层、由上至下分别为应用层、传输层、网络层、链路层。</p><h3 id="TCP-IP模型-amp-OSI七层模型"><a href="#TCP-IP模型-amp-OSI七层模型" class="headerlink" title="TCP/IP模型&amp;OSI七层模型"></a>TCP/IP模型&amp;OSI七层模型</h3><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%A6%82%E5%BF%B5%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt></p><h2 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h2><h3 id="建立连接——三次握手"><a href="#建立连接——三次握手" class="headerlink" title="建立连接——三次握手"></a>建立连接——三次握手</h3><ul><li><strong>第一次握手</strong>：客户端向服务端发送建立连接请求报文<strong>连接<code>SYN</code></strong>（序号<code>Seq</code>=x）</li><li><strong>第二次握手</strong>：服务端返回<strong>连接<code>SYN</code></strong>和<strong>确认<code>ACK</code></strong>（序号<code>Seq</code>=y、确认号<code>Ack</code>=x+1）</li><li><strong>第三次握手</strong>：客户端发送<strong>确认<code>ACK</code></strong>（确认号<code>Ack</code>=y+1）</li></ul><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt></p><p>若在一定时间内没有接收到确认应答，发送端会认为数据已经丢失，并进行重发；<strong>但实际上，发送端没有接收到确认应答，不一定是数据丢失，也可能是返回的确认应答在途中丢失，也会导致发送端重发；此外，也可能是确认应答延迟到达，发送端重发数据后才接收到</strong>。数据被重发后，<strong>若还接收不到确认应答，则再次发送。这时，等待确认应答的时间将会以2倍、4倍的指数函数增长</strong>；但<strong>数据也不会无限重发，达到一定的重发次数后，还没接收到确认应答，就会认为网络或对端主机发送异常，强制关闭连接，并通知应用通信异常，强行终止</strong>。</p><p>每一次传输数据时，TCP都会标记段的序列号，以便对方确认。<strong>在TCP中并不直接确认接收到哪些段，而是通知发送端下一次应该发送哪一个段，表示前面的段已经接收到</strong>；比如：接收到的确认应答为<code>N+1</code>时，表示<code>N</code>以及<code>N</code>之前的数据都已接收完毕。</p><p>在TCP进行通信前，发送一个<code>SYN</code>包作为建立连接的请求；在通信结束时，会使用<code>FIN</code>包进行断开连接的处理。<code>SYN</code>包和<code>FIN</code>包是通过TCP头部的控制字段来管理TCP连接。创建一个TCP连接，会产生一个<strong>32位随机序列号</strong>。TCP的三次握手至少需要发送3个包，四次挥手至少需要发送4个包。</p><p>三次握手的关键是确认对方接收到自己发送的数据包，计算机会记录该数据包的序号<code>Seq</code>，当收到对方返回的数据包后，检测数据包的确认号<code>Ack</code>，若<code>Ack</code>=<code>Seq</code>+1，则表示对方正确接收到自己发送的数据包。</p><p>经过传输层协议封装后的数据称为<code>段</code>。在建立TCP连接时，可以确定数据段的大小，即<code>最大消息长度（MSS）</code>。TCP在传输大量数据时，是以MSS的大小将数据进行分割发送；数据的重发也是以MSS为单位。MSS是在三次握手时，由两端主机计算而来；<strong>两端主机在发出建立连接的请求时，会在TCP头部写入MSS值，然后在两者之间选择较小的值使用</strong>，MSS<strong>默认值为536字节</strong>，<strong>理想值为1460字节</strong>。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/MSS%E5%8D%8F%E5%95%86.png" alt></p><h3 id="断开连接——四次挥手"><a href="#断开连接——四次挥手" class="headerlink" title="断开连接——四次挥手"></a>断开连接——四次挥手</h3><ul><li><strong>第一次挥手</strong>：客户端向服务端发送断开连接请求报文<strong>断开<code>FIN</code></strong>（序号<code>Seq</code>=x）</li><li><strong>第二次挥手</strong>：服务端返回<strong>确认<code>ACK</code></strong>（序号<code>Seq</code>=y、确认号<code>Ack</code>=x+1）</li><li><strong>第三次挥手</strong>：服务端发送表示可以断开连接的报文<strong>断开<code>FIN</code></strong>（序号<code>Seq</code>=y+1、确认号：<code>Ack</code>=x+1）</li><li><strong>第四次挥手</strong>：客户端返回<strong>确认<code>ACK</code></strong>（序号<code>Seq</code>=x+1、确认号<code>Ack</code>=y+2）</li></ul><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.png" alt></p><h2 id="TCP-amp-UDP的比较"><a href="#TCP-amp-UDP的比较" class="headerlink" title="TCP&amp;UDP的比较"></a>TCP&amp;UDP的比较</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，全称<code>User Datagram Protocol</code>。UDP不提供复杂的控制机制，利用IP提供面向<strong>无连接</strong>的、<strong>不可靠</strong>的通信服务。并且，UDP是将应用程序发来的数据，在收到的那一刻，立即按照原样发送到网络上的一种机制。即使在网络出现拥堵的情况下，UDP也无法进行流量控制。传输过程中出现丢包，UDP也不负责重发。当出现包的到达顺序错误时也没有纠正的功能。如果需要这些细节控制，那么需要交由<strong>上层的应用程序去处理</strong>。</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><ul><li>UDP是无连接的：UDP发送数据前不与对方建立连接；</li><li>UDP不对数据进行排序：UDP报文的头部没有数据顺序的信息；</li><li>UDP对数据不发送确认，发送端不知道数据是否被正确接收，也不会重发数据；</li><li>UDP传送数据比TCP快，系统开销少；</li><li>UDP缺乏拥塞控制机制，不能检测到网络拥塞。</li></ul><h4 id="UDP的应用"><a href="#UDP的应用" class="headerlink" title="UDP的应用"></a>UDP的应用</h4><ul><li>包总量较少的通信（DNS、SNMP、TFTP等）</li><li>视频、音频等多媒体通信（即时通信）</li><li>只在局域网内使用的应用通信</li><li>广播通信（广播、多播）</li></ul><h4 id="UDP格式"><a href="#UDP格式" class="headerlink" title="UDP格式"></a>UDP格式</h4><p>UDP段由UDP头部和UDP数据组成。UDP头部由<strong>源端口号</strong>、<strong>目的端口号</strong>、<strong>长度</strong>、<strong>校验和</strong>组成，UDP头部长度为固定的<strong>8</strong>字节。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/UDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt></p><ul><li><strong>源端口号</strong>：字段长16位，表示发送端UDP端口号。</li><li><strong>目的端口号</strong>：字段长16位，表示接收端UDP端口号。</li><li><strong>长度</strong>：字段长16位，表示UDP头部和UDP数据的总长度。</li><li><strong>校验和</strong>：字段长16位，由UDP头部和UDP数据的内容计算得出，用于检查在传输过程中是否出现错误。</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP是一种<strong>面向连接</strong>的协议，在数据传输前必须<strong>在发送方和接收方之间建立连接</strong>，还通过<strong>校验和</strong>、<strong>序列号</strong>、<strong>确认应答</strong>、<strong>重发控制</strong>、<strong>连接管理</strong>以及<strong>窗口控制</strong>等机制实现可靠性传输；只支持<strong>点对点</strong>的单播传输方式，提供全双工通信，在不保留报文边界的情况下以<strong>字节流</strong>的方式进行数据传输；适用于对<strong>传输可靠性要求高</strong>的应用（例如文件传输）。</p><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><ul><li>三次握手建立连接：确保连接建立的可靠性；</li><li>端口号：通过端口号识别上层协议和服务，实现网络的多路复用；</li><li>完整性校验：通过计算校验和，保证接收端能检测出传输过程中可能出现的错误；</li><li>确认机制：对于正确接收到的数据，接收端通过确认应答告知发送端，超出一定时间后，发送端将重传没有被确认的段，确保传输的可靠性；</li><li>序列号：发送的数据都有唯一的序列号，标识了每一个段，接收端可以通过序列号实现丢失检测、乱序重排等功能；</li><li>窗口机制：通过可调节的窗口，接收端可以告知希望的发送速度，控制数据流量。</li></ul><h4 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h4><p>TCP头部由一个<strong>20字节的固定长度</strong>加上<strong>可变长的选项字段</strong>组成。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt></p><ul><li><p><strong>源端口号</strong>：字段长16位，表示发送端TCP端口号。</p></li><li><p><strong>目的端口号</strong>：字段长16位，表示接收端TCP端口号。</p></li><li><p><strong>序列号</strong>：字段长32位，是指TCP段数据的位置序号，根据序列号来判断是否存在重收、漏收、乱序等情况。</p></li><li><p><strong>确认号</strong>：字段长32位，是指下一次应该收到的数据的序列号，收到这个确认号，表示这个确认号之前的数据都已经正常收到。</p></li><li><p><strong>数据偏移</strong>：字段长4位，表示TCP数据从哪一位开始计算，也可看作TCP头部的长度。</p></li><li><p><strong>保留</strong>：字段长6位，保留给以后扩展使用。</p></li><li><p><strong>控制位</strong>：字段长6位，每1位标志位可以打开一个控制功能；</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%8E%A7%E5%88%B6%E4%BD%8D.png" alt></p><ul><li><strong>URG</strong>：标志位为1时，表示有需要紧急处理的数据；</li><li><strong>ACK</strong>：标志位为1时，表示确认应答有效；</li><li><strong>PSH</strong>：标志位为1时，表示将数据立即上传给应用程序，而不是在缓冲区排队；</li><li><strong>RST</strong>：标志位为1时，表示TCP连接出现异常，必须强制断开连接；</li><li><strong>SYN</strong>：标志位为1时，表示请求建立连接，并设置序列号的初始值；</li><li><strong>FIN</strong>：标志位为1时，表示数据发送结束，请求断开TCP连接。</li></ul></li><li><p><strong>窗口</strong>：字段长16位，表示滑动窗口的大小。</p></li><li><p><strong>校验和</strong>：字段长16位，由TCP头部和TCP数据的内容计算得出，用于检查在传输过程中是否出现错误。</p></li><li><p><strong>紧急指针</strong>：字段长16位，表示紧急数据的长度；当<code>URG</code>位为1时，该字段才生效。</p></li><li><p><strong>选项</strong>：字段的长度是可变的；通过添加不同的选项来实现TCP的一些扩展功能。</p></li><li><p><strong>填充</strong>：如果TCP段的头部长度不是4字节的整数倍，就填充若干<code>0</code>，来保证头部长度是4字节的整数倍。</p></li><li><p><strong>数据</strong>：TCP段的数据部分，字段最大是MSS。</p></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><p>TCP是以1个段为单位，每发送一个段进行一次确认应答，如果包的往返时间越长，通信性能就越低。所以，TCP引入了<code>窗口</code>的概念，确认应答不再是每个分段，而是以窗口的大小来进行确认，<code>窗口大小</code>即指无需等待确认应答，而可以继续发送数据的最大值。<strong>因为窗口大小是一个16位字段，因此窗口最大为65535字节。</strong>在TCP传输过程中，双方通过交换窗口的大小来表示自己剩余的缓冲区（Buffer）空间，以及下一次能接受的最大数据量，避免缓冲区的溢出。</p><p>在发送数据的过程中，窗口内的数据即使没有收到确认应答也可以发送出去。若窗口中的数据在传输过程中丢失，也需要进行重发。因此，发送端在收到确认应答前，必须保留缓冲区中的该部分数据。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt></p><p>接收到确认应答后，将窗口滑动到确认应答中的序列号位置。这样可以按顺序将多个段同时发送，该机制也被称为<code>滑动窗口控制</code>。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.png" alt></p><h3 id="重发机制"><a href="#重发机制" class="headerlink" title="重发机制"></a>重发机制</h3><p>在使用<strong>窗口控制</strong>时，若确认应答未能返回，但数据已被接收，这种情况下是不需要进行重发的（即使某些确认应答丢失）。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E9%87%8D%E5%8F%91.png" alt></p><p>若某个报文段丢失，接收方收到序号不连续的数据时，会为已接收到的数据返回确认应答，且将已接收到的数据暂时保存至缓冲区。出现报文丢失时，同一序号的确认应答将会被重复发送。若发送方收到<strong>连续3次</strong>同一序号的确认应答，就会将对应的数据进行重发，该机制被称为<code>高速重发机制</code>。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E9%AB%98%E9%80%9F%E9%87%8D%E5%8F%91%E6%9C%BA%E5%88%B6.png" alt></p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是一种可以让发送方根据接收方的实际接收能力控制发送的数据量的机制。接收方通知发送方自己可以接收数据的大小，发送方就会发送不超过该限度的数据量，该限度为窗口大小。</p><p>TCP头部中有一个字段用来通知窗口大小，当接收方的缓存区空间不足或处理能力有限时，窗口大小的值就会<strong>降低一半</strong>，从而控制数据发送量。</p><p>若接收方要求的窗口大小为<strong><code>0</code></strong>，则表示接收方<strong>已经接收全部数据</strong>，或接收方<strong>要求暂停发送</strong>。</p><p>发送方会时不时地发送一个被称为<code>窗口探测</code>的数据段，该数据段仅包含一个字节以获取最新的窗口大小。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%B5%81%E6%8E%A7%E5%88%B6.png" alt></p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在网络出现拥堵时，如果突然发送一个较大量的数据，有可能导致整个网络瘫痪。为防止该问题出现，在通信开始时，会通过一个被称为<code>慢启动</code>的算法得出的数值，对发送数据量进行控制。</p><p>为了在发送方调节发送数据的量，需要使用拥塞窗口。在慢启动时，将拥塞窗口的大小设置为<strong>1MSS</strong>，之后每收到一次确认应答，拥塞窗口的值就<strong>加1</strong>。在发送数据时，将<strong>拥塞窗口的大小</strong>与<strong>接收方通知的窗口大小</strong>作比较，选择其中的<strong>较小值</strong>来发送数据，这样可以避免网络拥塞的发生。</p><p><img src="/2021/05/23/TCP%E5%92%8CUDP%E7%9A%84%E7%AE%80%E8%A6%81%E6%95%B4%E7%90%86/%E6%85%A2%E5%90%AF%E5%8A%A8.png" alt></p><hr><p><strong>参考资料：</strong></p><p><a href="https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html" target="_blank" rel="noopener">一文搞懂TCP与UDP的区别</a></p><p><a href="https://blog.csdn.net/weixin_45393094/article/details/104965561" target="_blank" rel="noopener">我终于搞懂了TCP的三次握手和四次挥手（图片案例超详解）</a></p><p><a href="https://blog.csdn.net/qq_38950316/article/details/81087809?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162158064016780274151270%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162158064016780274151270&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-5-81087809.first_rank_v2_pc_rank_v29&utm_term=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B&spm=1018.2226.3001.4187" target="_blank" rel="noopener">TCP的三次握手与四次挥手理解及面试题（很全面）</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议- 维基百科，自由的百科全书</a></p><p><a href="https://mp.weixin.qq.com/s/8iyxF1tT3JhyHKdyeF1uAg" target="_blank" rel="noopener">33 张图详解 TCP 和 UDP ：打通网络和应用的中间人</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI模型简要记录</title>
      <link href="/2021/05/22/OSI%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/05/22/OSI%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>开放式系统互联模型（英语：Open System Interconnection Model，缩写：OSI；简称为OSI模型）是一种概念模型，由国际标准化组织提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。</p><p>​                                                                                                                                                                        ——<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">维基百科</a></p><a id="more"></a><p>说人话，OSI模型就是将整个网络体系划分为若干个不同的层级，每个层级包含有若干协议，软、硬件厂商根据不同层级的不同协议来开发对应的产品（与特定的技术无关），有利于不同厂商开发的产品能互相协同运作。</p><p>OSI模型一共划分为七层：</p><ul><li><p>应用层【第七层】（Application）</p></li><li><p>表示层【第六层】（Presentation）</p></li><li><p>会话层【第五层】（Session）</p></li><li><p>传输层【第四层】（Transport）</p></li><li><p>网络层【第三层】（Network）</p></li><li><p>数据链路层【第二层】（Data Link）</p></li><li><p>物理层【第一层】（Physical）</p></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层是OSI模型的最高层，该层级直接接触用户数据，是用户以及应用程序和网络之间的接口（<strong>应用程序不属于应用层</strong>），直接面向用户和应用程序实现各种网络交互服务。</p><p>待传输数据的出现始于应用层，应用程序准备好数据后，就可以向表示层传递。</p><p><code>数据内容</code></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>归属于应用层的协议有以下（非全部）：</p><p>HTTP    超文本传输协议</p><p>HTTPS    安全超文本传输协议</p><p>SMTP    简单邮件传输协议</p><p>FTP    文件传输协议</p><p>POP3    邮局协议第3版</p><p>IMAP4    因特网信息访问协议第4版</p><p>SOCKS    安全套接字协议</p><p>DNS    域名解析协议</p><p>DHCP    动态主机配置协议</p><p>NTP    网络时间协议</p><p>应用程序（例如QQ、微信、钉钉、Twitter、TeamViewer）的私有协议</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层是OSI模型的第六层，该层对来自应用层的数据进行处理，例如数据格式的处理（用户程序之间在数据格式表示上可能存在差异）、数据编码（不同设备（操作系统、计算机体系等方面的差异）对某些信息（例如数据类型）的表示方式可能不同）、数据压缩和解压（减少数据的传输量）、数据加密和解密（提高数据传输的安全性），以此来迎合接收方。数据处理完毕后，将会被送入会话层。</p><p><code>数据内容</code></p><h3 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h3><p>归属于表示层的协议有如下（非全部）：</p><p>AES    高级加密标准</p><p>DES    数据加密标准</p><p>H.264    视频解码</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层是OSI模型的第五层，该层接收到来自表示层的数据后，负责在数据传输中设置和维护两台计算机之间的通信连接。用户或应用程序提供目标方的远程地址（例如域名，但<strong>不包括IP地址和MAC地址</strong>），通过单工、半双工或全双工的方式来建立会话连接。建立好会话连接后，数据将会被送入传输层。</p><p><code>数据内容</code></p><h3 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h3><p>归属于会话层的协议有如下（非全部）：</p><p>SSL    安全套接层协议</p><p>TLS    传输层安全协议</p><p>RPC    远程过程调用协议</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层是OSI模型的第四层，是通信子网和资源子网的接口（OSI模型的上三层的主要任务可归纳为数据处理，下三层则为数据通信），向上三层屏蔽下三层的数据通信的细节。传输层可对来自会话层的数据进行流量控制（将数据分割成小块）、多路传输（避免拥塞）。同时，传输层还为数据加上<strong>源端口</strong>和<strong>目的端口</strong>（告知接收方数据从哪来和到哪去）。</p><p><code>[源目端口]|数据内容</code></p><h3 id="协议-3"><a href="#协议-3" class="headerlink" title="协议"></a>协议</h3><p>归属于传输层的协议有如下（非全部）：</p><p>TCP    传输控制协议</p><p>UDP    用户数据报协议</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层是OSI模型的第三层，也是通信子网的最高层，在下两层的基础上向资源子网提供服务，该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。<strong>网络层主要解决不同子网之间的通信</strong>，会给数据追加<strong>源IP地址</strong>和<strong>目的IP地址</strong>。当源节点和目的节点之间存在多条路径时，网络层可根据路由算法为数据选择最佳路径。网络层还对<strong>从源节点到目的节点之间</strong>的流量进行控制，防止阻塞。</p><p><code>[源目IP地址]|[源目端口]|数据内容</code></p><h3 id="协议-4"><a href="#协议-4" class="headerlink" title="协议"></a>协议</h3><p>归属于网络层的协议有如下（非全部）：</p><p>IP    互联网协议</p><p>IPv6    互联网协议第6版</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层是OSI模型的第二层，负责建立和管理节点之间的链路。网络层的主要功能是在物理层提供的比特流的基础上，通过各种控制协议（例如在数据尾部追加检测数据完整性的FSC帧校验），提供可靠的通过物理介质传输数据的方法。同时，网络层为数据追加<strong>源MAC地址</strong>和<strong>目的MAC地址</strong>来<strong>解决子网内部的寻址问题</strong>。</p><p><code>[源目MAC地址]|[源目IP地址]|[源目端口]|数据内容|[FSC帧校验]</code></p><h3 id="协议-5"><a href="#协议-5" class="headerlink" title="协议"></a>协议</h3><p>归属于数据链路层的协议有如下（非全部）：</p><p>ARP    地址解析协议</p><p>RARP    逆向地址解析协议</p><p>Modbus    串行链路协议</p><p>CAN    控制器局域网总线协议</p><p>PPP    点到点通信协议</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>机械、电子、定时接口通信信道上的原始比特流传输。</p><p><code>100111010111010110110100001101101011</code></p><p>归属于物理层的协议有如下（非全部）：</p><p>LoRa    Semtech开发的远距离无线电技术</p><p>BLE    蓝牙低能耗</p><p>RS-232</p><p>RS-485</p><p>令牌传送网络</p><p>RJ45</p><hr><p><strong>参考资料</strong>：</p><p><a href="https://blog.csdn.net/qq_16093323/article/details/79582554?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162158153116780261954897%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162158153116780261954897&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-18-79582554.first_rank_v2_pc_rank_v29&utm_term=OSI%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187" target="_blank" rel="noopener">OSI七层模型基础知识及各层常见应用</a></p><p><a href="https://blog.csdn.net/qq_41923622/article/details/85805003?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162158153116780261954897%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162158153116780261954897&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-30-85805003.first_rank_v2_pc_rank_v29&utm_term=OSI%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187" target="_blank" rel="noopener">OSI 七层模型和TCP/IP模型及对应协议（详解）</a></p><p><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162158105716780269823021%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162158105716780269823021&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-7064869.first_rank_v2_pc_rank_v29&utm_term=OSI%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187" target="_blank" rel="noopener">OSI七层模型详解</a></p><p><a href="https://sspai.com/post/64659" target="_blank" rel="noopener">小白也能看懂的网络基础 03 | OSI 模型是如何工作的</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">什么是 OSI 模型？</a></p><p><a href="http://www.colasoft.com.cn/download/protocols_map.php" target="_blank" rel="noopener">科来网络通讯协议图2020版</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号量简要记录</title>
      <link href="/2021/05/17/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/05/17/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>信号量是操作系统中的一种进程同步与互斥的机制，对信号量的操作有两种，<code>P操作</code>和<code>V操作</code>，两个操作在执行时不被中断，必须成对使用。</p><a id="more"></a><p>在操作系统中，信号量表示资源的实体，由<code>S</code>（一个具有非负初值的整型变量）和<code>Q</code>（一个初始状态为空的队列）组成。<code>S</code>表示操作系统中某类资源的使用情况，当其值<strong>大于0</strong>时，表示操作系统中该<strong>资源的可用数量</strong>；当其值<strong>小于0</strong>时，其<strong>绝对值</strong>表示操作系统中因请求该类资源而<strong>阻塞等待的进程数目</strong>。除信号量的初值外，信号量的值能由<code>P</code>操作和<code>V</code>操作改变。</p><p><strong><code>P(S)</code></strong>的主要功能是：先<strong>执行<code>S=S-1</code></strong>；若<code>S</code><strong>大于或等于0</strong>，则该<strong>进程继续执行</strong>；若<code>S</code><strong>小于0</strong>，则该<strong>进程阻塞</strong>，并将其插入到该信号量的等待队列<code>Q</code>中。</p><p><strong><code>V(S)</code></strong>的主要功能是：先<strong>执行<code>S=S+1</code></strong>；若<code>S</code><strong>大于0</strong>，则该<strong>进程继续执行</strong>；若<code>S</code><strong>小于或等于0</strong>，则从该信号量的等待队列<code>Q</code>中移出第一个进程，使其<strong>变为就绪状态</strong>。</p><hr><p><a href="https://blog.csdn.net/qq_19782019/article/details/79746627?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162123137116780262558307%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162123137116780262558307&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79746627.first_rank_v2_pc_rank_v29&utm_term=%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">操作系统之信号量</a></p><p><a href="https://blog.csdn.net/yangkuiwu/article/details/52674809?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162123137116780262558307%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162123137116780262558307&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-5-52674809.first_rank_v2_pc_rank_v29&utm_term=%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">信号量是什么?可以这样简单的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编语言程序设计简要记录（三）</title>
      <link href="/2021/05/13/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/05/13/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>利用子程序对数据段NUM0<code>db 11,12,13,14</code>和NUM1<code>db 12,13,14,15</code>对应的各个数进行求和（即对<code>NUM0[0]</code>和<code>NUM1[0]</code>进行求和，对<code>NUM0[1]</code>和<code>NUM1[1]</code>进行求和······），将结果存储于以<code>1000H</code>起始的数据段中，并输出结果。</p><a id="more"></a><p><strong>源程序：</strong></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">    NUM0 <span class="built_in">DB</span> <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span></span><br><span class="line">    NUM1 <span class="built_in">DB</span> <span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span></span><br><span class="line">    ORG <span class="number">1000H</span></span><br><span class="line">    SUM <span class="built_in">DB</span> <span class="number">4</span> DUP(?)</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">    <span class="meta">ASSUME</span> <span class="built_in">DS</span>:DATA,<span class="built_in">CS</span>:CODE</span><br><span class="line"></span><br><span class="line"><span class="symbol">    START:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">LEA</span> <span class="built_in">SI</span>,NUM0     <span class="comment">;取段NUM0的偏移地址</span></span><br><span class="line">    <span class="keyword">LEA</span> <span class="built_in">DI</span>,NUM1     <span class="comment">;取段NUM1的偏移地址</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">BL</span>,[<span class="built_in">SI</span>]</span><br><span class="line">    <span class="keyword">MOV</span> <span class="number">BH</span>,[<span class="built_in">DI</span>]</span><br><span class="line">    <span class="keyword">ADD</span> <span class="number">BH</span>,<span class="built_in">BL</span>       <span class="comment">;两数相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">PUSH</span> <span class="built_in">SI</span>     <span class="comment">;将段NUM0的偏移地址SI压栈，避免与段SUM的偏移地址SI冲突</span></span><br><span class="line">    <span class="keyword">MOV</span> SUM[<span class="built_in">SI</span>],<span class="number">BH</span>      <span class="comment">;将两数相加的结果写入段SUM</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">    <span class="keyword">POP</span> <span class="built_in">SI</span>      <span class="comment">;将段NUM0的偏移地址SI弹栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">CALL</span> DISPLAY        <span class="comment">;调用子程序DISPLAY实现输出功能</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line">    <span class="keyword">LOOP</span> L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">4CH</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">    DISPLAY PROC        <span class="comment">;子程序DISPLAY</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">BH</span>       <span class="comment">;将8位的两数相加之和转换为16位并写入AX作被除数</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">0H</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">BL</span>,<span class="number">10</span>       <span class="comment">;8位的除数</span></span><br><span class="line">        <span class="keyword">DIV</span> <span class="built_in">BL</span>      <span class="comment">;SUM/10，取得SUM的十位和个位</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">AX</span>     <span class="comment">;将商和余数压栈（商被写入AL，余数被写入AH）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DL</span>,<span class="built_in">AL</span></span><br><span class="line">        <span class="keyword">ADD</span> <span class="built_in">DL</span>,<span class="number">30H</span>      <span class="comment">;将SUM的十位转换为其ASCII值，使十位能以字符形式输出</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">2H</span>       <span class="comment">;输出结果</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">POP</span> <span class="built_in">AX</span>      <span class="comment">;将商和余数弹栈</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DL</span>,<span class="number">AH</span></span><br><span class="line">        <span class="keyword">ADD</span> <span class="built_in">DL</span>,<span class="number">30H</span>      <span class="comment">;将SUM的个位转换为其ASCII值，使个位能以字符形式输出</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">2H</span>       <span class="comment">;输出结果</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DL</span>,<span class="string">'D'</span>      <span class="comment">;输出字符D</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">2H</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DL</span>,<span class="number">10</span>       <span class="comment">;输出“换行”</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">2H</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">RET</span>     <span class="comment">;子程序返回</span></span><br><span class="line">        DISPLAY ENDP</span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p><strong>调试结果：</strong></p><p><img src="/2021/05/13/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/%E8%B0%83%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt></p><p><strong>运行结果：</strong></p><p><img src="/2021/05/13/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 8086汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机 —— DS1302简要记录</title>
      <link href="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>DS1302是DALLAS公司推出的一款具有涓流充电功能的实时时钟芯片，带有存储容量为31字节的RAM，可对秒、分、时、日、月、年进行计时，能对日期进行自动调整（包括闰年的校正），可通过配置<code>AM/PM</code>来选择使用24小时制还是12小时制，通过串行通信的方式与MCU进行数据交换。</p><a id="more"></a><h2 id="DS1302引脚定义"><a href="#DS1302引脚定义" class="headerlink" title="DS1302引脚定义"></a>DS1302引脚定义</h2><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png" alt></p><ul><li><code>VCC2</code>：主电源引脚</li><li><code>X1</code>&amp;<code>X2</code>：连接一个32.768K的晶振，为DS1302提供一个时钟基准</li><li><code>GND</code>：接地</li><li><code>RST&#39;</code>：复位/片选引脚，也相当于使能引脚，读写DS1302时，该引脚必须为高电平</li><li><code>I/O</code>：双向通信引脚，DS1302通过该引脚进行数据的读写</li><li><code>SCLK</code>：时钟信号输入引脚</li><li><code>VCC1</code>：备用电源引脚</li></ul><h2 id="DS1302命令字"><a href="#DS1302命令字" class="headerlink" title="DS1302命令字"></a>DS1302命令字</h2><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/DS1302%E5%91%BD%E4%BB%A4%E5%AD%97.png" alt></p><ul><li><code>bit7</code>：最高有效位，必须为<code>1</code>，才能将数据写入DS1302</li><li><code>bit6</code>：若为<code>0</code>，表示存取日历时钟数据；若为<code>1</code>，表示存取RAM数据</li><li><code>bit5</code>~<code>bit1</code>：对将要进行操作的寄存器的地址</li><li><code>bit0</code>：读写选择位；若为<code>0</code>，表示进行写操作；若为<code>1</code>，表示进行读操作</li></ul><h2 id="DS1302读写时序"><a href="#DS1302读写时序" class="headerlink" title="DS1302读写时序"></a>DS1302读写时序</h2><h3 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h3><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E8%AF%BB%E6%97%B6%E5%BA%8F.png" alt></p><h3 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h3><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E5%86%99%E6%97%B6%E5%BA%8F.png" alt></p><h2 id="DS1302数据地址和传输格式"><a href="#DS1302数据地址和传输格式" class="headerlink" title="DS1302数据地址和传输格式"></a>DS1302数据地址和传输格式</h2><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E5%9C%B0%E5%9D%80.png" alt></p><p>如图所示，时钟日历被写入7个寄存器，数值以BCD码的形式被存储于这7个寄存器中。</p><ul><li><code>寄存器1</code>：<code>秒</code>寄存器；最高位<code>CH</code>为时钟停止标志位，该位为<code>0</code>表示时钟持续运行，该位为<code>1</code>表示时钟停止运行；剩下的7位中，高3位为<code>秒</code>的十位，低4位为<code>秒</code>的个位</li><li><code>寄存器2</code>：<code>分</code>寄存器；最高位无意义；剩下的7位中，高3位为<code>分</code>的十位，低4位为<code>分</code>的个位</li><li><code>寄存器3</code>：<code>时</code>寄存器；<code>bit7</code>为<code>1</code>表示12小时制，为<code>0</code>则表示24小时制；<code>bit6</code>固定为<code>0</code>；<code>bit5</code>在12小时制下若为<code>0</code>则表示<code>AM</code>，若为<code>1</code>则表示<code>PM</code>，在24小时制下和<code>bit4</code>一起表示<code>时</code>的十位；低4位则表示<code>时</code>的个位</li><li><code>寄存器4</code>：<code>日</code>寄存器；高2位固定为<code>0</code>；<code>bit5</code>和<code>bit4</code>表示<code>日</code>的十位；低4位表示<code>日</code>的个位</li><li><code>寄存器5</code>：<code>月</code>寄存器；高3位固定为<code>0</code>；<code>bit4</code>表示<code>月</code>的十位；低4位表示<code>月</code>的个位</li><li><code>寄存器6</code>：<code>星期</code>寄存器；高5位固定为<code>0</code>；低3位表示<code>星期</code></li><li><code>寄存器7</code>：<code>年</code>寄存器；高4位表示<code>年</code>的十位；低4位表示<code>年</code>的个位；范围为从2000年到2099年</li><li><code>寄存器8</code>：写保护寄存器；最高位<code>WP</code>为保护位，若该位为<code>1</code>，则禁止向DS1302的RAM或其他寄存器写入数据</li><li><code>寄存器9</code>：涓流充电功能所用到的寄存器</li></ul><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>从2021年5月11日0时0分0秒开始计时并在LCD1602上显示。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;<span class="built_in">int</span>rins.h&gt;</span><br><span class="line"></span><br><span class="line">sbit RST=P2^<span class="number">4</span>;</span><br><span class="line">sbit CLK=P2^<span class="number">1</span>;</span><br><span class="line">sbit IO=P2^<span class="number">0</span>;</span><br><span class="line">sbit RS=P1^<span class="number">0</span>;</span><br><span class="line">sbit RW=P1^<span class="number">1</span>;</span><br><span class="line">sbit E=P2^<span class="number">5</span>;</span><br><span class="line">sbit DU=P2^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">unsigned char num[]=&#123;<span class="string">"0123456789"</span>&#125;;<span class="comment">//LCD1602显示的数字字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> X()<span class="comment">//关闭数码管</span></span><br><span class="line">&#123;</span><br><span class="line">DU=<span class="number">1</span>;</span><br><span class="line">P0=<span class="number">0x00</span>;</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay()</span><br><span class="line">&#123;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_Bit_DS1302(unsigned char DAT)<span class="comment">//向DS1302写入一字节的数据</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">CLK=<span class="number">0</span>;</span><br><span class="line">Delay();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">IO=DAT&amp;<span class="number">0x01</span>;<span class="comment">//低位在前，高位在后</span></span><br><span class="line">Delay();</span><br><span class="line">CLK=<span class="number">1</span>;<span class="comment">//时钟信号上升沿，写入数据</span></span><br><span class="line">Delay();</span><br><span class="line">CLK=<span class="number">0</span>;<span class="comment">//重新拉低CLK，形成脉冲</span></span><br><span class="line">DAT&gt;&gt;=<span class="number">1</span>;<span class="comment">//将DAT的各数据位右移1位，准备写入下一数据位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_DS1302(unsigned char CMD,unsigned char DAT)<span class="comment">//向DS1302写入命令和数据</span></span><br><span class="line">&#123;</span><br><span class="line">RST=<span class="number">0</span>;<span class="comment">//禁止数据传输</span></span><br><span class="line">CLK=<span class="number">0</span>;<span class="comment">//在写入数据前确保CLK置低电平</span></span><br><span class="line">RST=<span class="number">1</span>;<span class="comment">//开始数据传输</span></span><br><span class="line">Delay();</span><br><span class="line">Write_Bit_DS1302(CMD);<span class="comment">//写入命令</span></span><br><span class="line">Write_Bit_DS1302(DAT);<span class="comment">//写入数据</span></span><br><span class="line">CLK=<span class="number">1</span>;</span><br><span class="line">RST=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char Read_Bit_DS1302()<span class="comment">//从DS1302读出一字节的数据</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,DAT;</span><br><span class="line">Delay();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">DAT&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(IO==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DAT|=<span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line">CLK=<span class="number">1</span>;</span><br><span class="line">Delay();</span><br><span class="line">CLK=<span class="number">0</span>;<span class="comment">//时钟信号下降沿，读出数据</span></span><br><span class="line">Delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char Read_DS1302(unsigned char CMD)<span class="comment">//向DS1302写入命令后再从DS1302读出数据</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char DAT;</span><br><span class="line">RST=<span class="number">0</span>;</span><br><span class="line">CLK=<span class="number">0</span>;</span><br><span class="line">RST=<span class="number">1</span>;</span><br><span class="line">Write_Bit_DS1302(CMD);<span class="comment">//写入命令</span></span><br><span class="line">DAT=Read_Bit_DS1302();<span class="comment">//读出数据</span></span><br><span class="line">CLK=<span class="number">1</span>;</span><br><span class="line">RST=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> DAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Init_DS1302()<span class="comment">//DS1302初始化</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char X;</span><br><span class="line">X=Read_DS1302(<span class="number">0x81</span>);</span><br><span class="line"><span class="keyword">if</span>(X&amp;<span class="number">0x80</span>)<span class="comment">//判断DS1302是否处于运行状态</span></span><br><span class="line">&#123;</span><br><span class="line">Write_DS1302(<span class="number">0x8e</span>,<span class="number">0x00</span>);<span class="comment">//允许将数据写入DS1302的寄存器</span></span><br><span class="line">Write_DS1302(<span class="number">0x80</span>,((<span class="number">00</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">00</span>%<span class="number">10</span>)));<span class="comment">//写入“秒”的初始值，需要将LCD1602显示的数字的ASCII值转换成BCD码</span></span><br><span class="line">Write_DS1302(<span class="number">0x82</span>,((<span class="number">00</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">00</span>%<span class="number">10</span>)));<span class="comment">//写入“分”的初始值</span></span><br><span class="line">Write_DS1302(<span class="number">0x84</span>,((<span class="number">00</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">00</span>%<span class="number">10</span>)));<span class="comment">//写入“时”的初始值</span></span><br><span class="line">Write_DS1302(<span class="number">0x86</span>,((<span class="number">11</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">11</span>%<span class="number">10</span>)));<span class="comment">//写入“日”的初始值</span></span><br><span class="line">Write_DS1302(<span class="number">0x88</span>,((<span class="number">5</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">5</span>%<span class="number">10</span>)));<span class="comment">//写入“月”的初始值</span></span><br><span class="line">Write_DS1302(<span class="number">0x8c</span>,((<span class="number">21</span>/<span class="number">10</span>)&lt;&lt;<span class="number">4</span>|(<span class="number">21</span>%<span class="number">10</span>)));<span class="comment">//写入“年”的初始值</span></span><br><span class="line">Write_DS1302(<span class="number">0x8e</span>,<span class="number">0x80</span>);<span class="comment">//禁止将数据写入DS1302的寄存器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay5ms()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">_nop_();</span><br><span class="line">i=<span class="number">9</span>;</span><br><span class="line">j=<span class="number">244</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> ReadBusy()<span class="comment">//LCD1602“读忙”操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=<span class="number">0xff</span>;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">temp=P0;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>(temp&amp;<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_Com(char com)<span class="comment">//LCD1602“写命令”操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ReadBusy());</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=com;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_Dat(char dat)<span class="comment">//LCD1602“写数据”操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ReadBusy());</span><br><span class="line">RS=<span class="number">1</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=dat;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> LCD1602_Init()<span class="comment">//LCD1602初始化</span></span><br><span class="line">&#123;</span><br><span class="line">Delay5ms();<span class="comment">//延时15ms，首次写入LCD1602时应给LCD1602一段较长的响应时间</span></span><br><span class="line">Delay5ms();</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);<span class="comment">//显示模式设置：16*2显示、5*7点阵，连续写入3次，确保LCD1602初始化成功</span></span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x0c</span>);<span class="comment">//显示模式设置：开显示、光标不显示、光标不闪烁</span></span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x06</span>);<span class="comment">//显示模式设置：光标右移，字符不右移</span></span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x01</span>);<span class="comment">//清除屏幕</span></span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Second(unsigned char x)<span class="comment">//LCD1602显示“秒”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;<span class="comment">//取数值的十位</span></span><br><span class="line">j=x%<span class="number">10</span>;<span class="comment">//取数值的个位</span></span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x49</span>);<span class="comment">//写入在LCD1602上显示的位置</span></span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Minute(unsigned char x)<span class="comment">//LCD1602显示“分”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;</span><br><span class="line">j=x%<span class="number">10</span>;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x46</span>);</span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Hour(unsigned char x)<span class="comment">//LCD1602显示“时”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;</span><br><span class="line">j=x%<span class="number">10</span>;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x43</span>);</span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Day(unsigned char x)<span class="comment">//LCD1602显示“日”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;</span><br><span class="line">j=x%<span class="number">10</span>;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x0c</span>);</span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Month(unsigned char x)<span class="comment">//LCD1602显示“月”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;</span><br><span class="line">j=x%<span class="number">10</span>;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x09</span>);</span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Display_Year(unsigned char x)<span class="comment">//LCD1602显示“年”的数值</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=x/<span class="number">10</span>;</span><br><span class="line">j=x%<span class="number">10</span>;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x06</span>);</span><br><span class="line">Write_Dat(num[i]);</span><br><span class="line">Write_Dat(num[j]);</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char second,minute,hour,day,month,year;</span><br><span class="line">unsigned char temp;<span class="comment">//暂存从DS1302读出的数据</span></span><br><span class="line">X();</span><br><span class="line">LCD1602_Init();</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x01</span>);</span><br><span class="line">Write_Dat(<span class="string">'D'</span>);</span><br><span class="line">Write_Dat(<span class="string">'A'</span>);</span><br><span class="line">Write_Dat(<span class="string">'T'</span>);</span><br><span class="line">Write_Dat(<span class="string">'E'</span>);</span><br><span class="line">Write_Dat(<span class="string">':'</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x08</span>);</span><br><span class="line">Write_Dat(<span class="string">'-'</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x0b</span>);</span><br><span class="line">Write_Dat(<span class="string">'-'</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x45</span>);</span><br><span class="line">Write_Dat(<span class="string">':'</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x48</span>);</span><br><span class="line">Write_Dat(<span class="string">':'</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Init_DS1302();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp=Read_DS1302(<span class="number">0x81</span>);</span><br><span class="line">second=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“秒”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Second(second);</span><br><span class="line">temp=Read_DS1302(<span class="number">0x83</span>);</span><br><span class="line">minute=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“分”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Minute(minute);</span><br><span class="line">temp=Read_DS1302(<span class="number">0x85</span>);</span><br><span class="line">hour=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“时”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Hour(hour);</span><br><span class="line">temp=Read_DS1302(<span class="number">0x87</span>);</span><br><span class="line">day=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“日”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Day(day);</span><br><span class="line">temp=Read_DS1302(<span class="number">0x89</span>);</span><br><span class="line">month=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“月”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Month(month);</span><br><span class="line">temp=Read_DS1302(<span class="number">0x8d</span>);</span><br><span class="line">year=((temp&amp;<span class="number">0x70</span>)&gt;&gt;<span class="number">4</span>)*<span class="number">10</span>+(temp&amp;<span class="number">0x0f</span>);<span class="comment">//将“年”的BCD码转换成对应的ASCII值</span></span><br><span class="line">Display_Year(year);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/DS1302%E6%97%B6%E9%92%9F%E6%A8%A1%E5%9D%97.png" alt></p><p><img src="/2021/05/13/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20DS1302%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/LCD1602%E6%A8%A1%E5%9D%97.png" alt></p><hr><p><strong>参考资料：</strong></p><p><a href="http://www.dianyuan.com/upload/community/2014/02/22/1393058389-67878.pdf" target="_blank" rel="noopener">DS1302中文资料</a></p><p><a href="https://blog.csdn.net/m0_37655357/article/details/78314570" target="_blank" rel="noopener">关于实时时钟模块DS1302使用心得</a></p><p><a href="https://blog.csdn.net/lin5103151/article/details/103544509" target="_blank" rel="noopener">时钟芯片DS1302的原理及使用</a></p><p><a href="https://blog.csdn.net/weixin_45859569/article/details/108249101" target="_blank" rel="noopener">DS1302的使用方式 及 51单片机连接DS1302的驱动程序</a></p><p><a href="https://blog.csdn.net/qq_36880027/article/details/80489465" target="_blank" rel="noopener">实时时钟DS1302详细介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机 —— IIC协议 &amp; EEPROM读写</title>
      <link href="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&amp;%20EEPROM%E8%AF%BB%E5%86%99/"/>
      <url>/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&amp;%20EEPROM%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>MCU：AT89S52</p><p>EEPROM：AT24C02</p><a id="more"></a><h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><h3 id="IIC物理层"><a href="#IIC物理层" class="headerlink" title="IIC物理层"></a>IIC物理层</h3><p>IIC协议是PHILIPS公司在1980年代开发的串行通信协议，半双工通信，多主从结构（任意时刻只有一主机），低速传输，支持多种传输速率（标准：100Kbit/s、快速：400Kbit/s、高速：3.4Mbit/s），传输距离短，主要用于MCU与外设的通信。IIC一共由两根总线组成：用于数据传输的<code>SDA</code>和用于时序控制的<code>SCL</code>。</p><h3 id="IIC协议层"><a href="#IIC协议层" class="headerlink" title="IIC协议层"></a>IIC协议层</h3><p>主机&amp;从机：控制<code>SCL</code>电平变换的器件即为主机。</p><p>IIC协议没有固定的波特率，但有时序的要求。</p><h4 id="IIC空闲状态"><a href="#IIC空闲状态" class="headerlink" title="IIC空闲状态"></a>IIC空闲状态</h4><p><code>SCL</code>和<code>SDA</code>均保持高电平。</p><h4 id="IIC起始信号"><a href="#IIC起始信号" class="headerlink" title="IIC起始信号"></a>IIC起始信号</h4><p><code>SCL</code>保持高电平，<code>SDA</code>由高电平跳变到低电平，产生一个下降沿，表示起始信号。</p><h4 id="IIC停止信号"><a href="#IIC停止信号" class="headerlink" title="IIC停止信号"></a>IIC停止信号</h4><p><code>SCL</code>保持高电平，<code>SDA</code>由低电平跳变到高电平，产生一个上升沿，表示停止信号。</p><h4 id="IIC响应信号"><a href="#IIC响应信号" class="headerlink" title="IIC响应信号"></a>IIC响应信号</h4><p>外设每接收到一字节的数据后，在第9个时钟脉冲到来前，（从机）将<code>SDA</code>稳定置低电平表示<code>应答</code>，（从机）将<code>SDA</code>稳定置高电平表示<code>非应答</code>。</p><h4 id="IIC数据传输"><a href="#IIC数据传输" class="headerlink" title="IIC数据传输"></a>IIC数据传输</h4><p>一字节数据由高位到低位依次传输，在数据传输过程中，主机必须保持<code>SCL</code>为低电平（因为当<code>SCL</code>为高电平时，<code>SDA</code>的任何电平变化都将被视为起始/停止信号）。</p><h4 id="IIC寻址信号"><a href="#IIC寻址信号" class="headerlink" title="IIC寻址信号"></a>IIC寻址信号</h4><p>主机发送一个起始信号后，接着发送一字节的寻址信号，该寻址信号的前7位表示器件地址（其中前4位固定为<code>1010</code>，后3位由从器件的对应的3个引脚的电平决定），第8位则为数据方向位（<code>0</code>表示主机写入数据，<code>1</code>表示主机读取数据），若从器件存在，则响应<code>应答</code>信号。</p><h4 id="IIC时序"><a href="#IIC时序" class="headerlink" title="IIC时序"></a>IIC时序</h4><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/%E6%80%BB%E7%BA%BF%E6%97%B6%E5%BA%8F.png" alt></p><h5 id="起始-停止时序"><a href="#起始-停止时序" class="headerlink" title="起始/停止时序"></a>起始/停止时序</h5><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/%E8%B5%B7%E5%A7%8B%E5%81%9C%E6%AD%A2%E6%97%B6%E5%BA%8F.png" alt></p><h5 id="写周期时序"><a href="#写周期时序" class="headerlink" title="写周期时序"></a>写周期时序</h5><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/%E5%86%99%E5%91%A8%E6%9C%9F%E6%97%B6%E5%BA%8F.png" alt></p><h5 id="应答时序"><a href="#应答时序" class="headerlink" title="应答时序"></a>应答时序</h5><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/%E5%BA%94%E7%AD%94%E6%97%B6%E5%BA%8F.png" alt></p><h2 id="EEPROM读写"><a href="#EEPROM读写" class="headerlink" title="EEPROM读写"></a>EEPROM读写</h2><p>开发板上的EEPROM使用IIC协议来读写数据。</p><h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>⑴发送IIC起始信号</p><p>⑵发送IIC寻址信号（从器件EEPROM的地址+<code>写</code>操作方向）</p><p>⑶发送将要存储数据的EEPROM的存储地址</p><p>⑷发送将要写入EEPROM的数据</p><h3 id="数据读出"><a href="#数据读出" class="headerlink" title="数据读出"></a>数据读出</h3><p>⑴发送IIC起始信号</p><p>⑵发送IIC寻址信号（从器件EEPROM的地址+<code>写</code>操作方向）</p><p>⑶发送将要读出数据的EEPROM的存储地址</p><p>⑷发送IIC起始信号</p><p>⑸发送IIC寻址信号（从器件EEPROM的地址+<code>读</code>操作方向）</p><p>⑹主机读取从器件返回的数据</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>一个00~99的计数器，每秒计数一次，具有断电记忆功能（开机后，从关机前的最新数值继续计数），软件模拟IIC协议。</p><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F.png" alt></p><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/%E6%A8%A1%E5%9D%97.png" alt></p><p><img src="/2021/05/08/51%E5%8D%95%E7%89%87%E6%9C%BA%20%E2%80%94%E2%80%94%20IIC%E5%8D%8F%E8%AE%AE%20&%20EEPROM%E8%AF%BB%E5%86%99/6%E4%BD%8D%E5%85%B1%E9%98%B4%E6%95%B0%E7%A0%81%E7%AE%A1%E6%A8%A1%E5%9D%97.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;<span class="built_in">int</span>rins.h&gt;</span><br><span class="line"></span><br><span class="line">bit x=<span class="number">0</span>;<span class="comment">//将计时值写入EEPROM的标志位</span></span><br><span class="line">sbit SCL=P2^<span class="number">1</span>;</span><br><span class="line">sbit SDA=P2^<span class="number">0</span>;</span><br><span class="line">sbit X=P2^<span class="number">4</span>;<span class="comment">//引脚P2^4为开发板上DS1302模块的复位引脚</span></span><br><span class="line">sbit DU=P2^<span class="number">6</span>;<span class="comment">//数码管模块段选位</span></span><br><span class="line">sbit WE=P2^<span class="number">7</span>;<span class="comment">//数码管模块位选位</span></span><br><span class="line"></span><br><span class="line">unsigned char num=<span class="number">0</span>;</span><br><span class="line">unsigned char i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unsigned char LEDS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;<span class="comment">//共阴数码管的段码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> LEDS_IO()<span class="comment">//数码管锁存</span></span><br><span class="line">&#123;</span><br><span class="line">WE=<span class="number">1</span>;</span><br><span class="line">P0=<span class="number">1</span>;</span><br><span class="line">WE=<span class="number">0</span>;</span><br><span class="line">DU=<span class="number">1</span>;</span><br><span class="line">P0=<span class="number">0</span>;</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay5ms()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=<span class="number">9</span>;</span><br><span class="line">j=<span class="number">244</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_Delay()</span><br><span class="line">&#123;</span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_INIT()<span class="comment">//IIC初始化</span></span><br><span class="line">&#123;</span><br><span class="line">X=<span class="number">0</span>;<span class="comment">//DS1302模块的复位电平为低电平，令DS1302模块一直处于复位状态，使其I/O端口（P2^0）不输出，避免干扰EEPROM模块的SDA端口（P2^0）</span></span><br><span class="line">SDA=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_Start()<span class="comment">//IIC起始信号</span></span><br><span class="line">&#123;</span><br><span class="line">SDA=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SDA=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_Stop()<span class="comment">//IIC停止信号</span></span><br><span class="line">&#123;</span><br><span class="line">SDA=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SDA=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_ACK()<span class="comment">//等待应答信号；“应答”信号：SDA=0；“非应答”信号：SDA=1</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line"><span class="keyword">while</span>((SDA==<span class="number">1</span>)&amp;&amp;(i&lt;<span class="number">256</span>))<span class="comment">//若超时，则视为“非应答”</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">SCL=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> IIC_Write(unsigned char DATA)<span class="comment">//IIC发送数据</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">unsigned char temp;</span><br><span class="line">temp=DATA;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">temp=temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">SCL=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SDA=CY;<span class="comment">//IIC数据的发送从高位开始，需要使用左移指令，而C语言的左移和右移指令，CY参与其中（CY并不是只有在进位和借位中用到），左移出来的一位赋给CY</span></span><br><span class="line">IIC_Delay();</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line">SCL=<span class="number">0</span>;<span class="comment">//将SCL置低电平，准备接收应答信号</span></span><br><span class="line">IIC_Delay();</span><br><span class="line">SDA=<span class="number">1</span>;<span class="comment">//释放SDA，准备接收从器件反馈的应答信号</span></span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char IIC_Read()<span class="comment">//IIC接收数据</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">unsigned char DATA;</span><br><span class="line">SCL=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">SDA=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">SCL=<span class="number">1</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">DATA=(DATA&lt;&lt;<span class="number">1</span>)|SDA;</span><br><span class="line">SCL=<span class="number">0</span>;</span><br><span class="line">IIC_Delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> EEPROM_Write(unsigned char ADDRESS,unsigned char DATA)<span class="comment">//写入EEPROM</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_Write(<span class="number">0xa0</span>);<span class="comment">//发送IIC从器件（EEPROM）地址，并选择“写”操作</span></span><br><span class="line">IIC_ACK();</span><br><span class="line">IIC_Write(ADDRESS);<span class="comment">//发送将要写入的EEPROM的存储地址</span></span><br><span class="line">IIC_ACK();</span><br><span class="line">IIC_Write(DATA);<span class="comment">//发送写入EEPROM的数据</span></span><br><span class="line">IIC_ACK();</span><br><span class="line">IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char EEPROM_Read(unsigned char ADDRESS)<span class="comment">//读取EEPROM</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char DATA;</span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_Write(<span class="number">0xa0</span>);</span><br><span class="line">IIC_ACK();</span><br><span class="line">IIC_Write(ADDRESS);</span><br><span class="line">IIC_ACK();</span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_Write(<span class="number">0xa1</span>);<span class="comment">//发送IIC从器件（EEPROM）地址，并选择“读”操作</span></span><br><span class="line">IIC_ACK();</span><br><span class="line">DATA=IIC_Read();</span><br><span class="line">IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> DATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> LEDS_OUTPUT(unsigned char m,unsigned char n)<span class="comment">//数码管显示</span></span><br><span class="line">&#123;</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">P0=LEDS[m];</span><br><span class="line">DU=<span class="number">1</span>;</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">WE=<span class="number">0</span>;</span><br><span class="line">P0=<span class="number">0x3e</span>;</span><br><span class="line">WE=<span class="number">1</span>;</span><br><span class="line">WE=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">P0=LEDS[n];</span><br><span class="line">DU=<span class="number">1</span>;</span><br><span class="line">DU=<span class="number">0</span>;</span><br><span class="line">WE=<span class="number">0</span>;</span><br><span class="line">P0=<span class="number">0x3d</span>;</span><br><span class="line">WE=<span class="number">1</span>;</span><br><span class="line">WE=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">IIC_INIT();</span><br><span class="line">LEDS_IO();</span><br><span class="line">num=EEPROM_Read(<span class="number">0x00</span>);</span><br><span class="line">TMOD=<span class="number">0x01</span>;</span><br><span class="line">TH0=<span class="number">0x4c00</span>;</span><br><span class="line">TL0=<span class="number">0x4c00</span>;</span><br><span class="line">TR0=<span class="number">1</span>;</span><br><span class="line">ET0=<span class="number">1</span>;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LEDS_OUTPUT(num/<span class="number">10</span>,num%<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">EEPROM_Write(<span class="number">0x00</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> T() <span class="built_in">int</span>errupt <span class="number">1</span><span class="comment">//每0.05秒中断一次</span></span><br><span class="line">&#123;</span><br><span class="line">TH0=<span class="number">0x4c00</span>;</span><br><span class="line">TL0=<span class="number">0x4c00</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)<span class="comment">//中断20次，即1秒</span></span><br><span class="line">&#123;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">num++;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong></p><p><a href="http://www.51hei.com/bbs/dpj-22299-1.html" target="_blank" rel="noopener">第14章 I2C总线与EEPROM</a></p><p><a href="https://blog.csdn.net/qq_34681938/article/details/95938557" target="_blank" rel="noopener">IIC协议超详细解释（适合小白入门）</a></p><p><a href="https://blog.csdn.net/shaguahaha/article/details/70766665" target="_blank" rel="noopener">IIC详解，包括原理、过程，最后一步步教你实现IIC</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/105366932?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162043634116780264049710%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162043634116780264049710&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-3-105366932.first_rank_v2_pc_rank_v29&utm_term=IIC" target="_blank" rel="noopener">IIC原理超详细讲解—值得一看</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编语言程序设计简要记录（二）</title>
      <link href="/2021/05/06/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/05/06/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>用冒泡排序算法实现对六个数6、8、2、0、16、5从大到小排序。</p><a id="more"></a><p>对于8086汇编语言，冒泡排序算法的关键是如何处理内循环和外循环对计数寄存器<code>CX</code>的争夺（循环体有两个，但用于<code>LOOP</code>循环计数的寄存器只有一个）；</p><p>其中一种方法可使用其他寄存器来保存一个循环体的计数值，但只有一个循环体可用<code>LOOP</code>指令来实现循环；</p><p>另一种方法则可使用堆栈来保存<code>CX</code>的值（相当于<code>CX</code>的值有两个），两个循环体均可使用<code>LOOP</code>指令。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">    NUM <span class="built_in">DB</span> <span class="number">6H</span>,<span class="number">8H</span>,<span class="number">2H</span>,<span class="number">0H</span>,<span class="number">10H</span>,<span class="number">5H</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">    <span class="meta">ASSUME</span> <span class="built_in">DS</span>:DATA,<span class="built_in">CS</span>:CODE</span><br><span class="line"></span><br><span class="line"><span class="symbol">    START:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">5</span>        <span class="comment">;外循环5次</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L1:</span>     <span class="comment">;外循环</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="built_in">CX</span>       <span class="comment">;将CX的值保存于DI，用于内循环L2的计数</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L2:</span>     <span class="comment">;内循环</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>]</span><br><span class="line">    <span class="keyword">CMP</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">JNC</span> COM</span><br><span class="line">    <span class="keyword">XCHG</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">MOV</span> NUM[<span class="built_in">BX</span>],<span class="built_in">AL</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    COM:</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">BX</span></span><br><span class="line">    <span class="keyword">DEC</span> <span class="built_in">DI</span></span><br><span class="line">    <span class="keyword">JNZ</span> L2      <span class="comment">;若DI不为0，则跳转到L2执行</span></span><br><span class="line">    <span class="keyword">LOOP</span> L1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">4CH</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line">CODE ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><h3 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h3><p><img src="/2021/05/06/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/0.png" alt></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="源程序-1"><a href="#源程序-1" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">    NUM <span class="built_in">DB</span> <span class="number">6H</span>,<span class="number">8H</span>,<span class="number">2H</span>,<span class="number">0H</span>,<span class="number">10H</span>,<span class="number">5H</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">    <span class="meta">ASSUME</span> <span class="built_in">DS</span>:DATA,<span class="built_in">CS</span>:CODE</span><br><span class="line"></span><br><span class="line"><span class="symbol">    START:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L1:</span>     <span class="comment">;外循环</span></span><br><span class="line">    <span class="keyword">PUSH</span> <span class="built_in">CX</span>     <span class="comment">;将CX的值压栈，即另外保存，CX原有的值将用于内循环L2的计数</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L2:</span>     <span class="comment">;内循环</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>]</span><br><span class="line">    <span class="keyword">CMP</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">JNC</span> COM</span><br><span class="line">    <span class="keyword">XCHG</span> <span class="built_in">AL</span>,NUM[<span class="built_in">BX</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">MOV</span> NUM[<span class="built_in">BX</span>],<span class="built_in">AL</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    COM:</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">BX</span></span><br><span class="line">    <span class="keyword">LOOP</span> L2</span><br><span class="line">    <span class="keyword">POP</span> <span class="built_in">CX</span>      <span class="comment">;跳出内循环L2后，将弹栈的值赋给CX，用于外循环L1的计数</span></span><br><span class="line">    <span class="keyword">LOOP</span> L1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">4CH</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><h3 id="调试结果-1"><a href="#调试结果-1" class="headerlink" title="调试结果"></a>调试结果</h3><p><img src="/2021/05/06/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 8086汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编语言程序设计简要记录（一）</title>
      <link href="/2021/04/27/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/04/27/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>写了一个涉及到程序循环和分支选择的简单程序来练练手(<em>/ω＼</em>)。</p><a id="more"></a><p>将数据<code>0FFH</code>、<code>02H</code>、<code>0FCBH</code>、<code>03H</code>、<code>1000H</code>、<code>0F3H</code>中大于或等于<code>0FFH</code>的数存入以偏移地址<code>100H</code>为起始的内存中，小于<code>0FFH</code>的数存入以偏移地址<code>200H</code>为起始的内存中。</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">    NUM <span class="built_in">DW</span> <span class="number">0FFH</span>,<span class="number">02H</span>,<span class="number">0FCBH</span>,<span class="number">03H</span>,<span class="number">1000H</span>,<span class="number">0F3H</span></span><br><span class="line">    ORG <span class="number">100H</span>        <span class="comment">;自定义的内存空间的偏移地址起始，下同</span></span><br><span class="line">    M <span class="built_in">DW</span> <span class="number">6</span> DUP(?)       <span class="comment">;定义一段字长为6的内存空间用于存储数值比0FFH大的数</span></span><br><span class="line">    ORG <span class="number">200H</span></span><br><span class="line">    N <span class="built_in">DW</span> <span class="number">6</span> DUP(?)       <span class="comment">;定义一段字长为6的内存空间用于存储数值比0FFH小的数</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE,<span class="built_in">DS</span>:DATA</span><br><span class="line">    </span><br><span class="line"><span class="symbol">    START:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">6</span>        <span class="comment">;循环执行的次数，每执行完一次循环，CX的值减1，直至CX的值变为0才退出循环</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">SI</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">BP</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L:</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">BX</span>,NUM[<span class="built_in">SI</span>]</span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DX</span>,<span class="number">0FFH</span></span><br><span class="line">    <span class="keyword">CMP</span> <span class="built_in">BX</span>,<span class="built_in">DX</span>       <span class="comment">;比较存储在BX和DX中的数的大小</span></span><br><span class="line">    <span class="keyword">JNC</span> L1      <span class="comment">;若BX中的数大于DX中的数，则直接执行L1处的指令；若BX中的数小于DX中的数，则继续顺序执行往下的指令</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">DX</span>,<span class="built_in">BX</span>       <span class="comment">;将小于0FFH的数（即BX中的数）送入DX，DX中原有的数0FFH将被覆写</span></span><br><span class="line">    <span class="keyword">MOV</span> N[<span class="built_in">DI</span>],<span class="built_in">DX</span>        <span class="comment">;将DX中的数写入内存</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">DI</span>      <span class="comment">;偏移地址加2，下同</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">    <span class="keyword">JMP</span> L2      <span class="comment">;跳转至标记L2，否则将继续往下执行L1处的指令，造成程序逻辑错误</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L1:</span>     <span class="comment">;当L1处的指令执行完毕后，继续往下执行L2处的指令</span></span><br><span class="line">    <span class="keyword">MOV</span> M[<span class="built_in">BP</span>],<span class="built_in">BX</span>        <span class="comment">;将大于0FFH的数写入内存</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">BP</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">BP</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">    <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    L2:</span></span><br><span class="line">    <span class="keyword">LOOP</span> L      <span class="comment">;返回标记L以此循环执行，直至CX的值变为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">4CH</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure><p><img src="/2021/04/27/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 8086汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言结构体简要笔记</title>
      <link href="/2021/04/20/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/20/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>C语言中的结构体是一种由若干个不同类型的数据组合而成、可由用户自定义的数据类型。</p><a id="more"></a><h2 id="结构体的定义和初始化"><a href="#结构体的定义和初始化" class="headerlink" title="结构体的定义和初始化"></a>结构体的定义和初始化</h2><p><del>因为我懒，</del>直接上源码吧，反正只有我自己看(つд⊂)。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">me</span>=&#123;</span><span class="string">"NIMITIZ"</span>,<span class="number">19</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s\n"</span>,me.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age: %d\n"</span>,me.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sex: %c\n"</span>,me.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式二</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;me=&#123;<span class="string">"NIMITIZ"</span>,<span class="number">19</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s\n"</span>,me.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age: %d\n"</span>,me.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sex: %c\n"</span>,me.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式三</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">char</span> sex;</span><br><span class="line">    &#125;me;</span><br><span class="line">    me.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">    me.age=<span class="number">19</span>;</span><br><span class="line">    me.sex=<span class="string">'M'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s\n"</span>,me.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age: %d\n"</span>,me.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sex: %c\n"</span>,me.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构体可包含多个C语言提供的数据类型（例如<code>int</code>、<code>float</code>、<code>char</code>等），也可包含其他结构体；</li><li><strong>结构体不能整体引用，只能引用结构体成员</strong>；</li><li><strong>在定义结构体时，可对其进行整体赋值；但在使用过程中，只能对结构体成员逐一赋值</strong>；</li><li><strong>结构体</strong>只是创建该数据类型的模板，<strong>不占用内存空间</strong>；<strong>结构体成员</strong>才是该数据类型的实体，<strong>需要占用内存空间</strong>。</li></ul><h2 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h2><p>可把结构体作为函数参数来使用。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">(struct Person I)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s\n"</span>,I.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age: %d\n"</span>,I.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sex: %c\n"</span>,I.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">me</span>;</span></span><br><span class="line">    me.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">    me.age=<span class="number">19</span>;</span><br><span class="line">    me.sex=<span class="string">'M'</span>;</span><br><span class="line">    <span class="literal">OUTPUT</span>(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>结构体数据即数组中的每个元素均为结构体。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    char group;</span><br><span class="line">    int score;</span><br><span class="line">&#125;</span><br><span class="line">class[]=&#123;&#123;<span class="string">"Arthur"</span>,<span class="string">'A'</span>,89&#125;,&#123;<span class="string">"John"</span>,<span class="string">'B'</span>,87&#125;,&#123;<span class="string">"Dutch"</span>,<span class="string">'B'</span>,96&#125;,&#123;<span class="string">"Micah"</span>,<span class="string">'A'</span>,76&#125;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,<span class="attribute">sum</span>=0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=class[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"ALL: %d"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;</span><br><span class="line">Person=&#123;<span class="string">"NIMITIZ"</span>,<span class="number">19</span>,<span class="string">'M'</span>&#125;,*ptr=&amp;Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s  age: %d  sex: %c"</span>,(*ptr).name,(*ptr).age,(*ptr).sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name: %s  age: %d  sex: %c"</span>,ptr-&gt;name,ptr-&gt;age,ptr-&gt;sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数组-amp-指向结构体的指针"><a href="#结构体数组-amp-指向结构体的指针" class="headerlink" title="结构体数组 &amp; 指向结构体的指针"></a>结构体数组 &amp; 指向结构体的指针</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">char</span> group;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>[]=&#123;</span>&#123;<span class="string">"Arthur"</span>,<span class="string">'A'</span>,<span class="number">89</span>&#125;,&#123;<span class="string">"John"</span>,<span class="string">'B'</span>,<span class="number">87</span>&#125;,&#123;<span class="string">"Dutch"</span>,<span class="string">'B'</span>,<span class="number">96</span>&#125;,&#123;<span class="string">"Micah"</span>,<span class="string">'A'</span>,<span class="number">76</span>&#125;&#125;,*ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="keyword">sizeof</span>(class)/<span class="keyword">sizeof</span>(struct G);</span><br><span class="line">    <span class="keyword">for</span>(ptr=class;ptr&lt;class+x;ptr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name: %s  group: %c  score: %d\n"</span>,ptr-&gt;name,ptr-&gt;group,ptr-&gt;score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intel 8086の指令系统</title>
      <link href="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Intel 8086中的指令按功能可分为六组：</p><p>① 数据传送；</p><p>② 算术运算；</p><p>③逻辑运算和移位；</p><p>④ 串操作；</p><p>⑤ 程序控制；</p><p>⑥ 标志操作和处理器控制。</p><a id="more"></a><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="通用传送指令MOV"><a href="#通用传送指令MOV" class="headerlink" title="通用传送指令MOV"></a>通用传送指令MOV</h3><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>MOV    OPRD1,OPRD2</code>（<code>OPRD1</code>和<code>OPRD2</code>分别表示<strong>目的操作数</strong>和<strong>源操作数</strong>）</p><h4 id="指令功能"><a href="#指令功能" class="headerlink" title="指令功能"></a>指令功能</h4><ul><li><p>CPU内部<strong>寄存器之间</strong>数据的任意传送（除了<code>CS</code>和<code>IP</code>以外）</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%86%85%E9%83%A8%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p></li><li><p><strong>立即数</strong>传送至CPU内部的<strong>通用寄存器组</strong>（即<code>AX</code>、<code>BX</code>、<code>CX</code>、<code>DX</code>、<code>BP</code>、<code>SP</code>、<code>SI</code>、<code>DI</code>）</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%AB%8B%E5%8D%B3%E6%95%B0.png" alt></p></li><li><p>CPU内部<strong>寄存器</strong>（除了<code>CS</code>和<code>IP</code>以外）与<strong>存储器</strong>（所有寻址方式）之间的数据传送</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p></li><li><p>用<strong>立即数</strong>给<strong>存储单元赋值</strong></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E8%B5%8B%E5%80%BC.png" alt></p></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p><code>MOV</code>指令<strong>不允许对<code>CS</code>和<code>IP</code>进行操作</strong></p></li><li><p>两个操作数中，除了立即寻址以外必须有一个为寄存器寻址方式，即<strong>两个存储器操作数之间</strong>不允许直接进行数据传送</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E5%86%85%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt></p></li><li><p><strong>两个段寄存器之间</strong>不能直接传送数据，也不允许用立即寻址方式来为段寄存器赋初值</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E8%B5%8B%E5%88%9D%E5%80%BC.png" alt></p></li><li><p><code>MOV</code>指令<strong>不影响标志位</strong></p></li></ul><h3 id="堆栈指令"><a href="#堆栈指令" class="headerlink" title="堆栈指令"></a>堆栈指令</h3><p>堆栈操作总是<strong>字操作</strong>，包括入栈和出栈。</p><h4 id="入栈指令PUSH"><a href="#入栈指令PUSH" class="headerlink" title="入栈指令PUSH"></a>入栈指令PUSH</h4><h5 id="指令格式-1"><a href="#指令格式-1" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>PUSH    OPRD</code>（<code>OPRD</code>为源操作数）</p><p>源操作数可以是CPU内部的16位<strong>通用寄存器</strong>、<strong>段寄存器（除了<code>CS</code>以外）</strong>和<strong>内存操作数（所有寻址方式）</strong>；入栈操作对象必须是<strong>16位数</strong>。</p><h5 id="指令功能-1"><a href="#指令功能-1" class="headerlink" title="指令功能"></a>指令功能</h5><p>将数据压入堆栈。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4.png" alt></p><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>入栈方向是由高地址向低地址进行。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%85%A5%E6%A0%88.png" alt></p><h4 id="出栈指令POP"><a href="#出栈指令POP" class="headerlink" title="出栈指令POP"></a>出栈指令POP</h4><h5 id="指令格式-2"><a href="#指令格式-2" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>POP    OPRD</code>（<code>OPRD</code>为目的操作数）</p><p>目的操作数可以是CPU内部的16位<strong>通用寄存器</strong>、<strong>段寄存器（除了<code>CS</code>以外）</strong>和<strong>内存操作数（所有寻址方式）</strong>；出栈操作对象必须是<strong>16位数</strong>。</p><h5 id="指令功能-2"><a href="#指令功能-2" class="headerlink" title="指令功能"></a>指令功能</h5><p>将数据弹出堆栈。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><p>不能从栈顶弹出一个字给<code>CS</code>，即<strong><code>CS</code>不能作目的操作数</strong>。</p><h3 id="交换指令XCHG"><a href="#交换指令XCHG" class="headerlink" title="交换指令XCHG"></a>交换指令XCHG</h3><h4 id="指令格式-3"><a href="#指令格式-3" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>XCHG    OPRD1,OPRD2</code></p><h4 id="指令功能-3"><a href="#指令功能-3" class="headerlink" title="指令功能"></a>指令功能</h4><p>完成数据交换。将一个字节或一个字的源操作数与目的操作数进行交换。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4.png" alt></p><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>交换能在<strong>通用寄存器之间</strong>、<strong>通用寄存器与存储器之间</strong>进行；</p></li><li><p><strong>段寄存器和立即数不能作为一个操作数</strong>；</p></li><li><p><strong>不能在存储器与存储器之间交换数据</strong>。</p></li></ul><h3 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h3><h4 id="输入输出指令（IN，OUT）"><a href="#输入输出指令（IN，OUT）" class="headerlink" title="输入输出指令（IN，OUT）"></a>输入输出指令（IN，OUT）</h4><p>Intel 8086通过输入输出指令与外设进行数据交换。</p><h5 id="IN指令"><a href="#IN指令" class="headerlink" title="IN指令"></a>IN指令</h5><h6 id="指令格式-4"><a href="#指令格式-4" class="headerlink" title="指令格式"></a>指令格式</h6><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/IN%E6%8C%87%E4%BB%A4.png" alt></p><h6 id="指令功能-4"><a href="#指令功能-4" class="headerlink" title="指令功能"></a>指令功能</h6><p>IN指令允许将一个字节或一个字由一个输入端口传送到<strong><code>AL</code></strong>或<strong><code>AX</code></strong>中；若端口地址超过<strong>255</strong>，则必须用<strong><code>DX</code></strong>保存端口地址。</p><h6 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h6><p>16位输入输出指令中的端口地址只能取偶地址。</p><h5 id="OUT指令"><a href="#OUT指令" class="headerlink" title="OUT指令"></a>OUT指令</h5><h6 id="指令格式-5"><a href="#指令格式-5" class="headerlink" title="指令格式"></a>指令格式</h6><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/OUT%E6%8C%87%E4%BB%A4.png" alt></p><h6 id="指令功能-5"><a href="#指令功能-5" class="headerlink" title="指令功能"></a>指令功能</h6><p>将<code>AL</code>或<code>AX</code>中的数据输出到I/O端口。</p><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><h5 id="指令格式-6"><a href="#指令格式-6" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>LEA    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/LEA.png" alt></p><h5 id="指令功能-6"><a href="#指令功能-6" class="headerlink" title="指令功能"></a>指令功能</h5><p>将源操作数的地址偏移量传送至目的操作数，该指令通常用来建立串操作指令所需的寄存器指针。</p><h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>源操作数必须是一个内存操作数；</li><li>目的操作数必须是一个16位的通用寄存器。</li></ul><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><h5 id="指令格式-7"><a href="#指令格式-7" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>ADD    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/ADD.png" alt></p><h5 id="指令功能-7"><a href="#指令功能-7" class="headerlink" title="指令功能"></a>指令功能</h5><p>完成两个操作数相加（<strong>不带进位的加法</strong>），将结果送至目的操作数；目的操作数可以是<strong>累加器</strong>，<strong>任意通用寄存器</strong>以及<strong>存储器操作数</strong>。</p><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><p><strong>ADD指令对标志位<code>CF</code>、<code>DF</code>、<code>PF</code>、<code>SF</code>、<code>ZF</code>和<code>AF</code>有影响。</strong></p><h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><h5 id="指令格式-8"><a href="#指令格式-8" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>ADC    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/ADC.png" alt></p><h5 id="指令功能-8"><a href="#指令功能-8" class="headerlink" title="指令功能"></a>指令功能</h5><p><strong>带进位的加法</strong>；与ADD指令类似，但在两个操作数相加时，要将进位标志<strong><code>CF</code></strong>的值加上，再将结果送至目的操作数。</p><h5 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h5><p>ADC指令对标志位的影响与ADD指令相同。</p><h4 id="INC"><a href="#INC" class="headerlink" title="INC"></a>INC</h4><h5 id="指令格式-9"><a href="#指令格式-9" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>INC    OPRD</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/INC.png" alt></p><h5 id="指令功能-9"><a href="#指令功能-9" class="headerlink" title="指令功能"></a>指令功能</h5><p>完成对指定的操作数加1，然后返回此操作数；<strong>INC指令主要用于在循环程序中修改地址指针和循环次数</strong>。</p><h5 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h5><p><strong>INC指令执行的结果影响标志位<code>AF</code>、<code>OF</code>、<code>PF</code>、<code>SF</code>和<code>ZF</code>，而对进位标志没有影响。</strong></p><h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><h4 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h4><h5 id="指令格式-10"><a href="#指令格式-10" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>SUB    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/SUB.png" alt></p><h5 id="指令功能-10"><a href="#指令功能-10" class="headerlink" title="指令功能"></a>指令功能</h5><p>完成两个操作数相减（<strong>不考虑借位</strong>），并将结果送至目的操作数。</p><h4 id="SBB"><a href="#SBB" class="headerlink" title="SBB"></a>SBB</h4><h5 id="指令格式-11"><a href="#指令格式-11" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>SBB    OPRD1,OPRD2</code></p><h5 id="指令功能-11"><a href="#指令功能-11" class="headerlink" title="指令功能"></a>指令功能</h5><p>与SUB指令类似，但在两个操作数相减时，<strong>还要减去借位标志<code>CF</code>的值</strong>。</p><h5 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h5><p>SBB指令对标志位<code>AF</code>、<code>CF</code>、<code>OF</code>、<code>PF</code>、<code>SF</code>和<code>ZF</code>都有影响。</p><h4 id="DEC"><a href="#DEC" class="headerlink" title="DEC"></a>DEC</h4><h5 id="指令格式-12"><a href="#指令格式-12" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>DEC    OPRD</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/DEC.png" alt></p><h5 id="指令功能-12"><a href="#指令功能-12" class="headerlink" title="指令功能"></a>指令功能</h5><p>对指定的操作数减1，然后返回此操作数。</p><h5 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>在相减时，将操作数作为一个<strong>无符号二进制数</strong>来进行操作；</li><li>指令执行的结果<strong>影响标志位<code>AF</code>、<code>OF</code>、<code>PF</code>、<code>SF</code>和<code>ZF</code></strong>，但<strong>对<code>CF</code>无影响</strong>。</li></ul><h4 id="NEG"><a href="#NEG" class="headerlink" title="NEG"></a>NEG</h4><h5 id="指令格式-13"><a href="#指令格式-13" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>NEG    OPRD</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/NEG.png" alt></p><h5 id="指令功能-13"><a href="#指令功能-13" class="headerlink" title="指令功能"></a>指令功能</h5><p>对操作数取2的补码，即相当于用0减去操作数，再将结果送回操作数。</p><h5 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li><strong>若在字节操作时对-128，或在字操作时对-32768取补，则操作数无变化，但标志位<code>OF</code>置1</strong>；</li><li>NEG指令影响标志位<strong><code>AF</code>、<code>CF</code>、<code>OF</code>、<code>PF</code>、<code>SF</code>和<code>ZF</code></strong>；</li><li><strong>指令执行的结果一般总是使标志位<code>CF</code>置1，除非在操作数为0时，才使<code>CF</code>置0</strong>。</li></ul><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><h5 id="指令格式-14"><a href="#指令格式-14" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>CMP    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/CMP.png" alt></p><h5 id="指令功能-14"><a href="#指令功能-14" class="headerlink" title="指令功能"></a>指令功能</h5><p>CMP指令用于比较两个数之间的关系，两个操作数相减（<strong>目的操作数减去源操作数</strong>），使结果反映在标志位<strong><code>ZF</code></strong>上，但并不返回结果。</p><ul><li><p>若两操作数<strong>相等</strong>，相减后结果为0，<strong><code>ZF</code>置1</strong>，否则置0；</p></li><li><p>若两操作数不相等，则可通过其他标志位的状态来确定两者的大小：</p><ul><li><p>若两个操作数为<strong>无符号数</strong>，则可根据标志位<strong><code>CF</code></strong>的状态来判断：</p><ul><li>若<strong><code>CF=0</code></strong>，则<strong>目的操作数大于或等于源操作数</strong>；</li><li>若<strong><code>CF=1</code></strong>，则<strong>目的操作数小于源操作数</strong>；</li></ul></li><li><p>若两个操作数为有符号数，则可根据标志位<code>OF</code>与<code>SF</code>来判断：</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0.png" alt></p><ul><li>若<code>OF</code>与<code>SF</code>的值相同，则被减数比减数大；</li><li>若<code>OF</code>与<code>SF</code>的值不同，则被减数比减数小。</li></ul></li></ul></li></ul><h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><h4 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h4><h5 id="指令格式-15"><a href="#指令格式-15" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>MUL    OPRD</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/MUL.png" alt></p><h5 id="指令功能-15"><a href="#指令功能-15" class="headerlink" title="指令功能"></a>指令功能</h5><p><strong>无符号数乘法指令</strong>，完成字节与字节相乘、字与字相乘，且默认的操作数放在<code>AL</code>或<code>AX</code>中，<strong>源操作数由指令给出</strong>。</p><h5 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li><strong>8位数</strong>相乘，结果为<strong>16位数</strong>，放在<strong><code>AX</code></strong>中；</li><li><strong>16位数</strong>相乘，结果为<strong>32位数</strong>，<strong>高16位</strong>放在<strong><code>DX</code></strong>，<strong>低16位</strong>放在<strong><code>AX</code></strong>；</li><li><strong>源操作数不能为立即数</strong>；</li><li>当结果的高半部分不为0，则<code>CF=1</code>，<code>OF=1</code>；否则<code>CF=0</code>，<code>OF=0</code>。</li></ul><h4 id="IMUL"><a href="#IMUL" class="headerlink" title="IMUL"></a>IMUL</h4><h5 id="指令格式-16"><a href="#指令格式-16" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>IMUL    OPRD</code></p><h5 id="指令功能-16"><a href="#指令功能-16" class="headerlink" title="指令功能"></a>指令功能</h5><p><strong>带符号数乘法指令</strong>，与MUL指令类似。</p><h5 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h5><p>当结果的高半部分不是结果的低半部分的符号扩展时，标志位<code>CF</code>和<code>OF</code>将置位；否则，标志位<code>CF</code>和<code>OF</code>都置0。</p><h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><h4 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a>DIV</h4><h5 id="指令格式-17"><a href="#指令格式-17" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>DIV    OPRD</code></p><h5 id="指令功能-17"><a href="#指令功能-17" class="headerlink" title="指令功能"></a>指令功能</h5><p><strong>无符号数除法指令</strong>；在字节运算时，被除数放在<code>AX</code>中，商放在<code>AL</code>中，余数放在<code>AH</code>中；在字运算时，被除数为<code>DX</code>与<code>AX</code>构成的32位数，商放在<code>AX</code>中，余数放在<code>DX</code>中。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4.png" alt></p><h5 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h5><p><strong>源操作数</strong>可为<strong>除立即寻址方式以外</strong>的任何一种寻址方式，且指令执行<strong>对所有标志位都无定义</strong>。</p><h4 id="IDIV"><a href="#IDIV" class="headerlink" title="IDIV"></a>IDIV</h4><h5 id="指令格式-18"><a href="#指令格式-18" class="headerlink" title="指令格式"></a>指令格式</h5><p><code>IDIV    OPRD</code></p><h5 id="指令功能-18"><a href="#指令功能-18" class="headerlink" title="指令功能"></a>指令功能</h5><p><strong>带符号数除法指令</strong>；执行过程同DIV指令。</p><h5 id="注意事项-15"><a href="#注意事项-15" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>在IDIV指令中，<strong>操作数的最高位为符号位，运算结果商的最高位也为符号位</strong>；</li><li>在IDIV指令执行过程中，若<strong>商超出</strong>正常范围<strong>（ -128 ~ +127 或 -32768 ~ +32767 ）</strong>，则<strong>产生0号中断</strong>。</li></ul><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><p>在<strong>双操作数</strong>的逻辑运算指令中，<strong>必须有一个操作数为寄存器寻址方式</strong>，且<strong>目的操作数不能为立即数</strong>；同时会使<code>CF=0</code>和<code>OF=0</code>，<code>AF</code>无定义，而<code>SF</code>、<code>ZF</code>和<code>PF</code>则根据运算结果而定。</p><h3 id="NOT指令"><a href="#NOT指令" class="headerlink" title="NOT指令"></a>NOT指令</h3><h4 id="指令格式-19"><a href="#指令格式-19" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>NOT    OPRD</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/NOT.png" alt></p><h4 id="指令功能-19"><a href="#指令功能-19" class="headerlink" title="指令功能"></a>指令功能</h4><p>对操作数求反，然后送回原处；操作数可以是寄存器或存储器内容。此指令对标志位无影响。</p><h4 id="注意事项-16"><a href="#注意事项-16" class="headerlink" title="注意事项"></a>注意事项</h4><p>NOT指令的<strong>操作数不能为立即数</strong>。</p><h3 id="AND指令"><a href="#AND指令" class="headerlink" title="AND指令"></a>AND指令</h3><h4 id="指令格式-20"><a href="#指令格式-20" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>AND    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/AND.png" alt></p><h4 id="指令功能-20"><a href="#指令功能-20" class="headerlink" title="指令功能"></a>指令功能</h4><p>对两个操作数进行按位的逻辑“与”运算，结果送回目的操作数；<strong>目的操作数</strong>可以是<strong>累加器</strong>、<strong>任意通用寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>；<strong>源操作数</strong>可以是<strong>立即数</strong>、<strong>寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>。</p><h4 id="注意事项-17"><a href="#注意事项-17" class="headerlink" title="注意事项"></a>注意事项</h4><p>AND指令可以进行字节操作，也可以进行字操作。</p><h3 id="TEST指令"><a href="#TEST指令" class="headerlink" title="TEST指令"></a>TEST指令</h3><h4 id="指令格式-21"><a href="#指令格式-21" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>TEST    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/TEST.png" alt></p><h4 id="指令功能-21"><a href="#指令功能-21" class="headerlink" title="指令功能"></a>指令功能</h4><p>完成与AND指令相同的操作，<strong>结果反映在标志位上</strong>，但并<strong>不送回</strong>。</p><h3 id="OR指令"><a href="#OR指令" class="headerlink" title="OR指令"></a>OR指令</h3><h4 id="指令格式-22"><a href="#指令格式-22" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>OR    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/OR.png" alt></p><h4 id="指令功能-22"><a href="#指令功能-22" class="headerlink" title="指令功能"></a>指令功能</h4><p>对指定的两个操作数进行逻辑“或”运算；运算结果返回目的操作数。<strong>目的操作数</strong>可以是<strong>累加器</strong>、<strong>任意通用寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>；<strong>源操作数</strong>可以是<strong>立即数</strong>、<strong>寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>。</p><h3 id="XOR指令"><a href="#XOR指令" class="headerlink" title="XOR指令"></a>XOR指令</h3><h4 id="指令格式-23"><a href="#指令格式-23" class="headerlink" title="指令格式"></a>指令格式</h4><p><code>XOR    OPRD1,OPRD2</code></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/XOR.png" alt></p><h4 id="指令功能-23"><a href="#指令功能-23" class="headerlink" title="指令功能"></a>指令功能</h4><p>对指定的两个操作数进行“异或”运算，结果送回目的操作数。<strong>目的操作数</strong>可以是<strong>累加器</strong>、<strong>任意通用寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>；<strong>源操作数</strong>可以是<strong>立即数</strong>、<strong>寄存器</strong>或<strong>内存操作数（所有寻址方式）</strong>。</p><h2 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h2><h3 id="算术-逻辑移位指令"><a href="#算术-逻辑移位指令" class="headerlink" title="算术/逻辑移位指令"></a>算术/逻辑移位指令</h3><h4 id="指令格式-24"><a href="#指令格式-24" class="headerlink" title="指令格式"></a>指令格式</h4><p>（M为移位次数，可以是<strong>1</strong>或<strong><code>CL</code></strong>）</p><ul><li><p>算术左移指令：<code>SAL    OPRD,M</code></p></li><li><p>逻辑左移指令：<code>SHL    OPRD,M</code></p></li><li><p>算术右移指令：<code>SAR    OPRD,M</code></p></li><li><p>逻辑右移指令：<code>SHR    OPRD,M</code></p></li></ul><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%911.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%912.png" alt></p><h4 id="指令功能-24"><a href="#指令功能-24" class="headerlink" title="指令功能"></a>指令功能</h4><p>对<strong>寄存器操作数</strong>或<strong>内存操作数</strong>进行指定的移位；可以进行字节操作或字操作。</p><h3 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h3><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.png" alt></p><p>前两条循环指令未将标志位<code>CF</code>包含在循环体内；后两条循环指令将标志位<code>CF</code>包含在循环体内。</p><p>循环指令可以进行字节操作或字操作；操作数可以是寄存器操作数，也可以是内存操作数；可以循环移位一次，也可以由<code>CL</code>来决定循环移位的次数。</p><p>左移一位，只要左移后的数未超出一个字节或一个字的表达范围，则相当于原数乘以2；右移一位则相当于原数除以2。</p><h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><ul><li>串操作指令可以用来实现内存区域的数据串操作；数据串可以是字节串，也可以是字串；</li><li>源操作数用寄存器<code>SI</code>寻址，默认在数据段<code>DS</code>中；</li><li>目的操作数用寄存器<code>DI</code>寻址，默认在附加段<code>ES</code>中；</li><li>字串长度默认在<code>CX</code>中，存取或搜索的值默认在<code>AL</code>中；</li><li>每执行一次串操作指令，<code>SI</code>和<code>DI</code>将自动修改：<ul><li><code>+1</code>（对于字节串）或<code>+2</code>（对于字串）；</li><li><code>-1</code>（对于字节串）或<code>-2</code>（对于字串）；</li><li>执行<code>CLD</code>指令后，<code>DF=0</code>，地址指针增1或2；</li><li>执行<code>STD</code>指令后，<code>DF=1</code>，地址指针减1或2。</li></ul></li></ul><h3 id="重复指令前缀"><a href="#重复指令前缀" class="headerlink" title="重复指令前缀"></a>重复指令前缀</h3><p>串操作指令可以与重复指令前缀配合使用，从而可以使操作得以重复进行，及时停止。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%87%8D%E5%A4%8D%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80.png" alt></p><h3 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h3><h4 id="MOVS指令"><a href="#MOVS指令" class="headerlink" title="MOVS指令"></a>MOVS指令</h4><p>将数据段中由<code>SI</code>间接寻址的一个字节或一个字传送到附加段中由<code>DI</code>间接寻址的一个字节单元或一个字单元，然后根据<code>DF</code>及所传送数据的类型（字节或字）对<code>SI</code>和<code>DI</code>进行修改，在指令重复前缀<code>REP</code>的控制下，可将数据段中的整串数据传送到附加段。该指令不影响标志位。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/MOVS.png" alt></p><h4 id="CMPS指令"><a href="#CMPS指令" class="headerlink" title="CMPS指令"></a>CMPS指令</h4><p>将数据段中由<code>SI</code>间接寻址的一个字节或一个字与附加段中由<code>DI</code>间接寻址的一个字节或一个字进行比较操作，使比较的结果影响标志位，然后根据<code>DF</code>及所进行比较的操作数类型（字节或字）对<code>SI</code>和<code>DI</code>进行修改，在指令重复前缀<code>REPE</code>/<code>REPZ</code>或<code>REPNE</code>/<code>REPNZ</code>的控制下，可在两个数据串中寻找第一个不相等的字节或字，或者第一个相等的字节或字。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/CMPS.png" alt></p><h4 id="SCAS指令"><a href="#SCAS指令" class="headerlink" title="SCAS指令"></a>SCAS指令</h4><p>用由指令指定的关键字节或关键字（分别存放在<code>AL</code>或<code>AX</code>中），与附加段中由<code>DI</code>间接寻址的字节串（或字串）中的一个字节（或字）进行比较操作，使比较的结果影响标志位，然后根据<code>DF</code>及所进行操作的数据类型（字节或字）对<code>DI</code>进行修改，在指令重复前缀<code>REPE</code>/<code>REPZ</code>或<code>REPNE</code>/<code>REPNZ</code>的控制下，可在指定的数据串中搜索第一个与关键字节（或字）匹配的字节（或字），或者搜索第一个与关键字节（或字）不匹配的字节（或字）。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/SCAS.png" alt></p><h4 id="STOS指令"><a href="#STOS指令" class="headerlink" title="STOS指令"></a>STOS指令</h4><p>将指令中指定的一个字节或一个字（分别存放在<code>AL</code>或<code>AX</code>中），传送到附加段中由<code>DI</code>间接寻址的字节内存单元（或字内存单元），然后根据<code>DF</code>及所进行操作的数据类型（字节或字）对<code>DI</code>进行修改操作。在指令重复前缀的控制下，可连续将<code>AL</code>（或<code>AX</code>）的内容存入到附加段中的一段内存区域，该指令不影响标志位。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/STOS.png" alt></p><h4 id="LODS指令"><a href="#LODS指令" class="headerlink" title="LODS指令"></a>LODS指令</h4><p>将数据段中由<code>SI</code>间接寻址的字节内存单元（或字内存单元）中指定的一个字节或一个字传送到<code>AL</code>（或<code>AX</code>）中，然后根据<code>DF</code>及所进行操作的数据类型（字节或字）对<code>SI</code>进行修改操作。在指令重复前缀的控制下，可连续将数据段中的一段内存区域中数据读入<code>AL</code>（或<code>AX</code>）中，该指令不影响标志位。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/LODS0.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/LODS1.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/LODS2.png" alt></p><h2 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h2><p>程序控制指令用于实现程序分支、循环等程序结构，通过改变<code>IP</code>（和<code>CS</code>）的值，实现程序执行顺序的改变。</p><h3 id="无条件转移指令JMP"><a href="#无条件转移指令JMP" class="headerlink" title="无条件转移指令JMP"></a>无条件转移指令JMP</h3><p>JMP指令分为直接转移和间接转移两种：</p><ul><li><p><strong>直接转移</strong>：</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E7%9B%B4%E6%8E%A5%E8%BD%AC%E7%A7%BB.png" alt></p></li><li><p><strong>间接转移</strong>：</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E9%97%B4%E6%8E%A5%E8%BD%AC%E7%A7%BB.png" alt></p></li></ul><h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>条件转移指令根据标志寄存器中各标志位的状态来决定程序是否进行转移。条件转移指令的<strong>目的地址必须在现行的<code>CS</code>内</strong>，并且<strong>以当前<code>IP</code>的内容为基准</strong>，其<strong>位移必须在 <code>+127</code> ~ <code>-128</code> 的范围内</strong>：</p><ul><li>一个8位位移量，表示本条件转移指令后的那条指令的偏移地址到目标指令的偏移地址的地址位移；</li><li>8位位移量是相对于当前<code>IP</code>的，且距当前<code>IP</code>地址 <code>-128</code> ~ <code>+127</code> 个单元的范围之内，属于段内短距离转移。</li></ul><p><strong>条件转移指令不影响标志位，但要利用标志位</strong>。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%A0%87%E5%BF%97%E4%BD%8D%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E4%B8%8D%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%AF%94%E8%BE%83%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%AF%94%E8%BE%83%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.png" alt></p><h3 id="子程序调用和返回指令"><a href="#子程序调用和返回指令" class="headerlink" title="子程序调用和返回指令"></a>子程序调用和返回指令</h3><p>当主程序需要执行子程序时，使用CALL调用指令转移到该子程序的起始处执行；当子程序执行完后，使用RET返回指令回到主程序继续执行。</p><h4 id="调用指令CALL"><a href="#调用指令CALL" class="headerlink" title="调用指令CALL"></a>调用指令CALL</h4><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/CALL.png" alt></p><h4 id="返回指令RET"><a href="#返回指令RET" class="headerlink" title="返回指令RET"></a>返回指令RET</h4><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/RET.png" alt></p><h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p>该组指令主要通过判断<code>CX</code>或标志位<code>ZF</code>来确定是否循环。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4.png" alt></p><h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>Intel 8086可以管理256个中断，各中断各用一个向量编号来区别；中断向量表（ <code>0:0</code> ~ <code>0:3FFH</code> ）存放中断程序的入口地址。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/INT.png" alt></p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%96%AD.png" alt></p><h2 id="标志操作和处理器控制指令"><a href="#标志操作和处理器控制指令" class="headerlink" title="标志操作和处理器控制指令"></a>标志操作和处理器控制指令</h2><h3 id="标志操作指令"><a href="#标志操作指令" class="headerlink" title="标志操作指令"></a>标志操作指令</h3><p>标志操作指令用来控制标志位（主要为<code>CF</code>、<code>DF</code>和<code>IF</code>三个）。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E6%A0%87%E5%BF%97%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4.png" alt></p><h3 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h3><p>处理器控制指令用来控制处理器的工作状态，不影响标志位。</p><p><img src="/2021/04/12/Intel%208086%E3%81%AE%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>斐讯N1折腾记录（二）——kiftd的部署</title>
      <link href="/2021/03/30/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94kiftd%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/03/30/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94kiftd%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>今天在逛GitHub的时候发现了<code>kiftd</code>这个项目，兴趣上头，就部署到之前被我刷入了Armbian的斐讯N1上，顺便写下本文<del>来水一水(⁰▿⁰)</del>。</p><a id="more"></a><h2 id="kiftd简介"><a href="#kiftd简介" class="headerlink" title="kiftd简介"></a>kiftd简介</h2><p>kiftd是一套开源的网络文件存储系统，可运行于Windows、Linux和Mac OS X；无传输限制，所有文件均能随意上传和下载；支持音、视频文件的在线播放，图片的在线预览，以及Word、PPT、TXT、PDF文档的在线预览；完全开源，无内置代码的隐患。</p><p><del>反正只是满足一下自己的折腾欲望(´∀`)。</del></p><h2 id="搭建kiftd"><a href="#搭建kiftd" class="headerlink" title="搭建kiftd"></a>搭建kiftd</h2><h3 id="安装Java运行环境"><a href="#安装Java运行环境" class="headerlink" title="安装Java运行环境"></a>安装Java运行环境</h3><p>kiftd基于Java开发，需要运行在Java环境下，根据说明文档的描述，Java 7/JDK 1.7及以下的版本会导致kiftd无法启动，必须是Java 8/JDK 1.8或以上的版本才能使kiftd运行（不过经过我的实际折腾，<a href="https://github.com/KOHGYLW/kiftd/releases/tag/v1.0.35-release" target="_blank" rel="noopener">kiftd v1.0.35-RELEASE 发行版</a>不能运行于最新的Java SE 16Σ( ° △ °|||)，但能运行于Java SE 8即JDK 1.8，原因不明 (☉_☉)）。</p><h4 id="安装JDK-1-8"><a href="#安装JDK-1-8" class="headerlink" title="安装JDK 1.8"></a>安装JDK 1.8</h4><p>直接使用一条命令就可以完成下载及安装。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">apt install openjdk<span class="number">-8</span>-jre</span><br></pre></td></tr></table></figure><p>完成后可使用<code>java -version</code>检查，若安装成功，则输出如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">openjdk version <span class="string">"1.8.0_282"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_282-8u282-b08-0ubuntu1~18.04-b08)</span><br><span class="line">OpenJDK 64-Bit<span class="built_in"> Server </span>VM (build 25.282-b08, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="下载-amp-解压kiftd程序主目录"><a href="#下载-amp-解压kiftd程序主目录" class="headerlink" title="下载 &amp; 解压kiftd程序主目录"></a>下载 &amp; 解压kiftd程序主目录</h3><p>在当前用户目录（即<code>/root</code>）下新建一个目录命名为kiftd（目录名随意，不要包含中文），然后下载kiftd的程序主目录压缩包；</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/KOHGYLW/</span>kiftd<span class="regexp">/archive/</span>refs<span class="regexp">/heads/m</span>aster.zip</span><br></pre></td></tr></table></figure><p>然后对压缩包进行解压。</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">unzip <span class="literal">master</span>.zip</span><br></pre></td></tr></table></figure><h2 id="运行kiftd"><a href="#运行kiftd" class="headerlink" title="运行kiftd"></a>运行kiftd</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>如果是在x86的计算机上，搭建完成后就可以直接使用了，但kiftd内置的FFmpeg视频解码引擎并不适用于ARM指令集，所以在斐讯N1上FFmpeg无法运行，且执行kiftd的运行命令时会报错而无法运行，需要先将FFmpeg禁用（禁用FFmpeg后，将只支持在线播放文件格式为MP4的视频）；在kiftd服务处于关闭状态时，打开（kiftd程序主目录下）子目录<code>conf</code>下的文件<code>server.properties</code>，在空白处添加如下设置：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">video.ffmpeg</span>=disable</span><br></pre></td></tr></table></figure><p>可以替换FFmpeg视频解码引擎而不禁用，但由于我没在线预览视频的需求，所以就用最简单粗暴的方式了(つд⊂)。</p><p>另外还可在此文件中修改<code>port</code>一项来自定义访问kiftd的端口号（默认端口号为8080）。</p><h3 id="启动kiftd"><a href="#启动kiftd" class="headerlink" title="启动kiftd"></a>启动kiftd</h3><p>修改完成，保存并关闭文件<code>server.properties</code>后，即可在kiftd程序主目录下运行kiftd；</p><p>在终端打开kiftd的控制面板</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">-jar</span> <span class="selector-tag">kiftd-1</span><span class="selector-class">.0</span><span class="selector-class">.35-RELEASE</span><span class="selector-class">.jar</span> <span class="selector-tag">-console</span></span><br></pre></td></tr></table></figure><p>启动kiftd服务</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">-<span class="literal">start</span></span><br></pre></td></tr></table></figure><p>接着就可以访问kiftd服务<code>http://&lt;斐讯N1的IP地址&gt;:&lt;访问kiftd的端口号&gt;/</code>；默认账户：<code>admin</code>，默认密码：<code>000000</code>。</p><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>使用以下命令即可一直以后台模式运行kiftd并列出进程ID，即使终端关闭或SSH断开连接；</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">nohup <span class="keyword">java </span>-<span class="keyword">jar </span>kiftd<span class="number">-1</span>.<span class="number">0</span>.<span class="number">35</span>-RELEASE.<span class="keyword">jar </span>-start &amp; echo $!</span><br></pre></td></tr></table></figure><p>可以使用kill命令来关闭kiftd。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">kill</span> &lt;进程<span class="keyword">ID</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="详细使用说明"><a href="#详细使用说明" class="headerlink" title="详细使用说明"></a>详细使用说明</h4><p><a href="https://github.com/KOHGYLW/kiftd/blob/master/kiftd%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3.pdf" target="_blank" rel="noopener">kiftd说明文档.pdf</a></p><hr><p><strong>参考资料</strong></p><p><a href="https://github.com/KOHGYLW/kiftd" target="_blank" rel="noopener">GitHub上的项目地址</a></p><p><a href="https://github.com/KOHGYLW/kiftd/blob/master/kiftd%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3.pdf" target="_blank" rel="noopener">kiftd说明文档.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 私有云存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intel 8086の寻址方式</title>
      <link href="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>根据指令内容来确定操作数的过程，被称为寻址。根据寻址计算所得到的操作数地址被称为操作数的有效地址（EA），即段内偏移地址，段内偏移地址还需要与相应的段地址组合形成20位的物理地址（PA）。</p><p>Intel 8086的寻址方式由立即寻址、寄存器寻址、直接寻址、寄存器间接寻址、变址寻址、基址加变址寻址。</p><a id="more"></a><h2 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h2><p><strong>立即寻址主要用来给寄存器或存储单元赋初值</strong>，操作数直接放在指令中，与操作码一起放在代码段内；立即数既可以是8位，也可以是16位，若为16位，则低字节位于低地址处，高字节位于高地址处；<strong>立即数只能是源操作数，且只能为整数</strong>。</p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%800.png" alt></p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%801.png" alt></p><h2 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h2><p><strong>寄存器寻址的操作数位于寄存器中，</strong>寄存器名（<strong>AX、BX、CX、DX、DI、SI、SP、BP</strong>）由指令给出，<strong>也可用于寄存器和内存单元之间传送数据</strong>。</p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt></p><h2 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h2><p>直接寻址是指操作数的有效地址（只包含16位偏移地址）由指令直接给出，与操作码一起存放在代码段。<strong>操作数的有效地址在指令中必须用<code>[]</code>括起来</strong>。直接寻址以<strong>数据段</strong>的地址为基础，Intel 8086允许段超越，即允许操作数位于以<strong>代码段、堆栈段或附加数据段</strong>为基准的内存区域中，此时需要<strong>在指令中指明段超越（即操作数位于哪个内存区域内）</strong>。</p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt></p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%800.png" alt></p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%801.png" alt></p><h2 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h2><p>如果<strong>寄存器中的内容为操作数的内存地址</strong>，则对应为寄存器间接寻址，<strong>寄存器在指令中必须用<code>[]</code>括起来</strong>。在Intel 8086中，操作数的16位偏移地址可以存放于寄存器<strong>SI、DI、BP、BX</strong>，此时分为两种情况：</p><ul><li>以<strong>SI、DI、BX</strong>间接寻址时，默认操作数位于数据段<strong>DS</strong>中；</li><li>以<strong>BP</strong>间接寻址时，默认操作数位于堆栈段<strong>SS</strong>中。</li></ul><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt></p><h2 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h2><p>变址寻址即在寄存器间接寻址的基础上再加一个16位的偏移量。</p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt></p><h2 id="基址加变址寻址"><a href="#基址加变址寻址" class="headerlink" title="基址加变址寻址"></a>基址加变址寻址</h2><p>基址加变址寻址时，把一个基址寄存器（<strong>BX或BP</strong>）的内容加上一个变址寄存器（<strong>SI或DI</strong>）的内容（若指令中还指定了8位或16位<strong>偏移量</strong>，则还需再加上）后作为操作数的16位偏移地址。</p><p>当使用基址寄存器<strong>BX</strong>时，操作数默认位于数据段<strong>DS</strong>中；当使用基址指针寄存器<strong>BP</strong>时，操作数默认位于堆栈段<strong>SS</strong>中；基址加变址寻址允许段超越，但需要在指令中指明。</p><p><img src="/2021/03/27/Intel%208086%E3%81%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程的上下文切换</title>
      <link href="/2021/03/26/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
      <url>/2021/03/26/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>各进程之间是共享CPU资源的，CPU需要在不同的时候执行不同的进程，一个正在执行的进程切换到另一个进程执行的过程被称为进程的上下文切换。</p><a id="more"></a><h2 id="CPU的上下文切换"><a href="#CPU的上下文切换" class="headerlink" title="CPU的上下文切换"></a>CPU的上下文切换</h2><p>在每个任务（进程、线程、中断）被CPU执行前，CPU需要知道任务从哪里加载，又从哪个阶段执行；所以操作系统会设置CPU的寄存器（例如写入执行数据的地址）和程序计数器（写入即将执行的指令的的地址），寄存器值和程序计数器的值为CPU必须依赖的环境，即CPU的上下文。</p><p>CPU上下文切换即为操作系统将当前任务的寄存器值和程序计数器的值保存起来，然后将CPU执行新任务所需的寄存器值和程序计数器的值写入，由CPU来执行新任务；当CPU需要继续执行此前的任务时，操作系统就将此前已保存的寄存器值和程序计数器的值写入，CPU则会继续执行此前的任务。</p><p>根据执行的任务的不同，CPU的上下文切换可分为进程的上下文切换、线程的上下文切换、中断的上下文切换。</p><p>当需要切换进程上下文时，操作系统会将当前的CPU上下文保存到当前进程的PCB（进程控制块），然后把另一个进程的PCB中的CPU上下文写入，CPU则会继续执行另一个进程。</p><h2 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h2><p>为保证所有任务都能得到相对公平的调度（一个CPU逻辑核心同一时刻内只能执行一个任务），操作系统将CPU时间划分为多个片段，当一个任务完成一个时间片段的执行后，CPU将被切换到执行另一个任务，每个任务快速轮流执行（因为时间片段足够短且CPU逻辑核心执行效率足够高，使人感觉多个任务是在同时执行）。</p><ul><li>当某个进程的时间片段耗尽，该进程被操作系统挂起，CPU被切换到执行其他进程；</li><li>当前进程所需资源过多（例如内存不足）时，操作系统会将当前进程挂起，CPU被切换到执行资源消耗较少的进程，直至资源充足且完成一个时间片段的执行，再切换回来继续执行；</li><li>当进程申请主动挂起且被操作系统允许时，操作系统也会重新调度资源，切换上下文；</li><li>低优先级的进程被高优先级的进程打断；</li><li>发生硬件中断。</li></ul><hr><p><strong>参考资料：</strong></p><p><a href="https://alanwin.top/2021/03/21/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">进程与线程</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intel 8086の存储器组织</title>
      <link href="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/"/>
      <url>/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下Intel 8086存储器组织的相关内容( ～’ω’)～。</p><a id="more"></a><h2 id="Intel-8086の存储空间"><a href="#Intel-8086の存储空间" class="headerlink" title="Intel 8086の存储空间"></a>Intel 8086の存储空间</h2><p>Intel 8086具有20条地址总线，可访问的存储大小为1MB，与之对应的物理内存地址为00000H~FFFFFH；存储器以字节为单位来对存储单元进行编址，一个存储单元写入一个字节的内容。</p><h3 id="字节-amp-字"><a href="#字节-amp-字" class="headerlink" title="字节 &amp; 字"></a>字节 &amp; 字</h3><p>Intel 8086的字长为16位，一个字由两个字节组成，占用相继的两个存储单元，大部分数据以字节为单位来表示；字节被顺序写入，低位字节被写入低地址，高位字节被写入高地址，<strong>同一地址既可以是字节单元地址，也可以是字单元地址，视使用情况而定</strong>；</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png" alt></p><p>如上图所示，0004H既是字单元1234H的地址，也是字节单元34H的地址。</p><h4 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h4><h5 id="⑴"><a href="#⑴" class="headerlink" title="⑴"></a>⑴</h5><p>Intel 8086也可使用双字、规则字和非规则字来表示数据：</p><ul><li><p>双字：双字型数据为32位的二进制数，需要占用连续的4个存储单元；</p></li><li><p>规则字：低位字节被写入偶地址的存储单元，高位字节被写入奇地址的存储单元，在一个总线周期内完成读写；</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E8%A7%84%E5%88%99%E5%AD%97.png" alt></p></li><li><p>非规则字：写入规则与规则字相反，<strong>对非规则字的读写需要两个总线周期</strong>：</p><ul><li><p>在第一个总线周期内，非规则字的低8位通过数据总线的高8位进行读写，数据总线的低8位处于空闲状态；</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9F.png" alt></p></li><li><p>在第二个总线周期内，非规则字的高8位通过数据总线的低8位进行读写，数据总线的高8位处于空闲状态。</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9F.png" alt></p></li></ul></li></ul><h5 id="⑵"><a href="#⑵" class="headerlink" title="⑵"></a>⑵</h5><p>在内存中，一个字节的数据既可以被写入奇地址的存储单元，也可以被写入偶地址的存储单元；读写一个字节时，只需要访问单个存储单元，相应的8位数据在数据总线上有效，而另一个字节的数据被忽略。</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E8%AF%BB%E5%86%99%E5%81%B6%E5%9C%B0%E5%9D%80%E5%AD%97%E8%8A%82.png" alt></p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E8%AF%BB%E5%86%99%E5%A5%87%E5%9C%B0%E5%9D%80%E5%AD%97%E8%8A%82.png" alt></p><h5 id="⑶"><a href="#⑶" class="headerlink" title="⑶"></a>⑶</h5><p>两个引脚的信号组合对存储器的读写控制：</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E5%AD%98%E5%82%A8%E5%99%A8%E8%AF%BB%E5%86%99.png" alt></p><h2 id="Intel-8086の存储器分段结构"><a href="#Intel-8086の存储器分段结构" class="headerlink" title="Intel 8086の存储器分段结构"></a>Intel 8086の存储器分段结构</h2><p>Intel 8086中用于写入地址的寄存器均为16位，最大只能寻址64KB的存储空间，若要访问1MB的存储空间，则需要对存储空间进行分段管理。</p><p>操作系统将存储器分为若干个逻辑段，<strong>每个逻辑段的存储容量小于或等于64KB，各逻辑段之间可以紧密相连，也可互相重叠</strong>。</p><p>用户编写的程序（指令和数据）被写入相应的逻辑段，这些逻辑段的段地址则被写入Intel 8086相应的段寄存器，而这些指令和数据在逻辑段中的偏移地址则被写入Intel 8086相应的寄存器中，由段地址和偏移地址即可确定指令和数据在物理内存中的地址：将段地址左移四位，再加上偏移地址，即可得到20位的物理地址（物理地址=段地址×16+偏移地址）。</p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E5%9C%B0%E5%9D%80.png" alt></p><p><img src="/2021/03/26/Intel%208086%E3%81%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt></p><p><strong>在物理内存中，每一个存储单元均有唯一一个物理地址，但其对应的段地址和偏移地址不唯一</strong>。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Intel-8086のI-O组织"><a href="#Intel-8086のI-O组织" class="headerlink" title="Intel 8086のI/O组织"></a>Intel 8086のI/O组织</h3><p>Intel 8086采用独立编址方式（即I/O端口地址与物理内存地址分开独立编址，I/O端口地址不占用物理内存的地址范围，需要有专门的I/O指令和控制逻辑），通过I/O芯片与外部设备进行通信，每个I/O芯片设置有一定数目的端口，每个端口被分配一个地址，一个端口通常对应芯片内部的一个或一组寄存器。</p><p>Intel 8086通过地址总线的低16位对8位I/O端口进行寻址，可访问的8位I/O端口有65536（64K）个，两个地址相邻的8位端口可以组成一个16位端口。一个8位的I/O设备既可以连接到数据总线的高8位，也可以连接到数据总线的低8位。</p><p>当一个I/O设备接在数据总线的低8位时，该I/O设备的所有端口地址都将是偶地址；当一个I/O设备接在数据总线的高8位时，该I/O设备的所有端口地址都将是奇地址。</p><p>Intel 8086对偶地址的I/O设备进行16位数据的读写时，可在一个总线周期内完成；对奇地址的I/O设备进行16位数据的读写则需要两个总线周期来完成，与对存储器的读写操作类似。</p><hr><p><strong>参考资料：</strong></p><p><a href="https://blog.csdn.net/rdgfdd/article/details/79797007" target="_blank" rel="noopener">8086/8088存储器和I/O组织</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intel 8086的寄存器结构</title>
      <link href="/2021/03/15/Intel%208086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2021/03/15/Intel%208086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>简单整理一下Intel 8086的各个寄存器的用途，为以后玩汇编语言奠定一个基础(&gt;ω&lt;)。</p><a id="more"></a><h2 id="寄存器总览"><a href="#寄存器总览" class="headerlink" title="寄存器总览"></a>寄存器总览</h2><p><img src="/2021/03/15/Intel%208086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p><p>Intel 8086共有14个寄存器，且均为16位，按照一定的方式又被分为通用寄存器组（其下又可被分为数据寄存器组和地址指针、变址寄存器组）、控制寄存器组和段寄存器组。</p><h2 id="通用寄存器组"><a href="#通用寄存器组" class="headerlink" title="通用寄存器组"></a>通用寄存器组</h2><p>通用寄存器组包括累加寄存器<code>AX</code>、基址寄存器<code>BX</code>、计数寄存器<code>CX</code>、数据寄存器<code>DX</code>、堆栈指针寄存器<code>SP</code>、基址指针寄存器<code>BP</code>、源变址寄存器<code>SI</code>、目的变址寄存器<code>DI</code>，这些寄存器除了具有相应的专职功能外，还可用于数据的暂存。</p><h3 id="数据寄存器组"><a href="#数据寄存器组" class="headerlink" title="数据寄存器组"></a>数据寄存器组</h3><p>数据寄存器组由累加寄存器<code>AX</code>、基址寄存器<code>BX</code>、计数寄存器<code>CX</code>、数据寄存器<code>DX</code>组成，为了兼容基于Intel 8086之前的8位CPU开发的程序，在Intel 8086中，每一个16位的数据寄存器均可拆分成2个独立的8位寄存器使用；即：</p><ul><li><code>AX</code> → <code>AH</code>、<code>AL</code></li><li><code>BX</code> → <code>BH</code>、<code>BL</code></li><li><code>CX</code> → <code>CH</code>、<code>CL</code></li><li><code>DX</code> → <code>DH</code>、<code>DL</code></li></ul><p>除此之外，其他16位寄存器均不可拆分为2个独立的8位寄存器。</p><h4 id="累加寄存器AX-amp-数据寄存器DX"><a href="#累加寄存器AX-amp-数据寄存器DX" class="headerlink" title="累加寄存器AX &amp; 数据寄存器DX"></a>累加寄存器AX &amp; 数据寄存器DX</h4><p><code>AX</code>是算术运算的主要寄存器，所有I/O指令都使用<code>AX</code>与外部设备交换数据。</p><p>对于某些I/O操作，其端口地址可写入<code>DX</code>。</p><p>在使用DIV指令（Intel 8086的除法指令）时，除数可以是8位或16位，且除数可以写入其他寄存器或内存；当除数是8位时，被除数一定是16位且默认被写入<code>AX</code>；当除数是16位时，被除数一定是32位，被除数的高16位被写入<code>DX</code>，低16位则被写入<code>AX</code>。</p><p>当DIV指令执行完成后，如果除数是8位，此次除法操作的商被写入<code>AL</code>，余数则被写入<code>AH</code>；如果除数是16位，此次除法操作的商被写入<code>AX</code>，余数则被写入<code>DX</code>。</p><p>在使用MUL指令（Intel 8086的乘法指令）时，两个乘数要么都是8位，要么都是16位；当两个乘数都是8位时，其中一个乘数默认被写入<code>AL</code>，另一个乘数则被写入其他寄存器或内存；当两个乘数都是16位时，其中一个乘数默认被写入<code>AX</code>，另一个乘数则被写入其他寄存器或内存。</p><p>当MUL指令执行完成后，如果是8位乘法运算，则运算结果为16位且默认被写入<code>AX</code>；如果是16位乘法运算，则运算结果为32位，其中高16位默认被写入<code>DX</code>，低16位默认被写入<code>AX</code>。</p><h4 id="基址寄存器BX"><a href="#基址寄存器BX" class="headerlink" title="基址寄存器BX"></a>基址寄存器BX</h4><p><code>BX</code>被写入基址，用于物理内存的寻址。</p><h4 id="计数寄存器CX"><a href="#计数寄存器CX" class="headerlink" title="计数寄存器CX"></a>计数寄存器CX</h4><p><code>CX</code>在循环LOOP指令和串处理指令中用作计数器。</p><p>在Intel 8086每次执行LOOP指令时，</p><ul><li>令<code>CX</code>的值自动减1</li><li>判断<code>CX</code>的值，若<code>CX</code>的值为0，则跳出循环；若<code>CX</code>的值不为0，则继续执行循环中的指令</li></ul><h3 id="地址指针、变址寄存器组"><a href="#地址指针、变址寄存器组" class="headerlink" title="地址指针、变址寄存器组"></a>地址指针、变址寄存器组</h3><p>地址指针、变址寄存器组包括堆栈指针寄存器<code>SP</code>、基址指针寄存器<code>BP</code>、源变址寄存器<code>SI</code>和目的变址寄存器<code>DI</code>，经常被用于在段内寻址时提供偏移地址。</p><h4 id="堆栈指针寄存器SP"><a href="#堆栈指针寄存器SP" class="headerlink" title="堆栈指针寄存器SP"></a>堆栈指针寄存器SP</h4><p><strong><code>SP</code>用来表示栈顶的偏移地址，必须与<code>SS</code>联合使用。</strong></p><h4 id="基址指针寄存器BP"><a href="#基址指针寄存器BP" class="headerlink" title="基址指针寄存器BP"></a>基址指针寄存器BP</h4><p><code>BP</code>用于表示偏移地址，可与<code>SS</code>联合使用来确定堆栈段中的具体地址。</p><p>若指令中没有明确给出段寄存器，则<strong><code>BP</code>默认与<code>SS</code>联合使用</strong>；若指令中明确给出段寄存器，则<code>BP</code>与该段寄存器联合使用。</p><h4 id="源变址寄存器SI-amp-目的变址寄存器DI"><a href="#源变址寄存器SI-amp-目的变址寄存器DI" class="headerlink" title="源变址寄存器SI &amp; 目的变址寄存器DI"></a>源变址寄存器SI &amp; 目的变址寄存器DI</h4><p>一般与<code>DS</code>联用，用来确定数据段中的具体地址。</p><p>在串操作中，<code>SI</code>与<code>DS</code>联用来寻址源操作数，<code>DI</code>与<code>ES</code>联用来寻址目的操作数，<code>SI</code>、<code>DI</code>具有自动增量和自动减量的功能。</p><h2 id="段寄存器组"><a href="#段寄存器组" class="headerlink" title="段寄存器组"></a>段寄存器组</h2><p>段寄存器组包括代码（指令）段寄存器<code>CS</code>、数据段寄存器<code>DS</code>、堆栈段寄存器<code>SS</code>和附加段寄存器<code>ES</code>。</p><h3 id="代码段寄存器CS"><a href="#代码段寄存器CS" class="headerlink" title="代码段寄存器CS"></a>代码段寄存器CS</h3><p><code>CS</code>与<code>IP</code>联用表示了Intel 8086当前将要读取的指令的地址；当操作系统运行一个可执行文件时，操作系统会将该可执行文件的起始地址分别写入<code>CS</code>和<code>IP</code>两个寄存器，随后CPU会从这个起始地址开始读取指令，当一条指令读取完后，自动变更<code>IP</code>，指向下一条要读取的指令。<strong>在任何时候，<code>CS</code>和<code>IP</code>指向的地址即为Intel 8086将要执行的指令的地址。</strong></p><h3 id="堆栈段寄存器SS"><a href="#堆栈段寄存器SS" class="headerlink" title="堆栈段寄存器SS"></a>堆栈段寄存器SS</h3><p>与<code>SP</code>联用，指向堆栈的栈顶。</p><h3 id="数据段寄存器DS-amp-附加段寄存器ES"><a href="#数据段寄存器DS-amp-附加段寄存器ES" class="headerlink" title="数据段寄存器DS &amp; 附加段寄存器ES"></a>数据段寄存器DS &amp; 附加段寄存器ES</h3><p><code>DS</code>被写入待访问的数据段的段地址。</p><p><code>ES</code>，emmmmm，备胎角色(／‵Д′)／~ ╧╧，当段寄存器不够用时，它再上位。</p><h2 id="控制寄存器组"><a href="#控制寄存器组" class="headerlink" title="控制寄存器组"></a>控制寄存器组</h2><p>控制寄存器组包括指令指针寄存器<code>IP</code>和标志寄存器<code>FLAG</code>。</p><h4 id="指令指针寄存器IP"><a href="#指令指针寄存器IP" class="headerlink" title="指令指针寄存器IP"></a>指令指针寄存器IP</h4><ul><li><code>IP</code>用于被写入代码段的偏移地址；</li><li>程序运行过程中<code>IP</code>始终指向下一次待读取的指令的偏移地址；</li><li><code>IP</code>与<code>CS</code>联用才能生成物理内存地址。</li></ul><p><strong>用户程序不能对<code>IP</code>进行修改，只能由BIU自动修改。</strong></p><h4 id="标志寄存器FLAG"><a href="#标志寄存器FLAG" class="headerlink" title="标志寄存器FLAG"></a>标志寄存器FLAG</h4><p><code>FLAG</code>用于被写入程序的状态字（例如进位、中断等），被写入<code>FLAG</code>的信息是按位起作用的，即<code>FLAG</code>中的每一个位都表示程序不同的状态。</p><h5 id="标志寄存器中各位如下："><a href="#标志寄存器中各位如下：" class="headerlink" title="标志寄存器中各位如下："></a>标志寄存器中各位如下：</h5><table><thead><tr><th align="center">15</th><th align="center">14</th><th align="center">13</th><th align="center">12</th><th align="center">11</th><th align="center">10</th><th align="center">9</th><th align="center">8</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">OF</td><td align="center">DF</td><td align="center">IF</td><td align="center">TF</td><td align="center">SF</td><td align="center">ZF</td><td align="center"></td><td align="center">AF</td><td align="center"></td><td align="center">PF</td><td align="center"></td><td align="center">CF</td></tr></tbody></table><ul><li><code>CF</code>（进位标志）：若运算过程中产生进位或错位，<code>CF</code>置1，否则置0；</li><li><code>PF</code>（奇偶标志）：若相关指令执行后其结果的低8位中1的个数为偶数，<code>PF</code>置1，否则置0；</li><li><code>AF</code>（辅助进位标志）：若字节操作中低半个字节向高半个字节借位或进位，<code>AF</code>置1，否则置0；</li><li><code>ZF</code>（零标志）：若相关指令执行后其结果为0，<code>ZF</code>置1，否则置0；</li><li><code>SF</code>（符号标志）：若相关指令执行后其结果为负数，<code>SF</code>置1，否则置0；</li><li><code>TF</code>（追踪标志）：常用于程序调试，若<code>TF</code>置1，每执行一条指令后，自动产生一次内部中断，使Intel 8086处于单步执行指令工作方式；</li><li><code>IF</code>（中断允许标志）：若<code>IF</code>置1，则允许外部可屏蔽中断，Intel 8086能响应外部的可屏蔽中断请求；</li><li><code>DF</code>（方向标志）：在串处理指令中，若令每次操作后<code>SI</code>和<code>DI</code>均自增，<code>DF</code>置0；</li><li><code>OF</code>（溢出标志）：若相关指令执行有符号运算后其结果发生溢出，<code>OF</code>置1，否则置0。</li></ul><hr><p>若有错误，请各位大佬多多指教，非常感谢(〃´∀｀)。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/weixin_40913261/article/details/90762210" target="_blank" rel="noopener">8086CPU各寄存器及其简介</a></p><p><a href="https://blog.csdn.net/fuhanghang/article/details/111571435" target="_blank" rel="noopener">8086CPU详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>51单片机中断优先级</title>
      <link href="/2021/03/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2021/03/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>由于自己对51单片机的中断优先级相关觉得比较混乱，有必要做个简单整理。</p><a id="more"></a><h2 id="查询优先级-amp-执行优先级"><a href="#查询优先级-amp-执行优先级" class="headerlink" title="查询优先级&amp;执行优先级"></a>查询优先级&amp;执行优先级</h2><p>51单片机由两种优先级——查询优先级和执行优先级。</p><h3 id="查询优先级"><a href="#查询优先级" class="headerlink" title="查询优先级"></a>查询优先级</h3><p><img src="/2021/03/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7/%E4%B8%AD%E6%96%AD%E6%9F%A5%E8%AF%A2%E6%AC%A1%E5%BA%8F.png" alt></p><p>查询优先级是指当51单片机的多个中断源同时引起中断时，CPU逐个查询中断标志位的次序，高优先级的中断标志位将被优先查询到，<strong>但并不代表查询优先级高的中断一定可以打断正在执行中断处理的低优先级中断</strong>。查询优先级由51单片机本身的电路来决定，不能设置和更改。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><ul><li>当定时器中断0和外部中断1同时引起时（没有设置中断优先级控制寄存器），则会首先执行定时器中断0的请求；</li><li>当定时器中断0和外部中断1同时引起且外部中断1正在执行请求时（没有设置中断优先级控制寄存器），外部中断1不能被任何中断（包括定时器中断0）所打断。</li></ul><h3 id="执行优先级"><a href="#执行优先级" class="headerlink" title="执行优先级"></a>执行优先级</h3><p>执行优先级由中断优先级控制寄存器<code>IP</code>来控制。</p><p><img src="/2021/03/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7/%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p><ul><li>高两位置0</li><li><code>PT2</code>：定时器中断2优先级控制位</li><li><code>PS</code>：串口中断优先级控制位</li><li><code>PT1</code>：定时器中断1优先级控制位</li><li><code>PX1</code>：外部中断1优先级控制位</li><li><code>PT0</code>：定时器中断0优先级控制位</li><li><code>PX0</code>：外部中断0优先级控制位</li></ul><p>如果设置了<code>IP</code>，执行优先级则只有两级——高优先级（<code>IP</code>中的相应位置1）和低优先级（<code>IP</code>中的相应位置0）。若没有设置<code>IP</code>，则当多个中断同时产生时，单片机只会根据查询优先级来进行优先选择。</p><ul><li>当多个中断源同时引起中断时，优先响应执行优先级高的中断；</li><li>同一执行优先级的中断则根据查询优先级依次响应；</li><li>一个正在执行的低优先级中断能被高优先级中断所打断，反之则不能；</li><li>一个正在执行的中断不能被新的同优先级中断所打断。</li></ul><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>当<code>IP</code>中的<code>PX1</code>位和<code>PT0</code>位置1，其余位置0时，中断的响应次序依次为：</p><p>定时器中断0 → 外部中断1 → 外部中断0 → 定时器中断1 → 串口中断 → 定时器中断2</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>旧型号的51单片机（80C51系列）只有5个中断源，2个（执行）优先级；现在很多新型号的51单片机有更多的中断源和（执行）优先级。</p><hr><p><strong>参考资料：</strong></p><p><a href="https://www.cnblogs.com/shirishiqi/p/5542116.html" target="_blank" rel="noopener">51单片机的中断优先级及中断嵌套</a></p><p><a href="http://www.stcmcudata.com/datasheet/stc/STC-AD-PDF/STC89C51RC-RD.pdf" target="_blank" rel="noopener">STC89C52RC官方技术文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机——UART通信简单记录</title>
      <link href="/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>简单整理一下之前用51单片机玩UART通信的笔记(๑¯∀¯๑)。</p><a id="more"></a><p>单片机：STC89C52RC</p><h2 id="UART相关"><a href="#UART相关" class="headerlink" title="UART相关"></a>UART相关</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>UART（Universal Asynchronous Receiver/Transmitter的缩写，中文名称：通用异步收发传输器）包括了RS232、RS449、RS423、RS422和RS485等接口标准规范和总线标准规范（<strong>UART不是通信协议，而是MCU中相对独立的电路模块</strong>），它将需要传输的数据在串行通信与并行通信之间加以转换：发送端的UART将来自控制设备（例如CPU）的并行数据转换为串行数据，以串行方式将其发送到接收端的UART，随后接收端的UART将串行数据转换为并行数据传递给接收端的控制设备。</p><h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p>UART将需要传输的数据封装为数据包，每个数据包包含1个起始位，5~9个数据位（取决于UART的具体设置），一个可选的校验位，1个到2个停止位（1位、1.5位、2位）。</p><h4 id="起始位"><a href="#起始位" class="headerlink" title="起始位"></a>起始位</h4><p>发送端与接收端之间的UART传输总线通常在不传输数据时保持在高电平；在开始传输数据前，发送端的UART在一个时钟周期内将传输总线从高电平拉低到低电平；当接收端的UART检测到传输总线由高电平转换到低电平时，将以波特率的频率读取数据位中的每一位数据。</p><h4 id="数据位"><a href="#数据位" class="headerlink" title="数据位"></a>数据位</h4><p>数据位包含接收端的控制设备实际需要的数据，数据位的长度可以是5、6、7、8，9位（<strong>如果使用校验位，则可以是5位，最多8位；如果不使用校验位，数据帧的长度可以是9位（此时可以把校验位当作数据位来使用）</strong>），一般为8位，因为一个ASCII码的长度为8位。</p><p>数据位从低有效位到高有效位依次发送。</p><h4 id="校验位"><a href="#校验位" class="headerlink" title="校验位"></a>校验位</h4><p>校验位可以是奇校验、偶校验、1校验、0校验，也可以没有校验位。</p><ul><li>奇校验：校验位为1，数据位与校验位的高逻辑位的位数之和为奇数；</li><li>偶校验：校验位为0，数据位与校验位的高逻辑位的位数之和位偶数；</li><li>1校验：强行将校验位设置为高逻辑位，仅通过检查校验位的值是否被修改为依据来判断是否有噪声干扰了通信或者数据的发送和接收是否同步；</li><li>0校验：强行将校验位设置为低逻辑位，效果同上。</li></ul><h4 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h4><p>发送端的UART将传输总线拉高到高电平，持续1到2个传输位的时间，以此来通知接收端的UART停止接收；同时给发送端和接收端提供了同步时钟的机会，停止位的位数越多，时钟同步的容错性越好，但数据传输越慢。</p><h3 id="优、缺点"><a href="#优、缺点" class="headerlink" title="优、缺点"></a>优、缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>占用的引脚少，除电源部分外，只需要两条数据传输线即可进行通信；</li><li>无需时钟信号；</li><li>有校验位，有利于检查数据是否完整无修改；</li><li>只需要在发送端和接收端设置好数据包结构，即可稳定通信。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>数据帧最大只支持9位数据；</li><li>不支持多主机或多从机的主从系统。</li></ul><h2 id="51单片机UART的使用"><a href="#51单片机UART的使用" class="headerlink" title="51单片机UART的使用"></a>51单片机UART的使用</h2><p>与51单片机UART通信相关的特殊功能寄存器有串行控制寄存器<code>SCON</code>、电源控制寄存器<code>PCON</code>、定时器模式寄存器<code>TMOD</code>。</p><h3 id="串行控制寄存器SCON"><a href="#串行控制寄存器SCON" class="headerlink" title="串行控制寄存器SCON"></a>串行控制寄存器SCON</h3><p>串行控制寄存器<code>SCON</code>用于选择串行通信的工作方式和某些控制功能。</p><p><img src="/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/%E4%B8%B2%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8.png" alt></p><p>各位地址为0x98~0x9f，可位寻址。</p><h4 id="SM0-amp-SM1"><a href="#SM0-amp-SM1" class="headerlink" title="SM0&amp;SM1"></a>SM0&amp;SM1</h4><p>通过<code>SM0</code>和<code>SM1</code>的组合可选择串行通信的工作方式：</p><p><img src="/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png" alt></p><ul><li><strong>方式0</strong>：在方式0下，数据从<code>RXD</code>端串行输出或输入，以8位数据为一帧，没有起始位和停止位，同步信号从<code>TXD</code>端输出，波特率固定不变，为晶振频率的1/12；常用于串口外接移位寄存器以拓展并行I/O，不适用于两个51单片机之间的串行通信。</li><li><strong>方式1</strong>：真正用于数据的串行发送和接收，<code>TXD</code>端和<code>RXD</code>端分别用于发送和接收数据；一帧数据为10位，包括1个起始位、8个数据位、1个停止位。</li><li><strong>方式2</strong>：当串口工作于方式2时，被定义为9位异步通信接口，每帧数据均为11位，包括1个起始位、8个数据位、1个校验位、1个停止位；第9位数据可通过软件控制，与<code>SCON</code>中的<code>SM2</code>位配合可使串口用于多机通信；波特率固定不变，为晶振频率的1/64或1/32，由<code>PCON</code>的最高位控制。</li><li><strong>方式3</strong>：与方式2类似，但方式3的波特率可变，也适用于多机通信。</li></ul><h4 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h4><p>多机通信控制位；主要用于方式2和方式3；若<code>SM2=1</code>，则允许多机通信；若<code>SM2=0</code>，则不允许多机通信，在接收完一帧数据后，置<code>RI</code>为1，同时把接收到的数据写入<code>SBUF</code>，在方式0中，<code>SM2</code>必须置0，在方式1中，若<code>SM2=1</code>，只有接收到有效停止位时，<code>RI</code>才置1。</p><h4 id="REN"><a href="#REN" class="headerlink" title="REN"></a>REN</h4><p>允许接收控制位；由软件置1或清零；当<code>REN=1</code>时，允许接收；当<code>REN=0</code>时，禁止接收。</p><h4 id="TB8"><a href="#TB8" class="headerlink" title="TB8"></a>TB8</h4><p>将待发送数据的第9位写入<code>TB8</code>，可以在多机通信中作为发送地址帧或数据帧的标志位。</p><h4 id="RB8"><a href="#RB8" class="headerlink" title="RB8"></a>RB8</h4><p>将接收到的数据的第9位写入<code>RB8</code>，类似于<code>TB8</code>。</p><h4 id="TI"><a href="#TI" class="headerlink" title="TI"></a>TI</h4><p>发送中断标志位；一帧数据准备发送时，该帧数据会被写入一个用作发送缓冲的<code>SBUF</code>等待马上被读取，当该帧数据发送完后，<code>TI</code>被置1，申请中断，表示该用作发送缓冲的<code>SBUF</code>已空，可以准备发送下一帧数据；<code>TI</code>不会自动清零，必须软件清零。</p><h4 id="RI"><a href="#RI" class="headerlink" title="RI"></a>RI</h4><p>接收中断标志位；当接收完一帧数据并且该帧数据被写入一个用作接收缓冲的<code>SBUF</code>后，<code>RI</code>被置1，申请中断，表示数据必须要马上被读取；<code>RI</code>也必须软件清零。<strong><code>RI</code>与<code>TI</code>是同一中断源，CPU一开始并不知道是发送还是接收产生的中断请求，必须在中断服务程序中通过是<code>TI==1</code>还是<code>RI==1</code>来判别。</strong></p><h3 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h3><p>电源控制寄存器<code>PCON</code>中只有<code>SMOD</code>位与串口运行有关，不可位寻址。</p><p><img src="/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/PCON.png" alt></p><ul><li>SMOD：波特率倍增位；在方式1、2、3中，当<code>SMOD</code>=1时，波特率增加一倍。</li></ul><h3 id="SBUF"><a href="#SBUF" class="headerlink" title="SBUF"></a>SBUF</h3><p>UART支持全双工的串口通信，可以同时接收和发送，待发送和已接收的数据分别写入两个不同的<code>SBUF</code>中暂存，这两个寄存器<strong>在物理上是相对独立的，但共用同一地址0x99</strong>。两个<code>SBUF</code>每次都只能暂存一个数据帧，只有暂存在SBUF中的数据帧被读取后，才能暂存下一数据帧；数据帧被写入<code>SBUF</code>后，必须要被马上读取，否则将被下一数据帧覆写。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//51单片机与PC进行串口通信：PC向51单片机发送字符，51单片机将接收到的字符返回给PC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART_init()<span class="comment">//初始化串口，波特率9600，晶振频率11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">PCON=<span class="number">0x80</span>;<span class="comment">//使能波特率倍增位SMOD</span></span><br><span class="line">SCON=<span class="number">0x50</span>;<span class="comment">//设置串口工作于方式1，不允许多机通信</span></span><br><span class="line">TMOD=<span class="number">0x20</span>;<span class="comment">//设置定时器1为8位自动重载模式，STC89C52RC的定时器0不能用作波特率发生器</span></span><br><span class="line">TL1=<span class="number">0xfa</span>;<span class="comment">//设置定时器1的初值</span></span><br><span class="line">TH1=<span class="number">0xfa</span>;<span class="comment">//设置定时器1的重载值</span></span><br><span class="line">TR1=<span class="number">1</span>;<span class="comment">//开启定时器1</span></span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//开启串口中断</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开启总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART() <span class="built_in">int</span>errupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">char temp;</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)<span class="comment">//当软件判别是串口接收产生的中断请求的时候</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SBUF;<span class="comment">//将接收到的数据赋值给变量temp</span></span><br><span class="line">RI=<span class="number">0</span>;<span class="comment">//软件清零</span></span><br><span class="line">SBUF=temp;<span class="comment">//将变量的值写入SBUF，准备发送</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);<span class="comment">//等待数据发送完毕</span></span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">UART_init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双机通信"><a href="#双机通信" class="headerlink" title="双机通信"></a>双机通信</h3><p>补充一个在两片51单片机之间进行双机通信的例子。</p><p>若主机的按键从未被按下，则从机的数码管显示数字“0“；当主机的按键K1被按下后，从机的数码管刷新显示数字“1”；当主机的按键K2被按下后，从机的数码管刷新显示数字“2”；当主机的按键K3被按下后，从机的数码管刷新显示数字“3”。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主机程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">sbit Key1=P1^<span class="number">0</span>;</span><br><span class="line">sbit Key2=P1^<span class="number">1</span>;</span><br><span class="line">sbit Key3=P1^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delaytime(unsigned char i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART_init()<span class="comment">//串口初始化，串口工作方式1，定时器工作方式2，波特率9600</span></span><br><span class="line">&#123;</span><br><span class="line">SCON=<span class="number">0x50</span>;</span><br><span class="line">TMOD=<span class="number">0x20</span>;</span><br><span class="line">TH1=<span class="number">0xfd</span>;</span><br><span class="line">TL1=<span class="number">0xfd</span>;</span><br><span class="line">TR1=<span class="number">1</span>;</span><br><span class="line">ES=<span class="number">0</span>;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART_TX(unsigned char p)<span class="comment">//串口输出数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">SBUF=p;</span><br><span class="line"><span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char KEY()<span class="comment">//按键扫描；无按键被按下，则返回数值0；按下按键K1，则返回数值1；按下按键K2，则返回数值2；按下按键K3，则返回数值3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">0</span>&amp;&amp;(Key1==<span class="number">0</span>||Key2==<span class="number">0</span>||Key3==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">Delaytime(<span class="number">100</span>);</span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Key1==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Key2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Key3==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Key1==<span class="number">1</span>&amp;&amp;Key2==<span class="number">1</span>&amp;&amp;Key3==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char num;</span><br><span class="line">UART_init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=KEY();</span><br><span class="line"><span class="keyword">if</span>(num)<span class="comment">//当有按键被按下时，则将相应的数值发送给从机</span></span><br><span class="line">&#123;</span><br><span class="line">UART_TX(num);</span><br><span class="line">&#125;</span><br><span class="line">Delaytime(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从机程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char LEDS[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>&#125;;<span class="comment">//数码管段码，分别显示数值0、1、2、3</span></span><br><span class="line">unsigned char num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delaytime(unsigned char i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART_init()<span class="comment">//串口初始化</span></span><br><span class="line">&#123;</span><br><span class="line">SCON=<span class="number">0x50</span>;</span><br><span class="line">TMOD=<span class="number">0x20</span>;</span><br><span class="line">TH1=<span class="number">0xfd</span>;</span><br><span class="line">TL1=<span class="number">0xfd</span>;</span><br><span class="line">TR1=<span class="number">1</span>;</span><br><span class="line">ES=<span class="number">1</span>;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> UART() <span class="built_in">int</span>errupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">num=SBUF;<span class="comment">//获取主机按键值</span></span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">UART_init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P0=LEDS[num];</span><br><span class="line">Delaytime(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94UART%E9%80%9A%E4%BF%A1%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt></p><hr><p>如有错误，请在评论区多多指教，非常感谢！</p><p><strong>参考资料：</strong></p><p><a href="https://mp.weixin.qq.com/s/kFtex1Hr28xa8KXlcrSl1Q" target="_blank" rel="noopener">UART串口通信的基本应用</a></p><p><a href="https://mp.weixin.qq.com/s/4bPFQT1-mJIfLGdKjSPNog" target="_blank" rel="noopener">我打赌！你还不会UART！不信，你看看~</a></p><p><a href="http://www.stcmcudata.com/datasheet/stc/STC-AD-PDF/STC89C51RC-RD.pdf" target="_blank" rel="noopener">STC89C52RC官方技术文档</a></p><p><a href="https://blog.csdn.net/wait_for_taht_day5/article/details/50564331" target="_blank" rel="noopener">【51单片机】（手把手教你）串口通信-基础篇</a></p><p><a href="https://blog.csdn.net/qq_27485531/article/details/81293188" target="_blank" rel="noopener">51单片机串口通讯UART</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机程序（LCD1602）</title>
      <link href="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/"/>
      <url>/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>很久没玩过51单片机了(．． )…，整理一下玩LCD1602模块的一些笔记。</p><a id="more"></a><p>LCD1602液晶显示模块可显示<code>2行、16字/行</code>的字符，绝大部分的LCD1602液晶显示模块都是基于HD77480及其兼容芯片来设计的。</p><p>单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a></p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/1602%E6%8E%A5%E5%8F%A3.png" alt></p><h2 id="LCD1602引脚"><a href="#LCD1602引脚" class="headerlink" title="LCD1602引脚"></a>LCD1602引脚</h2><ul><li><code>VSS</code>：电源地</li><li><code>VDD</code>：电源正极</li><li><code>V0</code>：液晶显示偏压信号，连接电位器，用于调节液晶显示的对比度</li><li><code>RS</code>：数据/命令选择端，当<code>RS=1</code>时，从<code>D0</code>到<code>D7</code>读/写数据；当<code>RS=0</code>时，从<code>D0</code>到<code>D7</code>读状态或写指令</li><li><code>RW</code>：读/写选择端，当<code>RW=1</code>时，进行读操作；当<code>RW=0</code>时，进行写操作</li><li><code>E</code>：使能端。进行读操作时，要使<code>E</code>处于高电平；进行写操作时，要使<code>E</code>处于下降沿</li><li><code>D0</code>~<code>D7</code>：并行输入/输出端</li><li><code>A</code>：背光源的正极</li><li><code>K</code>：背光源的负极</li></ul><h2 id="基本操作时序"><a href="#基本操作时序" class="headerlink" title="基本操作时序"></a>基本操作时序</h2><h3 id="读操作时序"><a href="#读操作时序" class="headerlink" title="读操作时序"></a>读操作时序</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F.png" alt></p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p><h3 id="写操作时序"><a href="#写操作时序" class="headerlink" title="写操作时序"></a>写操作时序</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F.png" alt></p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>LCD1602模块有两个8位寄存器，分别为指令寄存器和数据寄存器，可以通过<code>RS</code>和<code>R/W</code>输入信号的组合来选择指定的寄存器进行相应的操作。</p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E6%96%B9%E5%BC%8F.png" alt></p><ul><li><p>读状态：</p><ul><li>输入：<code>RS=0</code>、<code>RW=1</code>、<code>E=1</code></li><li>输出：<code>&lt;D0~D7&gt;=&lt;状态字&gt;</code></li></ul></li><li><p>写指令：</p><ul><li>输入：<code>RS=0</code>、<code>RW=0</code>、<code>&lt;D0~D7&gt;=&lt;指令码&gt;</code>、<code>E=&lt;高脉冲&gt;</code></li><li>输出：无</li></ul></li><li><p>读数据：</p><ul><li>输入：<code>RS=1</code>、<code>RW=1</code>、<code>E=1</code></li><li>输出：<code>&lt;D0~D7&gt;=&lt;数据&gt;</code></li></ul></li><li><p>写数据：</p><ul><li>输入：<code>RS=1</code>、<code>RW=0</code>、<code>&lt;D0~D7&gt;=&lt;数据&gt;</code>、<code>E=&lt;高脉冲&gt;</code></li><li>输出：无</li></ul></li></ul><h2 id="状态字说明"><a href="#状态字说明" class="headerlink" title="状态字说明"></a>状态字说明</h2><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E7%8A%B6%E6%80%81%E5%AD%97%E8%AF%B4%E6%98%8E.png" alt></p><ul><li><code>D7</code>：读写操作使能，当<code>D7=1</code>时，禁止读写；当<code>D7=0</code>时，允许读写</li><li><code>D6~0</code>：当前数据地址指针的数值</li></ul><p>因为LCD1602搭载的芯片运算速度较慢，当模块正在进行内部操作时，不接受任何外部指令和数据，此时，忙标志位<code>BF</code>为高电平。所以每次进行读写操作前，都必须进行读忙，将状态标志位<code>BF</code>读到<code>D7</code>，确保<code>D7=0</code>。</p><h2 id="LCD1602指令"><a href="#LCD1602指令" class="headerlink" title="LCD1602指令"></a>LCD1602指令</h2><p>51单片机可以直接访问LCD1602的指令寄存器和数据寄存器，在LCD1602进行内部操作前，来自51单片机的控制信息和数据将分别暂存于此，这些控制信息和数据的组合即为LCD1602的指令。</p><h3 id="清显示"><a href="#清显示" class="headerlink" title="清显示"></a>清显示</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E6%B8%85%E6%98%BE%E7%A4%BA.png" alt></p><h3 id="归位"><a href="#归位" class="headerlink" title="归位"></a>归位</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%BD%92%E4%BD%8D.png" alt></p><h3 id="设置输入模式"><a href="#设置输入模式" class="headerlink" title="设置输入模式"></a>设置输入模式</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F.png" alt></p><h3 id="显示开-关控制"><a href="#显示开-关控制" class="headerlink" title="显示开/关控制"></a>显示开/关控制</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E6%98%BE%E7%A4%BA%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6.png" alt></p><h3 id="游标或显示移位元"><a href="#游标或显示移位元" class="headerlink" title="游标或显示移位元"></a>游标或显示移位元</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E6%B8%B8%E6%A0%87%E6%88%96%E6%98%BE%E7%A4%BA%E7%A7%BB%E4%BD%8D%E5%85%83%EF%BC%880%EF%BC%89.png" alt></p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E6%B8%B8%E6%A0%87%E6%88%96%E6%98%BE%E7%A4%BA%E7%A7%BB%E4%BD%8D%E5%85%83%EF%BC%881%EF%BC%89.png" alt></p><h3 id="功能设置"><a href="#功能设置" class="headerlink" title="功能设置"></a>功能设置</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE.png" alt></p><h3 id="CGRAM地址设置"><a href="#CGRAM地址设置" class="headerlink" title="CGRAM地址设置"></a>CGRAM地址设置</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/CGRAM%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE.png" alt></p><h3 id="DDRAM地址设置"><a href="#DDRAM地址设置" class="headerlink" title="DDRAM地址设置"></a>DDRAM地址设置</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/DDRAM%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%EF%BC%880%EF%BC%89.png" alt></p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/DDRAM%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%EF%BC%881%EF%BC%89.png" alt></p><h3 id="读忙标志BF和AC"><a href="#读忙标志BF和AC" class="headerlink" title="读忙标志BF和AC"></a>读忙标志BF和AC</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E8%AF%BB%E5%BF%99%E6%A0%87%E5%BF%97BF%E5%92%8CAC.png" alt></p><h3 id="写数据到CGRAM或DDRAM"><a href="#写数据到CGRAM或DDRAM" class="headerlink" title="写数据到CGRAM或DDRAM"></a>写数据到CGRAM或DDRAM</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%86%99%E6%95%B0%E6%8D%AE%E5%88%B0CGRAM%E6%88%96DDRAM.png" alt></p><h3 id="从CGRAM或DDRAM中读数据"><a href="#从CGRAM或DDRAM中读数据" class="headerlink" title="从CGRAM或DDRAM中读数据"></a>从CGRAM或DDRAM中读数据</h3><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E4%BB%8ECGRAM%E6%88%96DDRAM%E4%B8%AD%E8%AF%BB%E6%95%B0%E6%8D%AE.png" alt></p><h2 id="CGROM、DDRAM和CGRAM"><a href="#CGROM、DDRAM和CGRAM" class="headerlink" title="CGROM、DDRAM和CGRAM"></a>CGROM、DDRAM和CGRAM</h2><p>在LCD1602模块内，与字符显示相关的存储器有CGROM、DDRAM、CGRAM。对于显示一些常用字符，其字模数据已存储于CGROM中，再调用时，只需使用语法<code>P=&lt;常用字符&gt;;</code>即可调用；但如果需要显示CGROM中不存在的字符，则必须先在CGRAM中自定义，再写入DDRAM。</p><h3 id="CGROM"><a href="#CGROM" class="headerlink" title="CGROM"></a>CGROM</h3><p>CGROM内存储了192个常用字符的字模数据，只能读出，不能写入。这些字模数据恰好与其对应的字符的ASCII值相等，因此，单片机会根据某常用字符的ASCII值从CGROM中读出与之值相等的字符数据，并将该字符数据写入DDRAM，即可显示对应的常用字符。另外，在CGROM中，地址<code>0x00</code> ~ <code>0x07</code>内容为空，由用户在CGRAM中进行自定义，再调用自定义的字符。</p><h3 id="DDRAM"><a href="#DDRAM" class="headerlink" title="DDRAM"></a>DDRAM</h3><p>DDRAM用于存储从CGROM或CGRAM读出的需要LCD1602显示的字符的字模数据，容量为80字节，地址范围：</p><ul><li><code>0x00</code> ~ <code>0x27</code></li><li><code>0x40</code> ~ <code>0x67</code></li></ul><p>其中用于存储需要显示的字符的字模数据的两段为：</p><ul><li><code>0x00</code> ~ <code>0x0f</code></li><li><code>0x40</code> ~ <code>0x4f</code></li></ul><p>其余部分用于存储字符显示相关的设置，例如字符的移动。</p><p><img src="/2021/02/20/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88LCD1602%EF%BC%89/%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt></p><h3 id="CGRAM"><a href="#CGRAM" class="headerlink" title="CGRAM"></a>CGRAM</h3><p>CGRAM用于存储自定义的字符的字模数据，可自定义8个点阵列大小为<code>5×7</code>的字符或4个点阵列大小为<code>5×11</code>的字符。以<code>5×7</code>模式为例，一个字模数据大小为8字节，需要8个地址来表示，每8个地址组成一个地址段，存储一个字模数据；第一个地址段的起始为<code>0x40</code>，该地址段对应CGROM中的地址<code>0x00</code>；第二个地址段的起始为<code>0x48</code>，该地址段对应CGROM中的地址<code>0x01</code>；第三个地址段的起始为<code>0x50</code>，该地址段对应CGROM中的地址<code>0x02</code>，依此类推。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示已有的字符</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">include</span>&lt;reg51.h&gt;</span><br><span class="line">#<span class="keyword">include</span>&lt;intrins.h&gt;<span class="comment">//包含有_nop_()函数定义的头文件，若使用12MHz的晶振，_nop_()函数起到延时1微秒的效果，_nop_()函数延时的时长由晶振频率决定</span></span><br><span class="line">sbit RS=P2^<span class="number">6</span>;</span><br><span class="line">sbit RW=P2^<span class="number">5</span>;</span><br><span class="line">sbit E=P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> Text0<span class="literal">[]</span>=<span class="string">"Hello,"</span>;<span class="comment">//定义LCD1602第一行显示的字符</span></span><br><span class="line"><span class="built_in">char</span> Text1<span class="literal">[]</span>=<span class="string">"world!"</span>;<span class="comment">//定义LCD1602第二行显示的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadBusy()</span><span class="comment">//定义一个用于读忙的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">1</span>;</span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">P0=<span class="number">0xff</span>;<span class="comment">//在电子电路中，高电平容易被低电平拉低，而低电平一般不能被高电平拉高，所以在读取某I/O端数据时，将该I/O端置1，确保原来的数据不受影响</span></span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">temp=P0;<span class="comment">//读取LCD1602的状态字</span></span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">return(temp&amp;<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="constructor">Delay5ms()</span><span class="comment">//定义一个延时5毫秒的函数</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="built_in">char</span> i,j;</span><br><span class="line">i=<span class="number">59</span>;</span><br><span class="line">j=<span class="number">90</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="constructor">Write_Com(<span class="params">char</span> <span class="params">com</span>)</span><span class="comment">//定义一个用于写命令的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="constructor">ReadBusy()</span>);</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">P0=com;<span class="comment">//准备写入命令</span></span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">E=<span class="number">1</span>;<span class="comment">//当使能端为高电平时，写入命令</span></span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line">E=<span class="number">0</span>;<span class="comment">//命令写入完成后，要将使能端的高电平拉低</span></span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="constructor">Write_Dat(<span class="params">char</span> <span class="params">dat</span>)</span><span class="comment">//定义一个用于写数据的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="constructor">ReadBusy()</span>);</span><br><span class="line">RS=<span class="number">1</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">P0=dat;</span><br><span class="line"><span class="constructor">_nop_()</span>;</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init<span class="literal">()</span><span class="comment">//定义一个用于初始化LCD1602的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="constructor">Delay5ms()</span>;<span class="comment">//延时15毫秒</span></span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line"><span class="constructor">Write_Com(0x38)</span>;<span class="comment">//设置显示模式</span></span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line"><span class="constructor">Write_Com(0x38)</span>;</span><br><span class="line"><span class="constructor">Delay5ms()</span>;</span><br><span class="line"><span class="constructor">Write_Com(0x38)</span>;</span><br><span class="line"><span class="constructor">Write_Com(0x0c)</span>;<span class="comment">//设置显示开关及光标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i,j;</span><br><span class="line">init<span class="literal">()</span>;</span><br><span class="line"><span class="constructor">Write_Com(0x80)</span>;<span class="comment">//设置指针指向显示第一行的第一个字符的DDRAM地址</span></span><br><span class="line">for(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="constructor">Write_Dat(Text0[<span class="params">i</span>])</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">Write_Com(0x80+0x40)</span>;<span class="comment">//设置指针指向显示第二行的第一个字符的DDRAM地址</span></span><br><span class="line">for(j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="constructor">Write_Dat(Text1[<span class="params">j</span>])</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示自定义字符</span></span><br><span class="line"></span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">#include&lt;<span class="built_in">int</span>rins.h&gt;</span><br><span class="line">sbit RS=P2^<span class="number">6</span>;</span><br><span class="line">sbit RW=P2^<span class="number">5</span>;</span><br><span class="line">sbit E=P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">char Image0[]=&#123;<span class="number">0x08</span>,<span class="number">0x1F</span>,<span class="number">0x12</span>,<span class="number">0x0F</span>,<span class="number">0x0A</span>,<span class="number">0x1F</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;;<span class="comment">//汉字“年”的字模数据</span></span><br><span class="line">char Image1[]=&#123;<span class="number">0x0F</span>,<span class="number">0x09</span>,<span class="number">0x0F</span>,<span class="number">0x09</span>,<span class="number">0x0F</span>,<span class="number">0x09</span>,<span class="number">0x13</span>,<span class="number">0x00</span>&#125;;<span class="comment">//汉字“月”的字模数据</span></span><br><span class="line">char Image2[]=&#123;<span class="number">0x1F</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x1F</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;;<span class="comment">//汉字“日”的字模数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> ReadBusy()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=<span class="number">0xff</span>;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">temp=P0;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>(temp&amp;<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay5ms()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=<span class="number">59</span>;</span><br><span class="line">j=<span class="number">90</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_Com(char com)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ReadBusy());</span><br><span class="line">RS=<span class="number">0</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=com;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Write_Dat(char dat)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ReadBusy());</span><br><span class="line">RS=<span class="number">1</span>;</span><br><span class="line">RW=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">P0=dat;</span><br><span class="line">_nop_();</span><br><span class="line">E=<span class="number">1</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">E=<span class="number">0</span>;</span><br><span class="line">Delay5ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> init()</span><br><span class="line">&#123;</span><br><span class="line">Delay5ms();</span><br><span class="line">Delay5ms();</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);</span><br><span class="line">Delay5ms();</span><br><span class="line">Write_Com(<span class="number">0x38</span>);</span><br><span class="line">Write_Com(<span class="number">0x0c</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> x,y,z;</span><br><span class="line">init();</span><br><span class="line">Write_Com(<span class="number">0x40</span>);<span class="comment">//设置指针指向CGRAM中第一个地址段的起始（5x7模式中一个字模数据大小为8字节，即需要8个地址来表示）</span></span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;sizeof(Image0);x++)<span class="comment">//写入字模数据</span></span><br><span class="line">&#123;</span><br><span class="line">Write_Dat(Image0[x]);</span><br><span class="line">&#125;</span><br><span class="line">Write_Com(<span class="number">0x48</span>);</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;sizeof(Image1);y++)</span><br><span class="line">&#123;</span><br><span class="line">Write_Dat(Image1[y]);</span><br><span class="line">&#125;</span><br><span class="line">Write_Com(<span class="number">0x50</span>);</span><br><span class="line"><span class="keyword">for</span>(z=<span class="number">0</span>;z&lt;sizeof(Image2);z++)</span><br><span class="line">&#123;</span><br><span class="line">Write_Dat(Image2[z]);</span><br><span class="line">&#125;</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x00</span>);<span class="comment">//0x80+0x00等效于0x80</span></span><br><span class="line">Write_Dat(<span class="number">0x00</span>);<span class="comment">//将CGRAM中第一个地址段存储的字模数据写入DDRAM</span></span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x02</span>);</span><br><span class="line">Write_Dat(<span class="number">0x01</span>);</span><br><span class="line">Write_Com(<span class="number">0x80</span>+<span class="number">0x04</span>);</span><br><span class="line">Write_Dat(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本文内容如有错误，请在评论区多多指教，非常感谢φ(≧ω≦*)♪。</p><p><strong>参考资料</strong></p><p><a href="https://blog.csdn.net/u013151320/article/details/46663167" target="_blank" rel="noopener">51单片机LCD1602程序详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/166184285" target="_blank" rel="noopener">超详细讲解，LCD1602电路与驱动</a></p><p><a href="https://blog.csdn.net/ROC_CHAO/article/details/107125314" target="_blank" rel="noopener">基于51单片机点亮LCD1602+自定义字符</a></p><p><a href="https://blog.csdn.net/imxlw00/article/details/90316745?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161370745016780261912211%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161370745016780261912211&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-90316745.first_rank_v2_pc_rank_v29_10&utm_term=51%25E5%258D%2595%25E7%2589%2587%25E6%259C%25BA+CGRAM" target="_blank" rel="noopener">单片机 1602 CGRAM、CGROM及DDRAM的作用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cloudreve —— 年轻人的第一个私人云盘</title>
      <link href="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/"/>
      <url>/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>一周前在一台瘦客户机升腾C92上借助<a href="https://cloudreve.org/" target="_blank" rel="noopener">Cloudreve</a>搭建了一个私人云盘来玩一玩(〃´∀｀)，今天来记录一下。</p><a id="more"></a><h2 id="Cloudreve特性"><a href="#Cloudreve特性" class="headerlink" title="Cloudreve特性"></a>Cloudreve特性</h2><ul><li>☁️ 支持本机、从机、七牛、阿里云 OSS、腾讯云 COS、又拍云、OneDrive (包括世纪互联版) 作为存储端</li><li>📤 上传/下载 支持客户端直传，支持下载限速</li><li>💾 可对接 Aria2 离线下载</li><li>📚 在线 压缩/解压缩、多文件打包下载</li><li>💻 覆盖全部存储策略的 WebDAV 协议支持</li><li>⚡ 拖拽上传、目录上传、流式上传处理</li><li>🗃️ 文件拖拽管理</li><li>👩‍👧‍👦 多用户、用户组</li><li>🔗 创建文件、目录的分享链接，可设定自动过期</li><li>👁️‍🗨️ 视频、图像、音频、文本、Office 文档在线预览</li><li>🎨 自定义配色、黑暗模式、PWA 应用、全站单页应用</li><li>🚀 All-In-One 打包，开箱即用</li></ul><h2 id="Cloudreve部署"><a href="#Cloudreve部署" class="headerlink" title="Cloudreve部署"></a>Cloudreve部署</h2><p>首先需要从<a href="https://github.com/cloudreve/Cloudreve" target="_blank" rel="noopener">Cloudreve项目的GitHub地址</a>获取适用于目标服务器的操作系统类型与CPU架构的Cloudreve程序；我的瘦客户机升腾C92的CPU架构为64位的x86，我选用的操作系统是Debian 10，Cloudreve版本为3.2.1。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/cloudreve/</span>Cloudreve<span class="regexp">/releases/</span>download<span class="regexp">/3.2.1/</span>cloudreve_3.<span class="number">2.1</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>下载完成后，在当前路径下新建一个目录，把压缩包移动至该目录内再解压和运行，这样可以避免当前路径在将来变得乱糟糟的(((ﾟдﾟ)))。</p><p>新建一个目录，命名为<code>Cloudreve</code>；</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Cloudreve</span><br></pre></td></tr></table></figure><p>将压缩包移动至目录<code>Cloudreve</code>；</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">cloudreve_3</span><span class="selector-class">.2</span><span class="selector-class">.1_linux_amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span> <span class="selector-tag">Cloudreve</span></span><br></pre></td></tr></table></figure><p>进入目录<code>Cloudreve</code>；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Cloudreve</span><br></pre></td></tr></table></figure><p>解压压缩包；</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">cloudreve_3</span><span class="selector-class">.2</span><span class="selector-class">.1_linux_amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>给可执行文件<code>cloudreve</code>授予执行权限；</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">chmod +<span class="symbol">x</span> ./cloudreve</span><br></pre></td></tr></table></figure><p>Cloudreve默认监听端口<code>5212</code>，部分操作系统可能会默认禁用该端口，需要予以放行；我在Debian 10下使用防火墙管理工具<code>UFW</code>启用<code>5212</code>端口；</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ufw allow <span class="number">5212</span></span><br></pre></td></tr></table></figure><p>运行Cloudreve；</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./cloudreve</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/%E4%BF%A1%E6%81%AF.png" alt></p><p>这样就能在浏览器上访问<code>&lt;服务器IP&gt;:5212</code>来使用Cloudreve。</p><h3 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h3><p>使用文本编辑器<code>vim</code>编辑配置文件；</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">cloudreve</span>.<span class="title">service</span></span></span><br></pre></td></tr></table></figure><p>添加如下内容：（需要将文本中的<code>PATH_TO_CLOUDREVE</code>替换为可执行文件<code>cloudreve</code>所在的目录）</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Cloudreve</span><br><span class="line"><span class="attr">Documentation</span>=https://docs.cloudreve.org</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"><span class="attr">After</span>=mysqld.service</span><br><span class="line"><span class="attr">Wants</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">WorkingDirectory</span>=/PATH_TO_CLOUDREVE</span><br><span class="line"><span class="attr">ExecStart</span>=/PATH_TO_CLOUDREVE/cloudreve</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-abnormal</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span>s</span><br><span class="line"><span class="attr">KillMode</span>=mixed</span><br><span class="line"></span><br><span class="line"><span class="attr">StandardOutput</span>=null</span><br><span class="line"><span class="attr">StandardError</span>=syslog</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>更新配置；</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure><p>启动服务；</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> cloudreve</span><br></pre></td></tr></table></figure><p>设置开机启动。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> cloudreve</span><br></pre></td></tr></table></figure><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><ul><li><p>启动服务</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> cloudreve</span><br></pre></td></tr></table></figure></li><li><p>停止服务</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">stop</span> cloudreve</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart cloudreve</span></span><br></pre></td></tr></table></figure></li><li><p>查看状态</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status cloudreve</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>如果把Cloudreve直接部署在公网服务器，则可直接在公网环境下访问，但因为我是部署在局域网环境下的瘦客户机上，所以如果需要在公网环境下访问，就需要将该瘦客户机的IP与Cloudreve监听的端口映射到一台公网服务器上，通过访问该公网服务器即可访问到局域网下的瘦客户机；常用的内网穿透工具有ngrok、frp、NATAPP等，考虑到访问速度和开箱即用，我选用的是在国内运营的<a href="https://natapp.cn/" target="_blank" rel="noopener">NATAPP</a>。</p><h3 id="账号注册与方案选购"><a href="#账号注册与方案选购" class="headerlink" title="账号注册与方案选购"></a>账号注册与方案选购</h3><p>NATAPP提供多种方案的服务，按照自己的实际需求来选购就可以了，反正我现在只是拿来玩一玩( ～’ω’)～，就选用<code>免费隧道(注册用户)</code>。</p><p><code>隧道协议</code>选择<code>Web</code>，<code>本地端口</code>设置为Cloudreve监听的端口，若是默认监听端口，即为<code>5212</code>。</p><p><img src="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/%E8%B4%AD%E4%B9%B0%E9%9A%A7%E9%81%93.png" alt></p><h3 id="客户端安装与运行"><a href="#客户端安装与运行" class="headerlink" title="客户端安装与运行"></a>客户端安装与运行</h3><p>在自己的服务器上新建一个目录，我将其命名为<code>NATAPP</code>。</p><p>进入目录<code>NATAPP</code>，下载NATAPP的客户端<code>natapp</code>和本地配置文件<code>config.ini</code>；</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>download.natapp.cn<span class="regexp">/assets/</span>downloads<span class="regexp">/clients/</span><span class="number">2</span>_3_9<span class="regexp">/natapp_linux_amd64/</span>natapp</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>download.natapp.cn<span class="regexp">/assets/</span>downloads<span class="regexp">/config.ini</span></span><br></pre></td></tr></table></figure><p>使用文本编辑器<code>vim</code>编辑<code>config.ini</code>；</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">config</span>.ini</span><br></pre></td></tr></table></figure><p><img src="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt></p><p>在NATAPP官网的<code>会员中心</code>→<code>我的隧道</code>下即可找到刚才选购的隧道方案的<code>authtoken</code>并复制粘贴到本地配置文件<code>config.ini</code>的<code>authtoken</code>一项中；</p><p><img src="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/%E6%88%91%E7%9A%84%E9%9A%A7%E9%81%93.png" alt></p><p>为可执行文件<code>natapp</code>授予执行权限；</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">chmod a+<span class="symbol">x</span> natapp</span><br></pre></td></tr></table></figure><p>运行客户端；</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./natapp</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/18/Cloudreve%20%E2%80%94%E2%80%94%20%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BA%91%E7%9B%98/%E8%BF%90%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt></p><p>在列出的信息中，<code>Forwarding</code>一项给出的域名即为内网服务器的5212端口的公网映射；在局域网或公网下访问该域名即可访问已在局域网下部署的Cloudreve。</p><p>至此，年轻人的第一个私人云盘已初步部署完毕，可以投入实际使用了（゜▽＾*））。</p><hr><p><strong>参考资料</strong></p><p><a href="https://github.com/cloudreve/Cloudreve" target="_blank" rel="noopener">Cloudreve项目的GitHub地址</a></p><p><a href="https://docs.cloudreve.org/" target="_blank" rel="noopener">Cloudreve官方文档</a></p><p><a href="https://natapp.cn/article/natapp_newbie" target="_blank" rel="noopener">NATAPP1分钟快速新手图文教程</a></p><p><a href="https://natapp.cn/article/config_ini" target="_blank" rel="noopener">使用本地配置文件config.ini</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 私有云存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐讯N1折腾记录（一）</title>
      <link href="/2021/01/24/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/01/24/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前一直有听说过斐讯N1这款硬件产品，但直到最近才入手了一台，今天折腾了一阵子，写下此文记录一下(′▽`〃)。</p><a id="more"></a><h2 id="降级操作"><a href="#降级操作" class="headerlink" title="降级操作"></a>降级操作</h2><p>如果机器的官方操作系统版本较高（版本号2.22以上）的话，需要先把boot、bootloader等关键分区降级到低版本，才能引导和启动非官方的操作系统；但因为我手上这台斐讯N1到手前被卖家刷入了OpenWrt，关键分区已经被降级到低版本，而一台机器只需进行一次降级操作，所以我就不需要再对其进行降级操作了。</p><h2 id="刷入Armbian"><a href="#刷入Armbian" class="headerlink" title="刷入Armbian"></a>刷入Armbian</h2><p><a href="https://www.armbian.com/" target="_blank" rel="noopener">Armbian</a>是一款基于Ubuntu和Debian开发，可运行于ARM开发板上的操作系统。我选择这个操作系统是因为想把这台斐讯N1作为一台轻量级的ARM服务器来玩玩φ(≧ω≦*)♪。</p><p>我选用的镜像是<a href="https://pan.baidu.com/s/1iu0de2aqrK799fw9PrIT-Q" target="_blank" rel="noopener">Armbian_5.77_Aml-s905_Ubuntu_bionic_default_5.0.2_20190401.zip</a>（提取码：518d），Armbian版本5.77，内核版本5.0.2，目前来说是较新但又相对省心的版本。</p><h3 id="写入U盘-amp-导入-dtb文件"><a href="#写入U盘-amp-导入-dtb文件" class="headerlink" title="写入U盘 &amp; 导入.dtb文件"></a>写入U盘 &amp; 导入.dtb文件</h3><p>镜像解压后，使用工具<a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">balenaEtcher</a>写入U盘。因为这个镜像包含的操作系统原本是运行在一款与斐讯N1存在硬件差异的ARM开发板上的，如果直接由该操作系统驱动斐讯N1，会带来各种兼容问题；所以需要一个记录了斐讯N1的硬件信息（例如CPU、RAM等详细信息）的<code>.dtb</code>文件（<code>.dtb</code>文件需要随着内核编译，<strong>同一设备不同内核所对应的.dtb文件也不同，不能混用</strong>）向内核传递相关的硬件信息，内核根据这些信息对CPU、RAM等斐讯N1的硬件进行调度和管理，最终实现该操作系统相对完美地在斐讯N1上运行。</p><p>我把文件<code>meson-gxl-s905d-phicomm-n1-xiangsm.dtb</code>放入U盘的<code>BOOT</code>分区根目录下，随后使用文本编辑器打开文件<code>uEnv.ini</code>，修改<code>dtb_name</code>一项，使其指向<code>meson-gxl-s905d-phicomm-n1-xiangsm.dtb</code>，即修改为<code>dtb_name=/meson-gxl-s905d-phicomm-n1-xiangsm.dtb</code>。然后就能让斐讯N1从U盘启动操作系统了。</p><h3 id="写入eMMC"><a href="#写入eMMC" class="headerlink" title="写入eMMC"></a>写入eMMC</h3><p>将U盘插入靠近HDMI接口的USB接口，连接显示器，给斐讯N1通电，即可从U盘启动Armbian。Armbian启动后，登录默认的root用户（用户名：root，密码：1234）；首次登录，需要先输入一次默认的密码，然后系统要求修改root用户的密码。</p><p>接着使用以下命令，即可把U盘中的Armbian写入斐讯N1的eMMC（<strong>原有的操作系统和数据将会被覆写</strong>），写入完成后，使用命令<code>poweroff</code>关机并拔出U盘。下一次给斐讯N1通电就能直接从eMMC启动Armbian。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">nand-sata-<span class="keyword">install</span></span><br></pre></td></tr></table></figure><h2 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h2><p>Armbian的默认软件源位于境外，国内的访问速度实在是一言难尽╮(╯▽╰)╭，所以需要使用国内的软件源，通过国内的服务器来更新软件列表和升级软件包。我一般用的是清华大学开源软件镜像站。</p><p>使用文本编辑器vim打开<code>/etc/apt/sources.list</code>：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p><img src="/2021/01/24/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/%E9%95%9C%E5%83%8F%E6%BA%90.png" alt></p><p>写入以下的软件源信息，但多个软件源应该不能共存（具体我没尝试过），所以需要用<code>#</code>把原有的软件源信息注释（也可以删除，但如果软件源信息写入错误，那就没退路了|(*′口`)），原有的软件源信息中的注释内容可删除。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>更改后如下：</p><p><img src="/2021/01/24/%E6%96%90%E8%AE%AFN1%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BF%AE%E6%94%B9%E5%90%8E.png" alt></p><p>按<code>i</code>键进入编辑模式，更改完后，按<code>ESC</code>键，接着输入<code>:wq</code>即为保存并退出。</p><p>另外，还需要更改<code>/etc/apt/sources.list.d/armbian.list</code>：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/apt/sources.<span class="keyword">list</span>.d/armbian.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deb</span> http://mirrors.tuna.tsinghua.edu.cn/armbian/ <span class="keyword">bionic </span>main <span class="keyword">bionic-utils </span><span class="keyword">bionic-desktop</span></span><br></pre></td></tr></table></figure><h2 id="中文显示和输入"><a href="#中文显示和输入" class="headerlink" title="中文显示和输入"></a>中文显示和输入</h2><p>使用SSH协议连接斐讯N1，在终端中无法显示和输入中文，需要修改<code>/etc/environment</code>中的内容<code>LC_ALL=&quot;C&quot;</code>，如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">LC_ALL</span>=<span class="string">"en_US.utf-8"</span></span><br></pre></td></tr></table></figure><p>然后关机再通电重启。</p><h2 id="解决负载过高的问题"><a href="#解决负载过高的问题" class="headerlink" title="解决负载过高的问题"></a>解决负载过高的问题</h2><p>由于网卡驱动的问题，在启用有线网络的时候，系统负载较高，真正解决问题就需要修改<code>.dtb</code>文件。</p><p>进入目录<code>/boot</code>，首先需要把<code>.dtb</code>文件反编译为<code>.dts</code>文件并命名为<code>n1.dts</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dtc</span> <span class="selector-tag">-I</span> <span class="selector-tag">dtb</span> <span class="selector-tag">-O</span> <span class="selector-tag">dts</span> <span class="selector-tag">-o</span> <span class="selector-tag">n1</span><span class="selector-class">.dts</span> <span class="selector-tag">meson-gxl-s905d-phicomm-n1-xiangsm</span><span class="selector-class">.dtb</span></span><br></pre></td></tr></table></figure><p>使用vim编辑器打开<code>n1.dts</code>，找到<code>interrupt-controller@9880</code>一项，将其下的<code>phandle</code>一项使用<code>#</code>注释，如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>errupt-<span class="symbol">controller@</span><span class="number">9880</span> &#123;</span><br><span class="line">compatible = <span class="string">"amlogic,meson-gpio-intc"</span>, <span class="string">"amlogic,meson-gxl-gpio-intc"</span>;</span><br><span class="line">reg = &lt;<span class="number">0x0</span> <span class="number">0x9880</span> <span class="number">0x0</span> <span class="number">0x10</span>&gt;;</span><br><span class="line"><span class="built_in">int</span>errupt-controller;</span><br><span class="line">#<span class="built_in">int</span>errupt-cells = &lt;<span class="number">0x2</span>&gt;;</span><br><span class="line">amlogic,channel-<span class="built_in">int</span>errupts = &lt;<span class="number">0x40</span> <span class="number">0x41</span> <span class="number">0x42</span> <span class="number">0x43</span> <span class="number">0x44</span> <span class="number">0x45</span> <span class="number">0x46</span> <span class="number">0x47</span>&gt;;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line">#phandle = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改完成后，把<code>.dts</code>文件编译为<code>.dtb</code>文件，并命名为<code>n1.dtb</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dtc</span> <span class="selector-tag">-I</span> <span class="selector-tag">dts</span> <span class="selector-tag">-O</span> <span class="selector-tag">dtb</span> <span class="selector-tag">-o</span> <span class="selector-tag">n1</span><span class="selector-class">.dtb</span> <span class="selector-tag">n1</span><span class="selector-class">.dts</span></span><br></pre></td></tr></table></figure><p>接着，修改文件<code>uEnv.ini</code>中<code>dtb_name</code>一项，指向<code>n1.dtb</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">dtb_name</span>=/n1.dtb</span><br></pre></td></tr></table></figure><p>重新启动，即可使系统负载回复到正常水平。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><hr><p><strong>参考文章</strong></p><p><a href="https://www.right.com.cn/forum/thread-340279-1-1.html" target="_blank" rel="noopener">[T1] [2018-9-28]斐讯T1和N1降级恢复线刷功能, adb脚本工具</a></p><p><a href="https://yuerblog.cc/2019/10/23/%E6%96%90%E8%AE%AFn1-%E5%AE%8C%E7%BE%8E%E5%88%B7%E6%9C%BAarmbian%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">斐讯N1 – 完美刷机Armbian教程</a></p><p><a href="https://www.right.com.cn/forum/thread-510423-1-1.html" target="_blank" rel="noopener">[N1盒子] Armbian-5.77 on N1, so far so good</a></p><p><a href="https://powersee.github.io/2020/03/n1-armbian-server/" target="_blank" rel="noopener">打造最具性价比服务器 N1-armbian</a></p><p><a href="https://p3terx.com/archives/n1-armbian-dtb.html" target="_blank" rel="noopener">斐讯 N1 Armbian 低负载 dtb 编译</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/" target="_blank" rel="noopener">Ubuntu Ports 镜像使用帮助</a></p><p><strong>资源出处</strong></p><p><a href="http://veger.ys168.com/" target="_blank" rel="noopener">@powersee</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于进程和线程的一些笔记</title>
      <link href="/2021/01/21/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/01/21/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>整理一下进程和线程的一些简单笔记，如有错误，请在评论区多多指教，非常感谢＜（＾－＾）＞。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是应用程序运行的载体，也是操作系统分配资源和调度的基本单位，每个进程均有独立的内存空间。进程一般由程序段、数据段和进程控制块三部分组成。操作系统通过链接方式和索引方式对各个进程进行管理。在Windows下，每运行一个<code>.exe</code>文件即为新建一个进程。</p><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul><li><strong>动态性</strong>：进程是程序的一次执行过程，动态产生、动态消亡，是临时的，具有生命周期。</li><li><strong>并发性</strong>：任何进程均可与其他进程一起并发执行。</li><li><strong>独立性</strong>：进程是操作系统进行资源分配和调度的一个独立单位。</li><li><strong>制约性</strong>：因访问共享资源或进程间同步而产生制约。</li></ul><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程由程序段、数据段和进程控制块三部分组成：</p><ul><li><strong>程序段</strong>：程序段用于描述进程要完成的功能以及控制进程的执行。</li><li><strong>数据段</strong>：数据段包含进程在执行时所需要的数据。</li><li><strong>进程控制块</strong>：操作系统为每个进程都维护一个进程控制块来管理进程，该部分包含进程的描述信息、控制与管理信息、资源分配信息、处理机相关信息，是进程存在的唯一标志，进程的任何状态变化都可通过进程控制块来体现。</li></ul><h4 id="进程控制块包含的的信息"><a href="#进程控制块包含的的信息" class="headerlink" title="进程控制块包含的的信息"></a>进程控制块包含的的信息</h4><ul><li><p><strong>进程标识信息</strong>：包括本进程的标识、本进程的父进程标识、用户标识等。</p></li><li><p><strong>处理机状态信息保护区</strong>：用于保存进程的运行现场信息：</p><ul><li><strong>用户可见寄存器</strong>：用户程序可使用的（数据、地址等）寄存器；</li><li><strong>控制和状态寄存器</strong>：程序计数器、程序状态字；</li><li><strong>栈指针</strong>：用于中断处理和返回、过程调用、系统调用；</li></ul></li><li><p><strong>进程控制信息</strong>：</p><ul><li><strong>调度和状态信息</strong>：在被操作系统调度时使用；</li><li><strong>进程间通信信息</strong>：进程之间进行通信所需的各种标识、信号等，这些信息存在于接收方的进程控制块中；</li><li><strong>存储管理信息</strong>：包含有指向本进程存储空间的数据结构；</li><li><strong>进程所用资源</strong>：说明由进程使用的系统资源（例如进程打开的文件）；</li><li><strong>有关数据结构连接信息</strong>：进程可以连接到一个进程队列中，或连接到相关的其他进程的进程控制块。</li></ul></li></ul><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><ul><li><strong>链接方式</strong>：根据进程状态将各进程的进程控制块分为多个队列，操作系统持有指向各队列的指针。</li><li><strong>索引方式</strong>：根据进程状态为各进程的进程控制块建立多个索引表，操作系统持有指向各索引表的指针。</li></ul><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>在多数的操作系统中，进程在生命结束前有三种基本状态：</p><ul><li><strong>就绪状态</strong>：<strong>进程等待CPU资源</strong>，进程此时已具备执行条件，但其他进程正在占用CPU，一旦得到处理机就可以运行。</li><li><strong>运行状态</strong>：进程正在执行，正在占用CPU。</li><li><strong>阻塞状态</strong>：<strong>进程本身不具备运行条件，即使其获得CPU也不能运行</strong>，进程正在等待某一事件（例如等待输入输出或等待某数据）而暂停执行。</li></ul><p>在只搭载一个单核CPU（不考虑超线程技术）的计算机上，在任何时刻有且仅有一个进程处于运行状态。</p><h4 id="进程状态间的转换"><a href="#进程状态间的转换" class="headerlink" title="进程状态间的转换"></a>进程状态间的转换</h4><ul><li>就绪状态 → 运行状态：进程被调度</li><li>运行状态 → 就绪状态：时间片到，或CPU被其他高优先级的进程抢占</li><li>运行状态 → 阻塞状态：等待资源分配，或等待某事件的发生（主动行为）</li><li>阻塞状态 → 就绪状态：资源分配到位，或等待的事件已发生（被动行为）</li></ul><p><img src="/2021/01/21/%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt></p><h3 id="进程的生命周期管理"><a href="#进程的生命周期管理" class="headerlink" title="进程的生命周期管理"></a>进程的生命周期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>创建进程有三种主要情况：</p><ul><li>系统初始化；</li><li>用户请求创建一个新进程；</li><li>一个正在运行的进程执行创建进程的系统调用。</li></ul><h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>操作系统内核选择一个处于就绪状态的进程，让其占用处理机并运行。</p><h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><p>进程阻塞有三种主要情况：</p><ul><li>请求并等待系统服务，无法马上完成；</li><li>启动某种操作，无法马上完成；</li><li>需要的数据没有到达。</li></ul><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>进程只能被其他进程或操作系统唤醒，有三种主要情况：</p><ul><li>被阻塞的进程需要的资源可被满足；</li><li>被阻塞的进程等待的事件到达；</li><li>将该进程的进程控制块插入到就绪队列。</li></ul><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>进程结束有四种主要情况：</p><ul><li><strong>正常退出</strong>（自愿）：进程执行完毕，正常终止。</li><li><strong>出错退出</strong>（自愿）：进程发现了错误而退出。</li><li><strong>严重错误</strong>（强制）：进程发生了严重的错误而不得不退出，通常是由程序的错误引起，例如执行了非法指令、引用不存在的内存等。</li><li><strong>被其他进程杀死</strong>（强制）。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程执行中的一个单一的顺序控制流程，是进程执行的最小单位，也是资源分配和CPU调度的基本单位。和进程一样，线程也有就绪、阻塞、运行三种基本状态。一个进程包含有一个或多个线程，除线程本身所必需的最基本资源（例如寄存器、栈）外，同一进程中的线程共享操作系统分配给该进程的资源和内存空间。</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul><li>进程是操作系统分配资源和调度的基本单位，线程是CPU调度和执行的基本单位。</li><li>一个线程只能属于一个进程，而一个进程至少包含有一个线程。</li><li>进程之间相互独立，但同一进程下的各线程共享该进程所得的资源和内存空间。</li><li>进程之间的切换所消耗的资源较多，线程之间的切换所消耗的资源较少。</li><li>一个进程崩溃后，可不对其他进程造成影响；但一个线程的崩溃将导致其所属进程的崩溃。</li></ul><p>先整理到这里(′▽`〃)。</p><hr><p>本人菜鸡一只，如有错误，请多多指教(′▽`〃)。</p><p>本文整理自</p><p><a href="https://www.cnblogs.com/wkfvawl/p/11512107.html" target="_blank" rel="noopener">操作系统——进程的定义、组成、组织方式和特征</a></p><p><a href="https://github.com/zkywsg/Daily-DeepLearning/blob/master/07-BaseClass/Os/04%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md" target="_blank" rel="noopener">04进程与线程.md</a></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/102021274" target="_blank" rel="noopener">进程和线程的区别(超详细)</a></p><p><a href="http://luckylau.tech/2017/06/20/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">进程和线程的区别</a></p><p><a href="https://mp.weixin.qq.com/s/vofzmsLtJcMyAhWgSVTVIg" target="_blank" rel="noopener">深度好文|面试官：进程和线程，我只问这19个问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑代数公式整理</title>
      <link href="/2020/12/19/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2020/12/19/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>临近期末考试ヽ(*。&gt;Д&lt;)o゜，开始整理一些数字电子相关的笔记。</p><a id="more"></a><h2 id="基本公式和常用公式"><a href="#基本公式和常用公式" class="headerlink" title="基本公式和常用公式"></a>基本公式和常用公式</h2><h3 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h3><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span><span class="keyword">A</span>=<span class="number">0</span></span><br><span class="line"><span class="number">1</span><span class="keyword">A</span>=<span class="keyword">A</span></span><br><span class="line">AA=<span class="keyword">A</span></span><br><span class="line">AA'=<span class="number">0</span></span><br><span class="line">AB=BA</span><br><span class="line"><span class="keyword">A</span>(BC)=(AB)C</span><br><span class="line"><span class="keyword">A</span>(B+C)=AB+AC</span><br><span class="line">(AB)'=<span class="keyword">A</span>'+B'</span><br><span class="line">(<span class="keyword">A</span>')'=<span class="keyword">A</span></span><br><span class="line"><span class="number">1</span>+<span class="keyword">A</span>=<span class="number">1</span></span><br><span class="line"><span class="number">0</span>+<span class="keyword">A</span>=<span class="keyword">A</span></span><br><span class="line"><span class="keyword">A</span>+<span class="keyword">A</span>=<span class="keyword">A</span></span><br><span class="line"><span class="keyword">A</span>+<span class="keyword">A</span>'=<span class="number">1</span></span><br><span class="line"><span class="keyword">A</span>+B=B+<span class="keyword">A</span></span><br><span class="line"><span class="keyword">A</span>+(B+C)=(<span class="keyword">A</span>+B)+C</span><br><span class="line"><span class="keyword">A</span>+BC=(<span class="keyword">A</span>+B)(<span class="keyword">A</span>+C)</span><br><span class="line">(<span class="keyword">A</span>+B)'=<span class="keyword">A</span>'B'</span><br></pre></td></tr></table></figure><h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span>+AB=<span class="keyword">A</span></span><br><span class="line"><span class="keyword">A</span>+<span class="keyword">A</span>'B=<span class="keyword">A</span>+B</span><br><span class="line">AB+AB'=<span class="keyword">A</span></span><br><span class="line"><span class="keyword">A</span>(<span class="keyword">A</span>+B)=<span class="keyword">A</span></span><br><span class="line">AB+<span class="keyword">A</span>'C+BC=AB+<span class="keyword">A</span>'C</span><br><span class="line">AB+<span class="keyword">A</span>'C+BCD=AB+<span class="keyword">A</span>'C</span><br><span class="line"><span class="keyword">A</span>(AB)'=AB'</span><br><span class="line"><span class="keyword">A</span>'(AB)'=<span class="keyword">A</span>'</span><br></pre></td></tr></table></figure><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><h3 id="代入定理"><a href="#代入定理" class="headerlink" title="代入定理"></a>代入定理</h3><p>在任何一个包含<code>A</code>的逻辑代数式中，若将该逻辑代数式中所有的<code>A</code>都替换为另一个逻辑代数式，则该逻辑代数式仍然成立。</p><h3 id="反演定理"><a href="#反演定理" class="headerlink" title="反演定理"></a>反演定理</h3><p>对于任意一个逻辑代数式<code>Y</code>，若将其中所有的<code>⋅</code>替换为<code>+</code>、<code>+</code>替换为<code>⋅</code>、<code>0</code>替换为<code>1</code>、<code>1</code>替换为<code>0</code>、<code>原变量</code>替换为<code>反变量</code>、<code>反变量</code>替换为<code>原变量</code>，则得到逻辑代数式<code>Y&#39;</code>。</p><ul><li>反演定理仍遵守<code>先()后·再+</code>的运算优先级；</li><li>不属于单个变量上的<code>&#39;</code>应保持不变。</li></ul><h3 id="对偶定理"><a href="#对偶定理" class="headerlink" title="对偶定理"></a>对偶定理</h3><p>若两逻辑代数式相等，则其对偶式也相等。</p><ul><li>对偶式的定义：对于任意一个逻辑代数式<code>Y</code>，若将其中所有的<code>·</code>替换为<code>+</code>、<code>+</code>替换为<code>·</code>、<code>0</code>替换为<code>1</code>、<code>1</code>替换为<code>0</code>，则得到逻辑代数式<code>Y</code>的对偶式。</li></ul><hr><p>本文参考自</p><p><a href="https://www.cnblogs.com/xianyufpga/p/13263600.html" target="_blank" rel="noopener">数电（2）：逻辑代数的基本定理</a></p>]]></content>
      
      
      <categories>
          
          <category> 数字电子技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——继承与覆盖（三）</title>
      <link href="/2020/12/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/12/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>一些关于抽象类的笔记（´Д`）。</p><a id="more"></a><h2 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h2><ul><li>包含有抽象方法的类即为抽象类，抽象类必须有关键字<code>abstract</code>修饰；</li><li>抽象类的访问权限必须为<code>public</code>或<code>protected</code>，在没有访问权限关键字修饰时默认为<code>public</code>；</li><li>抽象类必须要有子类使用<code>extends</code>继承，并且<strong>一个子类只能继承一个抽象类</strong>；</li><li>若某抽象类的子类不为抽象类，则必须重写父类中<strong>所有</strong>的抽象方法；</li><li>若某抽象类的子类没有实现父类的抽象方法，则必须将该子类也定义为抽象类；</li><li>抽象类不能直接实例化对象，<strong>必须通过子类（子类为非抽象类）采用向上转型的方式处理</strong>；</li><li>抽象类不能使用关键字<code>final</code>声明；</li><li>外部抽象类不允许使用关键字<code>static</code>声明，而内部抽象类允许使用关键字<code>static</code>声明；</li><li>可直接调用抽象类中使用关键字<code>static</code>声明的方法而不需要实例化对象。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>抽象方法只有声明而没有具体的实现，即没有方法体；定义抽象方法时必须使用关键字<code>abstract</code>修饰。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><h3 id="抽象类的最基础的使用"><a href="#抽象类的最基础的使用" class="headerlink" title="抽象类的最基础的使用"></a>抽象类的最基础的使用</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person0</span><span class="comment">//定义一个抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OUTPUT0</span>(<span class="params"></span>)<span class="comment">//一般方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"NIMITIZ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OUTPUT1</span>(<span class="params"></span>)</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person1</span> <span class="title">extends</span> <span class="title">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OUTPUT1</span>(<span class="params"></span>)<span class="comment">//必须要重写父类中所有的抽象方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PRACTICE0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Person0 P0=<span class="keyword">new</span> Person1();<span class="comment">//向上转型</span></span><br><span class="line">        P0.OUTPUT1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h3 id="抽象类中的构造方法"><a href="#抽象类中的构造方法" class="headerlink" title="抽象类中的构造方法"></a>抽象类中的构造方法</h3><p>为了对抽象类中的成员进行初始化，抽象类中必定存在构造方法；并且在实例化子类对象时依然先执行父类的构造方法，再执行子类的构造方法。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person0</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Person0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OUTPUT</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person1</span> <span class="title">extends</span> <span class="title">Person0</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Person1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OUTPUT</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PRACTICE1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Person0 P0=<span class="keyword">new</span> Person1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">Perso<span class="symbol">n0</span></span><br><span class="line">Perso<span class="symbol">n1</span></span><br></pre></td></tr></table></figure><h3 id="使用关键字static声明内部抽象类"><a href="#使用关键字static声明内部抽象类" class="headerlink" title="使用关键字static声明内部抽象类"></a>使用关键字static声明内部抽象类</h3><p>使用关键字<code>static</code>声明的内部抽象类相当于一个外部抽象类，在被继承的时候，使用<code>&lt;外部抽象类名&gt;.&lt;内部抽象类名&gt;</code>来表示类名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person0</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span>//该内部抽象类相当于一个外部抽象类</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">extends</span> <span class="title">Person0</span>.<span class="title">Person1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person0.Person1 P01=<span class="keyword">new</span> Person2();</span><br><span class="line">        P01.OUTPUT();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h3 id="直接调用关键字static声明的方法"><a href="#直接调用关键字static声明的方法" class="headerlink" title="直接调用关键字static声明的方法"></a>直接调用关键字static声明的方法</h3><p>在任何情况下，都可直接调用类（不限于抽象类）中由关键字<code>static</code>声明的方法而不需要实例化对象。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person.<span class="literal">OUTPUT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><hr><p>整理自</p><p><a href="https://blog.csdn.net/wei_zhi/article/details/52736350" target="_blank" rel="noopener">Java抽象类 详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——类与对象（四）</title>
      <link href="/2020/12/14/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/12/14/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>初学者つ﹏⊂，简单记录一下<code>this</code>关键字的部分用法。</p><a id="more"></a><h2 id="引用当前类的实例变量"><a href="#引用当前类的实例变量" class="headerlink" title="引用当前类的实例变量"></a>引用当前类的实例变量</h2><p>若实例变量与形参之间存在歧义，则可使用<code>this</code>关键字解决歧义。</p><h3 id="不使用this关键字的情况"><a href="#不使用this关键字的情况" class="headerlink" title="不使用this关键字的情况"></a>不使用this关键字的情况</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">String</span> name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        name=name;</span><br><span class="line">        age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">" age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person P0=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ"</span>,<span class="number">18</span>);</span><br><span class="line">        Person P1=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ-FBH"</span>,<span class="number">19</span>);</span><br><span class="line">        P0.<span class="literal">OUTPUT</span>();</span><br><span class="line">        P1.<span class="literal">OUTPUT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="literal">null</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">name:</span> <span class="literal">null</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="使用this关键字的情况"><a href="#使用this关键字的情况" class="headerlink" title="使用this关键字的情况"></a>使用this关键字的情况</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">String</span> name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">" age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person P0=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ"</span>,<span class="number">18</span>);</span><br><span class="line">        Person P1=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ-FBH"</span>,<span class="number">19</span>);</span><br><span class="line">        P0.<span class="literal">OUTPUT</span>();</span><br><span class="line">        P1.<span class="literal">OUTPUT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ-FBH</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="调用当前类的一般方法"><a href="#调用当前类的一般方法" class="headerlink" title="调用当前类的一般方法"></a>调用当前类的一般方法</h2><p>可以使用<code>this</code>关键字调用当前类的一般方法；若调用当前类的一般方法时没有在源码中使用<code>this</code>关键字，Java编译器将会自动提供<code>this</code>关键字。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOWORLD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x();        <span class="comment">// x(); 等同于 this.x(); </span></span><br><span class="line">        <span class="keyword">this</span>.x();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HELLOWORLD HW=<span class="keyword">new</span> HELLOWORLD();</span><br><span class="line">        HW.y();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h2 id="调用当前类的构造方法"><a href="#调用当前类的构造方法" class="headerlink" title="调用当前类的构造方法"></a>调用当前类的构造方法</h2><p>构造方法是类在实例化对象时自动调用的，不能如调用一般方法那样通过方法名或类名来调用；但如果一个类包含有多个构造方法，则可以在一个构造方法中通过<code>this</code>关键字来调用其他构造方法。</p><ul><li><strong>只能在构造方法中</strong>通过<code>this</code>关键字来调用其他构造方法，不能在一般方法中通过<code>this</code>关键字来调用构造方法</li><li>不能在一个构造方法中通过<code>this</code>关键字直接或间接地调用该构造方法本身</li><li><strong>对<code>this</code>关键字的调用必须是构造器中的第一个语句</strong></li><li>不能在一个构造方法中同时使用关键字<code>this</code>和<code>super</code>调用其他构造方法（因为对<code>super</code>关键字的调用也必须是构造器中的第一个语句）</li><li><strong>不能在一个构造方法中多次调用不同的构造方法</strong></li><li>在构造方法中可以使用<code>this</code>关键字来调用本类的成员变量和成员方法，其用法与非构造方法中的<code>this</code>关键字相同</li></ul><h3 id="在有参构造方法中调用无参构造方法"><a href="#在有参构造方法中调用无参构造方法" class="headerlink" title="在有参构造方法中调用无参构造方法"></a>在有参构造方法中调用无参构造方法</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOWORLD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HELLOWORLD()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Hello,world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HELLOWORLD(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>();     <span class="comment">//在有参构造方法中调用无参构造方法      对this的调用必须是构造器中的第一个语句</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HELLOWORLD HW=<span class="keyword">new</span> HELLOWORLD(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Hello,world!</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="在无参构造方法中调用有参构造方法"><a href="#在无参构造方法中调用有参构造方法" class="headerlink" title="在无参构造方法中调用有参构造方法"></a>在无参构造方法中调用有参构造方法</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOWORLD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HELLOWORLD(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    HELLOWORLD()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">18</span>);       <span class="comment">//在无参构造方法中调用有参构造方法      对this的调用必须是构造器中的第一个语句</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HELLOWORLD HW=<span class="keyword">new</span> HELLOWORLD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h3 id="重用构造方法"><a href="#重用构造方法" class="headerlink" title="重用构造方法"></a>重用构造方法</h3><p><code>this()</code>构造方法调用可用于重用构造方法。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    Person(<span class="keyword">String</span> name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">String</span> name,<span class="keyword">int</span> age,<span class="keyword">char</span> sex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>(name,age);     <span class="comment">//重用构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OUTPUT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">" age: "</span>+age);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">" sex: "</span>+sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person P0=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ"</span>,<span class="number">18</span>);</span><br><span class="line">        P0.<span class="literal">OUTPUT</span>();</span><br><span class="line">        Person P1=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ"</span>,<span class="number">18</span>,<span class="string">'M'</span>);</span><br><span class="line">        P1.<span class="literal">OUTPUT</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"> <span class="attr">sex:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"> <span class="attr">sex:</span> <span class="string">M</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>this</code>关键字访问成员变量和成员方法时不受访问权限的限制，可以访问本类中所有的成员变量和成员方法。</p><hr><p>整理自</p><p><a href="http://www.yiidian.com/java/java-this-keyword.html" target="_blank" rel="noopener">Java this关键字</a></p><p><a href="https://blog.csdn.net/ccpat/article/details/44515335" target="_blank" rel="noopener">Java this 关键字用法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——类与对象（三）</title>
      <link href="/2020/12/07/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/12/07/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下Java的部分构造方法（〃′o`）。</p><a id="more"></a><h2 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h2><p>Java中的构造方法，也被称作构造函数，可分为无参构造方法和有参构造方法，一般用来初始化成员属性和成员方法。当对象被实例化后，构造方法就给对象初始化，且一个对象被实例化后，<strong>构造方法只被调用一次</strong>，而一般的方法可被该对象多次调用。</p><ul><li>构造方法名与类名相同；</li><li>构造方法不需要定义返回值类型，也不能包含有<code>return</code>语句；</li><li>一般方法不能调用构造方法，只有构造方法才能调用构造方法；</li><li>类中必有构造方法，若源文件中没有指定任何构造函数，Java编译器提供一个无参构造方法；</li><li>构造方法不能被<code>static</code>、<code>final</code>、<code>synchronized</code>、<code>abstract</code>和<code>native</code>修饰；</li><li>构造方法可以被重载；</li><li>构造方法在初始化对象时自动执行，一般不能直接调用；</li><li>当同一个类中存在多种构造方法时，编译器自动根据参数列表一一对应来调用构造方法。</li></ul><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>类中只定义一个无参构造方法；构造方法总伴随着对象的实例化一起被调用。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Person()        <span class="comment">//定义无参构造方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Hello,world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person P=<span class="keyword">new</span> Person();      <span class="comment">//实例化对象时，就会调用对应的构造方法Person()并执行其中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello,</span>world!</span><br></pre></td></tr></table></figure><p>有参构造方法，在实例化对象时，将实参传递给成员变量。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">String</span> x,<span class="keyword">int</span> y)      <span class="comment">//定义有参构造方法，给成员变量传递参数值，然后直接输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        name=x;</span><br><span class="line">        age=y;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person P=<span class="keyword">new</span> Person(<span class="string">"NIMITIZ"</span>,<span class="number">18</span>);      <span class="comment">//实例化对象时，直接调用有参构造方法并传递实参，同时执行其中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>一个对象建立后，构造方法只被调用一次；如果需要给对象再赋新值，就需要使用<code>set</code>和<code>get</code>方法。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="constructor">Person(String <span class="params">x</span>,<span class="params">int</span> <span class="params">y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name=x;</span><br><span class="line">        age=y;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"name: "</span>+name);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void set<span class="constructor">Name(String <span class="params">m</span>)</span>       <span class="comment">//set方法，用于再次给name赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        name=m;</span><br><span class="line">    &#125;</span><br><span class="line">    public String get<span class="constructor">Name()</span>     <span class="comment">//get方法，用于获取name的赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">class</span> Person2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person P=<span class="keyword">new</span> <span class="constructor">Person(<span class="string">"NIMITIZ"</span>,18)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">P</span>.</span></span>set<span class="constructor">Name(<span class="string">"NIMITIZ_FBH"</span>)</span>;       <span class="comment">//调用set方法</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">P</span>.</span></span>get<span class="constructor">Name()</span>);        <span class="comment">//调用get方法并输出赋值</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">P</span>.</span></span>set<span class="constructor">Name(<span class="string">"FBH_NIMITIZ"</span>)</span>;       <span class="comment">//可多次调用</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">P</span>.</span></span>get<span class="constructor">Name()</span>);        <span class="comment">//可多次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="string">NIMITIZ_FBH</span></span><br><span class="line"><span class="string">FBH_NIMITIZ</span></span><br></pre></td></tr></table></figure><p>构造方法也是方法的一种，也具备方法的重载特性。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="constructor">Person()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"A:  name: "</span>+name);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"     age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">Person(String <span class="params">name</span>,<span class="params">int</span> <span class="params">age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"B:  name: "</span>+name);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"     age: "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">Person(<span class="params">int</span> <span class="params">age</span>,String <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"C:   age: "</span>+age);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"    name: "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">class</span> Person3</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args)      <span class="comment">//不能都实例化为同一对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person P1=<span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line">        Person P2=<span class="keyword">new</span> <span class="constructor">Person(<span class="string">"NIMITIZ"</span>,18)</span>;</span><br><span class="line">        Person P3=<span class="keyword">new</span> <span class="constructor">Person(18,<span class="string">"NIMITIZ"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">A:  name:</span> <span class="literal">null</span></span><br><span class="line">     <span class="attr">age:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">B:  name:</span> <span class="string">NIMITIZ</span></span><br><span class="line">     <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">C:   age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">NIMITIZ</span></span><br></pre></td></tr></table></figure><p>子类不会继承父类的构造方法，只是必须显式或隐式地调用。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//隐式调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    Person0()</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"NIMITIZ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Person0(<span class="built_in">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Person1</span> <span class="symbol">extends</span> <span class="symbol">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Person1()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Person1(<span class="built_in">int</span> x)<span class="comment">//①</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//super();执行 System.out.println(18); 时优先调用父类的无参构造方法super()</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person1 P1=new Person1(<span class="number">19</span>);<span class="comment">//调用①</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">NIMITIZ</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    Person0()</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"NIMITIZ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Person0(<span class="built_in">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Person1</span> <span class="symbol">extends</span> <span class="symbol">Person0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Person1()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Person1(<span class="built_in">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">19</span>);<span class="comment">//显式调用父类的有参构造方法后，不再默认调用无参构造方法</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person1 P1=new Person1(<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><ul><li>如果父类没有无参构造方法，创建子类时必须在子类有参构造方法的第一行显式调用父类的有参构造方法；</li><li>如果父类没有有参构造方法，那么在创建子类时可以不显式调用父类的构造方法，这时会默认调用父类的无参构造方法<code>super()</code>；</li></ul><h2 id="Java构造方法与一般方法的区别"><a href="#Java构造方法与一般方法的区别" class="headerlink" title="Java构造方法与一般方法的区别"></a>Java构造方法与一般方法的区别</h2><table><thead><tr><th align="center">构造方法</th><th align="center">一般方法</th></tr></thead><tbody><tr><td align="center">构造方法用于初始化对象的成员属性和成员方法</td><td align="center">一般方法用于表示对象的行为</td></tr><tr><td align="center">构造方法不能拥有返回类型</td><td align="center">一般方法一般拥有返回类型</td></tr><tr><td align="center">构造方法隐式调用</td><td align="center">一般方法显式调用</td></tr><tr><td align="center">如果没有指定任何构造方法，Java编译器提供一个无参构造方法</td><td align="center">在任何情况下Java编译器都不提供默认的一般方法调用</td></tr><tr><td align="center">构造方法名必须与类名相同</td><td align="center">一般方法名可以不与类名相同</td></tr></tbody></table><hr><p>整理自</p><p><a href="https://aerchi.blog.csdn.net/article/details/90759744" target="_blank" rel="noopener">JAVA构造函数(方法)</a></p><p><a href="https://blog.csdn.net/sdjadycsdn/article/details/81559475" target="_blank" rel="noopener">Java中的构造方法</a></p><p><a href="https://blog.csdn.net/li_jeremy/article/details/79294699" target="_blank" rel="noopener">java学习—构造器（构造方法）</a></p><p><a href="https://www.jianshu.com/p/f7934687e420" target="_blank" rel="noopener">java中继承,子类是否继承父类的构造函数</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——继承与覆盖（二）</title>
      <link href="/2020/12/04/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/12/04/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下Java的重写与重载(<em>/ω＼</em>)。</p><a id="more"></a><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>Java重写是在子类中定义方法，其与父类某方法的命名、参数列表和返回类型完全相同。重写的好处在于子类可以根据需要，定义特定于自己的方法。</p><h3 id="重写的规则"><a href="#重写的规则" class="headerlink" title="重写的规则"></a>重写的规则</h3><ul><li>参数列表（参数个数、参数顺序）、返回值类型必须与被重写的方法完全相同；</li><li>访问级别不能比父类中被重写的方法有更严格的限制；</li><li>父类的方法只能被其子类重写；</li><li>声明为<code>final</code>的方法不能被重写；</li><li>声明为<code>static</code>的方法不能被重写，但能被再次声明；</li><li>当子类和父类在同一个包中时，子类可以重写父类除了声明为<code>private</code>和<code>final</code>外的所有方法；</li><li>当子类和父类不在同一个包中时，子类只能重写父类声明为<code>public</code>和<code>protected</code>的方法；</li><li>如果不能继承一个方法，则不能重写这个方法；</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常；但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以；</li><li>构造方法不能被重写。</li></ul><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="title">extends</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo0 d0=<span class="keyword">new</span> demo0();</span><br><span class="line">        demo1 d1=<span class="keyword">new</span> demo1();</span><br><span class="line">        d0.tags();</span><br><span class="line">        d1.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">dem<span class="meta">o0</span></span><br><span class="line">dem<span class="meta">o1</span></span><br></pre></td></tr></table></figure><h3 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h3><p>当需要在子类中调用父类的被重写的方法时，就要使用关键字<code>super</code>。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="title">extends</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo1"</span>);</span><br><span class="line">        super.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo1 d1=<span class="keyword">new</span> demo1();</span><br><span class="line">        d1.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">dem<span class="meta">o1</span></span><br><span class="line">dem<span class="meta">o0</span></span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>Java重载就是使类以相同的方法处理不同的参数，其在一个类中，方法名字相同，而参数列表不同，返回值可以相同也可不同。</p><h3 id="重载的规则"><a href="#重载的规则" class="headerlink" title="重载的规则"></a>重载的规则</h3><ul><li>方法的参数列表（参数个数、参数顺序）必须不同；</li><li>方法的返回值类型可以相同也可不同；</li><li>方法可以改变访问修饰符；</li><li>方法能在同一个类或在一个子类中被重载；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>不能以返回值类型作为重载的标准。</li></ul><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">String</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">demo</span><span class="params">(<span class="keyword">String</span> y,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Overload O=<span class="keyword">new</span> Overload();</span><br><span class="line">        O.demo();</span><br><span class="line">        O.demo(<span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(O.demo(<span class="number">1</span>,<span class="string">"NIMITIZ"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>(O.demo(<span class="string">"NIMITIZ"</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">dem<span class="meta">o0</span></span><br><span class="line">dem<span class="meta">o1</span></span><br><span class="line">dem<span class="meta">o2</span></span><br><span class="line">test<span class="number">0</span></span><br><span class="line">dem<span class="meta">o3</span></span><br><span class="line">test<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center"></th><th align="center">重写</th><th align="center">重载</th></tr></thead><tbody><tr><td align="center"><strong>参数列表</strong></td><td align="center">一定不能修改</td><td align="center">必须修改</td></tr><tr><td align="center"><strong>返回值类型</strong></td><td align="center">一定不能修改</td><td align="center">可以修改</td></tr><tr><td align="center"><strong>异常</strong></td><td align="center">可以减少或删除，一定不能出现新的或更广的异常</td><td align="center">可以修改</td></tr><tr><td align="center"><strong>访问级别</strong></td><td align="center">可以降低限制，但一定不能做更严格的限制</td><td align="center">可以修改</td></tr></tbody></table><hr><p>如有错误，请在评论区留言，非常感谢(′▽`〃)。</p><p>本文整理自</p><p><a href="https://www.w3cschool.cn/java/java-override-overload.html" target="_blank" rel="noopener">Java 重写(Override)与重载(Overload)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——继承与覆盖（一）</title>
      <link href="/2020/12/04/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/12/04/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Java中的继承是一种机制，表示为一个对象获取父对象的所有属性和行为。在Java的继承中，可以基于现有类构建新的类，当从现有类继承时，可以重复使用父类的方法和字段，也可以在继承的新类中添加新的方法和字段。在Java中，继承的类称为父类或超类，新类称为子类。在类的基础上，Java可以有三种类型的继承：单一继承、多级继承和分层继承，仅能通过接口支持多重继承和混合继承。</p><a id="more"></a><h2 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h2><p><img src="/images/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF.png" alt></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件PRACTICE0.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tags0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="title">extends</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tags1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"demo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo1 d1=<span class="keyword">new</span> demo1();</span><br><span class="line">        d1.tags0();</span><br><span class="line">        d1.tags1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">dem<span class="meta">o0</span></span><br><span class="line">dem<span class="meta">o1</span></span><br></pre></td></tr></table></figure><h2 id="多级继承"><a href="#多级继承" class="headerlink" title="多级继承"></a>多级继承</h2><p><img src="/images/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%80%EF%BC%89/%E5%A4%9A%E7%BA%A7%E7%BB%A7%E6%89%BF.png" alt></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件PRACTICE1.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags0()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo2</span> <span class="keyword">extends</span> <span class="title">demo1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        demo2 d2=<span class="keyword">new</span> demo2();</span><br><span class="line">        d2.tags0();</span><br><span class="line">        d2.tags1();</span><br><span class="line">        d2.tags2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">dem<span class="meta">o0</span></span><br><span class="line">dem<span class="meta">o1</span></span><br><span class="line">dem<span class="meta">o2</span></span><br></pre></td></tr></table></figure><h2 id="分层继承"><a href="#分层继承" class="headerlink" title="分层继承"></a>分层继承</h2><p><img src="/images/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%A6%86%E7%9B%96%EF%BC%88%E4%B8%80%EF%BC%89/%E5%88%86%E5%B1%82%E7%BB%A7%E6%89%BF.png" alt></p><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件PRACTICE2.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span> <span class="keyword">extends</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags0()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        demo1 d1=<span class="keyword">new</span> demo1();</span><br><span class="line">        d1.tags();</span><br><span class="line">        d1.tags1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">demo</span><br><span class="line">dem<span class="meta">o1</span></span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件PRACTICE2.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo0</span> <span class="keyword">extends</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags0()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    void tags1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"demo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PRACTICE2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        demo1 d1=<span class="keyword">new</span> demo1();</span><br><span class="line">        d1.tags();</span><br><span class="line">        d1.tags0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">PRACTICE2</span><span class="selector-class">.java</span><span class="selector-pseudo">:28</span>: 错误: 找不到符号</span><br><span class="line">        <span class="selector-tag">d1</span><span class="selector-class">.tags0</span>();</span><br><span class="line">          ^</span><br><span class="line">  符号:   方法 <span class="selector-tag">tags0</span>()</span><br><span class="line">  位置: 类型为<span class="selector-tag">demo1</span>的变量 <span class="selector-tag">d1</span></span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>因为子类<code>demo1</code>和另一子类<code>demo0</code>分层继承自父类<code>demo</code>，所以<code>demo1</code>不能使用<code>demo0</code>中的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——类与对象（二）</title>
      <link href="/2020/12/03/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/12/03/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h2><p>为了更好地组织和管理类，Java提供了包机制，用于区别类名的命名空间。</p><a id="more"></a><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ul><li>把功能相似或相关的类或接口组织在同一包中，方便查找和使用；</li><li>包采用树形目录的存储方式，同一包中的类名不同，不同的包中的类名可以相同，包可以避免命名冲突；</li><li>包限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><p>在Java中，包的使用需要用到包封装语句<code>package</code>和包导入语句<code>import</code>。</p><h3 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h3><p><code>package</code>语句的含义是将源文件中定义的所有类放在同一文件夹中；格式如下：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">&lt;包名&gt;;</span></span><br></pre></td></tr></table></figure><p><code>&lt;包名&gt;</code>可以是字符串，也可以由多个字符串通过<code>.</code>连接起来。</p><p>例如：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">nimitiz;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="title">cn.nimitiz;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>包的声明只能位于Java源文件的第一行，每个源文件只能有一个包声明；</li><li>包名的所有字母必须小写，同时不能包含特殊字符；</li><li>Java解释器会将包名中的<code>.</code>解释为目录分隔符（Windows下目录分隔符为<code>\</code>）；</li><li>如果源文件中没有包声明，那么其中的类、接口等将被保存到一个默认的包<code>java.lang</code>中。</li></ul><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>创建一个Java源文件<code>demo0.java</code></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package cn.nimitiz;<span class="comment">//demo0.java的相对路径为./cn/nimitiz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name+<span class="string">""</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>如果要使用某一包中的成员，需要在Java源文件中使用<code>import语句</code>导入该包。</p><ul><li>一个Java源文件中可以有多个<code>import语句</code>，必须写在<code>package语句</code>之后，且在类定义之前；</li><li>如果一个Java源文件没有使用<code>import语句</code>，编译器将自动引入默认的包<code>java.lang</code></li></ul><h4 id="引入包中的某个类"><a href="#引入包中的某个类" class="headerlink" title="引入包中的某个类"></a>引入包中的某个类</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> &lt;包名&gt;.&lt;类名&gt;;</span></span><br></pre></td></tr></table></figure><p>例如，引入包<code>cn.nimitiz</code>中的类<code>demo0</code>：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.nimitiz.demo0;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo0 d=<span class="keyword">new</span> demo0();</span><br><span class="line">        d.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">        d.age=<span class="number">18</span>;</span><br><span class="line">        d.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入包中的所有类"><a href="#引入包中的所有类" class="headerlink" title="引入包中的所有类"></a>引入包中的所有类</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> &lt;包名&gt;.*;</span></span><br></pre></td></tr></table></figure><p>例如，引入包<code>cn.nimitiz</code>中的所有类：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.nimitiz.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo0 d=<span class="keyword">new</span> demo0();</span><br><span class="line">        d.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">        d.age=<span class="number">18</span>;</span><br><span class="line">        d.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>Java中有四种访问级别：<code>private</code>、<code>default（默认方式，不带任何修饰符）</code>、<code>protected</code>、<code>public</code>。</p><ul><li><code>private</code>：被其修饰的属性和方法只能被该类的对象访问，其子类不能访问，更不允许跨包访问</li><li><code>default</code>：只允许在同一包中访问</li><li><code>protected</code>：被其修饰的属性和方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问</li><li><code>public</code>：被其修饰的类、属性和方法不仅可以跨类访问，而且允许跨包访问</li></ul><table><thead><tr><th align="center"></th><th align="center">同一类</th><th align="center">同一包</th><th align="center">不同包的子类</th><th align="center">不同包的非子类</th></tr></thead><tbody><tr><td align="center"><strong>public</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center"><strong>protected</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✘</td></tr><tr><td align="center"><strong>默认方式（default）</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✘</td><td align="center">✘</td></tr><tr><td align="center"><strong>private</strong></td><td align="center">✔</td><td align="center">✘</td><td align="center">✘</td><td align="center">✘</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对51单片机中断的整理（非全部）</title>
      <link href="/2020/11/13/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/"/>
      <url>/2020/11/13/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>先整理记录外部中断和定时器中断(っ・Д・)っ。</p><a id="more"></a><p>单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a></p><p><img src="/images/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/MCU.png" alt></p><p><img src="/images/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/LED%E6%A8%A1%E5%9D%97.png" alt></p><p><img src="/images/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE.png" alt></p><h2 id="相关的特殊功能寄存器"><a href="#相关的特殊功能寄存器" class="headerlink" title="相关的特殊功能寄存器"></a>相关的特殊功能寄存器</h2><h3 id="定时器控制寄存器TCON"><a href="#定时器控制寄存器TCON" class="headerlink" title="定时器控制寄存器TCON"></a>定时器控制寄存器TCON</h3><table><thead><tr><th>位</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>IT0</td><td>外部中断0触发方式选择位。置0，则为低电平触发；置1，则为负跳变触发。</td></tr><tr><td>1</td><td>IE0</td><td>外部中断0请求标志位。</td></tr><tr><td>2</td><td>IT1</td><td>外部中断1触发方式选择位。置0，则为低电平触发；置1，则为负跳变触发。</td></tr><tr><td>3</td><td>IE1</td><td>外部中断1请求标志位。</td></tr><tr><td>4</td><td>TR0</td><td>定时器0运行控制位。软件置1来启动定时器；软件清零来停止定时器。</td></tr><tr><td>5</td><td>TF0</td><td>定时器0中断标志位。</td></tr><tr><td>6</td><td>TR1</td><td>定时器1运行控制位。软件置1来启动定时器；软件清零来停止定时器。</td></tr><tr><td>7</td><td>TF1</td><td>定时器1中断标志位。</td></tr></tbody></table><h3 id="中断允许寄存器IE"><a href="#中断允许寄存器IE" class="headerlink" title="中断允许寄存器IE"></a>中断允许寄存器IE</h3><table><thead><tr><th align="center">位</th><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">EX0</td><td align="center">外部中断0允许位。</td></tr><tr><td align="center">1</td><td align="center">ET0</td><td align="center">定时器中断0允许位。</td></tr><tr><td align="center">2</td><td align="center">EX1</td><td align="center">外部中断1允许位。</td></tr><tr><td align="center">3</td><td align="center">ET1</td><td align="center">定时器中断1允许位。</td></tr><tr><td align="center">4</td><td align="center">ES</td><td align="center">串口中断允许位。</td></tr><tr><td align="center">5</td><td align="center">/</td><td align="center">/</td></tr><tr><td align="center">6</td><td align="center">/</td><td align="center">/</td></tr><tr><td align="center">7</td><td align="center">EA</td><td align="center">中断总允许位。</td></tr></tbody></table><h3 id="定时器模式寄存器TMOD"><a href="#定时器模式寄存器TMOD" class="headerlink" title="定时器模式寄存器TMOD"></a>定时器模式寄存器TMOD</h3><h4 id="TMOD的位分配"><a href="#TMOD的位分配" class="headerlink" title="TMOD的位分配"></a>TMOD的位分配</h4><p><strong>注：</strong>标有<code>T1</code>的符号表示控制定时器<code>T1</code>的位，标有<code>T0</code>的符号表示控制定时器<code>T0</code>的位。</p><table><thead><tr><th align="center">位</th><th align="center">符号</th><th align="center">复位值</th></tr></thead><tbody><tr><td align="center">7</td><td align="center">GATE(T1)</td><td align="center">0</td></tr><tr><td align="center">6</td><td align="center">C/T(T1)</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">M1(T1)</td><td align="center">0</td></tr><tr><td align="center">4</td><td align="center">M0(T1)</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">GATE(T0)</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">C/T(T0)</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">M1(T0)</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">M0(T0)</td><td align="center">0</td></tr></tbody></table><h4 id="TMOD的位描述"><a href="#TMOD的位描述" class="headerlink" title="TMOD的位描述"></a>TMOD的位描述</h4><table><thead><tr><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GATE</td><td align="center">门控位。当GATE=0时，只要TCON中的TR0或TR1为1，就能启动相应的定时器/计数器；当GATE=1时，只要TCON中的TR0或TR1为1，且外部中断引脚INT0或INT1为高电平时，才能启动相应的定时器/计数器。</td></tr><tr><td align="center">C/T</td><td align="center">定时器/计数器模式选择位。C/T=0为定时器模式；C/T=1为计数器模式。</td></tr></tbody></table><h4 id="TMOD的M1、M0和工作模式"><a href="#TMOD的M1、M0和工作模式" class="headerlink" title="TMOD的M1、M0和工作模式"></a>TMOD的M1、M0和工作模式</h4><table><thead><tr><th align="center">M1</th><th align="center">M0</th><th align="center">工作模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">兼容8048单片机的13位定时器。</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">THn和TLn组成一个16位的定时器。</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">8位自动重装载模式，定时器溢出后把THn重装载到TLn。</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">禁用定时器<code>T1</code>，定时器<code>T0</code>变成两个8位定时器。</td></tr></tbody></table><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>STC89C52有两个外部中断源——外部中断0和外部中断1，分别由引脚<code>INT0（P3.2）</code>和<code>INT1（P3.3）</code>的低电平或负跳变触发。</p><p><img src="/images/%E5%AF%B951%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%95%B4%E7%90%86%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/MCU.png" alt></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>要使用外部中断，需要对<strong>IE</strong>和<strong>TCON</strong>这两个特殊功能寄存器进行初始化操作：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 开启中断总允许位EA</span><br><span class="line"><span class="number">2.</span> 开启外部中断允许位EX</span><br><span class="line"><span class="number">3.</span> 设置外部中断触发方式</span><br></pre></td></tr></table></figure><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">sbit D8=P2^<span class="number">7</span>;</span><br><span class="line">sbit K5=P3^<span class="number">5</span>;</span><br><span class="line">sbit x=P3^<span class="number">2</span>;<span class="comment">//把触发外部中断0的引脚定义为x</span></span><br><span class="line"><span class="built_in">void</span> Delay10ms()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i=<span class="number">20</span>,j=<span class="number">113</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Interrupt()<span class="comment">//对相关的特殊功能寄存器进行初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开启中断总允许位EA</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//开启外部中断0允许位EX0</span></span><br><span class="line">IT0=<span class="number">1</span>;<span class="comment">//设置外部中断0的触发方式为负跳变触发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Int0() <span class="built_in">int</span>errupt <span class="number">0</span><span class="comment">//定义外部中断0的中断函数Int0，“interrupt”后的“0”为中断号</span></span><br><span class="line">&#123;</span><br><span class="line">D8=~D8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> Key=<span class="number">0</span>;</span><br><span class="line">  Interrupt();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(K5==<span class="number">0</span>&amp;&amp;Key==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delay10ms();</span><br><span class="line">            Key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(K5==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">1</span>;<span class="comment">//产生负跳变信号</span></span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K5==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Key=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：初次按下独立按键<code>K5</code>，LED<code>D8</code>亮；再次按下独立按键<code>K5</code>，LED<code>D8</code>灭。</p><h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>当定时器的计数值溢出时，就能够触发定时器中断。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>要使用定时器中断，需要对<strong>TCON</strong>、<strong>IE</strong>和<strong>TMOD</strong>这三个特殊功能寄存器进行初始化操作：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 开启中断总允许位EA</span><br><span class="line"><span class="number">2.</span> 开启定时器中断允许位ET</span><br><span class="line"><span class="number">3.</span> 设置定时器的工作模式</span><br><span class="line"><span class="number">4.</span> 确定THn和TLn的初值</span><br><span class="line"><span class="number">5.</span> 开启定时器</span><br></pre></td></tr></table></figure><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">sbit D8=P2^<span class="number">7</span>;</span><br><span class="line"><span class="built_in">void</span> Time0()<span class="comment">//对相关的特殊功能寄存器进行初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开启中断总允许位EA</span></span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">//开启定时器中断允许位ET0</span></span><br><span class="line">TMOD=<span class="number">1</span>;<span class="comment">//设置定时器T0的工作模式为1</span></span><br><span class="line">TH0=<span class="number">0xB8</span>;<span class="comment">//对TH0和TL0赋初值</span></span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">//开启定时器T0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Timeinterrupt0() <span class="built_in">int</span>errupt <span class="number">1</span><span class="comment">//定义触发定时器中断0的中断函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line">TH0=<span class="number">0xB8</span>;</span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">D8=~D8;</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">Time0();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：开发板上编号为<code>D8</code>的LED以先点亮1秒后熄灭1秒的规律来循环亮灭。</p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><table><thead><tr><th align="center">中断源</th><th align="center">中断号</th></tr></thead><tbody><tr><td align="center">外部中断0</td><td align="center">0</td></tr><tr><td align="center">定时器中断0</td><td align="center">1</td></tr><tr><td align="center">外部中断1</td><td align="center">2</td></tr><tr><td align="center">定时器中断1</td><td align="center">3</td></tr><tr><td align="center">串口中断</td><td align="center">4</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机程序（独立按键）</title>
      <link href="/2020/11/05/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%EF%BC%89/"/>
      <url>/2020/11/05/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下(#／。＼#)。</p><a id="more"></a><p>单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a></p><p><img src="/images/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%EF%BC%89/LED%E6%A8%A1%E5%9D%97.png" alt></p><p><img src="/images/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%EF%BC%89/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE.png" alt></p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">sbit K5=P3^<span class="number">5</span>;</span><br><span class="line">sbit D8=P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> Delay10ms()<span class="comment">//延时10ms</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">i=<span class="number">20</span>;</span><br><span class="line">j=<span class="number">113</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(--j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> Key=<span class="number">0</span>;<span class="comment">//定义一个标志位，变量Key的值置0，表示按键处于松开状态</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(K5==<span class="number">0</span>&amp;&amp;Key==<span class="number">0</span>)<span class="comment">//判断按键是否被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms();<span class="comment">//延时消抖</span></span><br><span class="line">Key=<span class="number">1</span>;<span class="comment">//把标志位置1，防止程序循环执行</span></span><br><span class="line"><span class="keyword">if</span>(K5==<span class="number">0</span>)<span class="comment">//再次判断按键状态，排除干扰</span></span><br><span class="line">&#123;</span><br><span class="line">D8=~D8;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(K5==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key=<span class="number">0</span>;<span class="comment">//当按键没有被按下时，重置标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>按下独立按键<code>K5</code>，LED<code>D8</code>亮；再次按下<code>K5</code>，<code>D8</code>灭。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>开发板上的按键由于机械触点的弹性作用，当按下按键时机械触点并不会立刻稳定闭合，松开按键时机械触点也不会立刻稳定断开，因此在按下或松开按键的瞬间（在大约10ms内）电位会有一定的波动（或者叫做抖动）；软件消抖就是当检测到按键状态发生变化后，先延时大约10ms待电位稳定后，再进行一次检测，如果仍然保持闭合状态的电位，则确认为按键真正被按下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmstat命令笔记</title>
      <link href="/2020/11/03/vmstat%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/11/03/vmstat%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>vmstat是一个可对Linux的虚拟内存、进程和CPU活动进行监控的轻量化工具，能对系统的整体情况进行统计，但不能深入分析某个进程。</p><a id="more"></a><h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><h3 id="vmstat命令格式"><a href="#vmstat命令格式" class="headerlink" title="vmstat命令格式"></a>vmstat命令格式</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vmstat</span><span class="meta"> [命令选项]</span></span><br></pre></td></tr></table></figure><h3 id="vmstat命令常用选项"><a href="#vmstat命令常用选项" class="headerlink" title="vmstat命令常用选项"></a>vmstat命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-a显示活跃和非活跃内存。</span></span><br><span class="line"><span class="deletion">-f显示从系统启动至今的fork数量。</span></span><br><span class="line"><span class="deletion">-m显示slabinfo。</span></span><br><span class="line"><span class="deletion">-n只在开始时显示一次各字段名称。</span></span><br><span class="line"><span class="deletion">-s显示内存相关统计信息及多种系统活动数量。</span></span><br><span class="line"><span class="deletion">-d显示磁盘统计信息。</span></span><br><span class="line"><span class="deletion">-D对磁盘统计信息进行总结。</span></span><br><span class="line"><span class="deletion">-S &lt;参数&gt;使用指定的单位显示；参数：k（1000字节）、K（1024字节）、m（1000000字节）、M（1048576字节）；默认单位为K（1024字节）。</span></span><br><span class="line"><span class="deletion">-t显示时间戳。</span></span><br><span class="line"><span class="deletion">-w增大数据显示的列间隔，有助于观察。</span></span><br><span class="line"><span class="deletion">-h显示帮助。</span></span><br><span class="line"><span class="deletion">-V显示程序版本。</span></span><br><span class="line">&lt;x&gt; &lt;y&gt;x表示数据采集的时间间隔数，单位为秒；y表示数据采集的次数。</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><img src="/images/vmstat%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/vmstat.png" alt></p><ul><li><p><code>procs（进程）</code>：</p><ul><li><code>r</code>：当前运行队列中进程的数目，该值可作为判断CPU是否繁忙的一个指标。</li><li><code>b</code>：等待I/O的进程数量。</li></ul></li><li><p><code>memory（内存）</code>：</p><ul><li><code>交换（swpd）</code>：已使用的虚拟内存的大小。</li><li><code>空闲（free）</code>：空闲的物理内存的大小。</li><li><code>缓冲（buff）</code>：用作缓冲的内存大小；用作传输速度不同步或优先级不同的设备之间传输数据时的缓冲区域，减少进程之间的相互等待。</li><li><code>缓存（cache）</code>：用作缓存的内存大小；介于CPU与内存之间，存储着CPU刚使用过或循环使用的一部分数据，当CPU再次使用这些数据时，则从缓存中直接调用，减少CPU的等待时间。</li></ul></li><li><p><code>swap（交换空间）</code>：</p><ul><li><code>si</code>：每秒从虚拟内存写入物理内存的数据大小。</li><li><code>so</code>：每秒从物理内存写入虚拟内存的数据大小。</li></ul></li><li><p><code>io</code>：（默认块大小是1024字节）</p><ul><li><code>bi</code>：块设备每秒接收的块数。</li><li><code>bo</code>：块设备每秒发送的块数。</li></ul></li><li><p><code>system</code>：</p><ul><li><code>in</code>：设备中断，每秒CPU的中断次数，包含时间中断。</li><li><code>cs</code>：每秒上下文切换数。</li></ul></li><li><p><code>cpu</code>：<strong>（百分比）</strong></p><ul><li><code>us</code>：用户进程执行时间。</li><li><code>sy</code>：系统进程执行时间。</li><li><code>id</code>：空闲时间（包括I/O等待时间）。</li><li><code>wa</code>：I/O等待时间。</li></ul></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><h3 id="Linux内存管理机制相关"><a href="#Linux内存管理机制相关" class="headerlink" title="Linux内存管理机制相关"></a>Linux内存管理机制相关</h3><ul><li>Linux会不时进行内存页面交换操作，以保持尽可能多的可用物理内存，即使此时物理内存占用很低，Linux还是会进行此操作，这样在需要时可以尽量减少进程等待内存交换所需的时间甚至是避免进程等待；</li><li>Linux会将一些最近不经常使用的页面文件交换到虚拟内存，因此会出现这一正常现象：可用的物理内存虽然较多，但虚拟内存已使用的空间也较多；</li><li>即使某进程结束并释放较多的物理内存，但被交换到虚拟内存的页面文件也不会自动重新返回物理内存，除非有必要。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><code>si</code>和<code>so</code>的值都长期大于0，则系统性能会收到影响。</li><li>磁盘随机读写时，<code>bi</code>和<code>bo</code>的值越大，则CPU的I/O等待时间的值也会越大。</li><li><code>in</code>和<code>cs</code>的值越大，表明内核占用的CPU时间越多。</li><li><code>wa</code>的值越大，表明I/O等待越严重，可能是由于磁盘的大量随机访问，也有可能是磁盘出现性能瓶颈。</li></ul><hr><p>整理自</p><p><a href="https://www.jellythink.com/archives/419" target="_blank" rel="noopener">Linux vmstat命令详解</a></p><p><a href="https://segmentfault.com/a/1190000018834649" target="_blank" rel="noopener">Linux常用命令 | vmstat、top</a></p><p><a href="https://commandnotfound.cn/linux/1/212/vmstat-命令" target="_blank" rel="noopener">vmstat 命令详解</a></p><p><a href="https://juejin.im/post/6844904087536812039" target="_blank" rel="noopener">linux下内存实时性能监控vmstat命令详解</a></p><p><a href="https://www.cnblogs.com/peida/archive/2012/12/25/2833108.html" target="_blank" rel="noopener">每天一个linux命令（46）：vmstat命令</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机程序（数码管显示）</title>
      <link href="/2020/10/30/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%EF%BC%89/"/>
      <url>/2020/10/30/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>备份一下之前自己写的实现数码管循环显示和动态显示的程序 ٩(｡・ω・｡)﻿و 。</p><a id="more"></a><p>单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a></p><p>HC6800-MS开发板上的数码管部分的电路示意图如下：</p><p><img src="/images/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%EF%BC%89/%E6%95%B0%E7%A0%81%E7%AE%A1.png" alt></p><h2 id="数码管循环显示"><a href="#数码管循环显示" class="headerlink" title="数码管循环显示"></a>数码管循环显示</h2><p>程序运行结果：开发板上数码管模块最左侧的位循环显示数字0~9，每个数字停留显示1秒。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">sbit LEDS1=P1^<span class="number">0</span>;</span><br><span class="line">sbit LEDS2=P1^<span class="number">1</span>;</span><br><span class="line">sbit LEDS3=P1^<span class="number">2</span>;</span><br><span class="line">sbit LEDS4=P1^<span class="number">3</span>;</span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> LEDChar[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;<span class="comment">//数码管真值，显示数字0~9</span></span><br><span class="line"><span class="built_in">int</span> x=<span class="number">0</span>,sec=<span class="number">0</span>;</span><br><span class="line">LEDS1=<span class="number">0</span>;</span><br><span class="line">LEDS2=<span class="number">0</span>;</span><br><span class="line">LEDS3=<span class="number">0</span>;</span><br><span class="line">LEDS4=<span class="number">1</span>;<span class="comment">//设定只有数码管模块最左侧的位显示</span></span><br><span class="line">TMOD=<span class="number">0x01</span>;</span><br><span class="line">TH0=<span class="number">0xB8</span>;</span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">TR0=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TF0==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">TF0=<span class="number">0</span>;</span><br><span class="line">TH0=<span class="number">0xB8</span>;</span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">sec++;</span><br><span class="line">P0=LEDChar[sec<span class="number">-1</span>];<span class="comment">//将数码管的真值赋给控制数码管的其中一个寄存器P0</span></span><br><span class="line"><span class="keyword">if</span>(sec==<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">sec=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数码管动态显示"><a href="#数码管动态显示" class="headerlink" title="数码管动态显示"></a>数码管动态显示</h2><p>数码管的动态显示实际上是从左向右的不同位数码管的流水显示依次循环（同一时刻内只有一位数码管被点亮），利用人眼的视觉暂留效应，只要进行一次流水显示所需的时间足够短，那么在人眼看来，所有位的数码管都是同时被点亮的。</p><p>程序运行结果：开发板上的四位数码管从左往右分别显示数字<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>（实际上每位数码管停留显示0.005秒）。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;reg51.h&gt;</span></span><br><span class="line">sbit <span class="attribute">LEDS4</span>=P1^3;</span><br><span class="line">sbit <span class="attribute">LEDS3</span>=P1^2;</span><br><span class="line">sbit <span class="attribute">LEDS2</span>=P1^1;</span><br><span class="line">sbit <span class="attribute">LEDS1</span>=P1^0;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int LEDChar[]=&#123;0x3F,0x06,0x5B,0x4F&#125;;</span><br><span class="line">int <span class="attribute">x</span>=0;</span><br><span class="line"><span class="attribute">TMOD</span>=0x01;</span><br><span class="line"><span class="attribute">TH0</span>=0xEE;</span><br><span class="line"><span class="attribute">TL0</span>=0x00;</span><br><span class="line"><span class="attribute">TR0</span>=1;</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">TF0</span>==1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">TF0</span>=0;</span><br><span class="line"><span class="attribute">TH0</span>=0xEE;</span><br><span class="line"><span class="attribute">TL0</span>=0x00;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">x</span>==1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">LEDS4</span>=1;</span><br><span class="line"><span class="attribute">LEDS3</span>=0;</span><br><span class="line"><span class="attribute">LEDS2</span>=0;</span><br><span class="line"><span class="attribute">LEDS1</span>=0;</span><br><span class="line"><span class="attribute">P0</span>=LEDChar[x-1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">x</span>==2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">LEDS4</span>=0;</span><br><span class="line"><span class="attribute">LEDS3</span>=1;</span><br><span class="line"><span class="attribute">LEDS2</span>=0;</span><br><span class="line"><span class="attribute">LEDS1</span>=0;</span><br><span class="line"><span class="attribute">P0</span>=LEDChar[x-1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">x</span>==3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">LEDS4</span>=0;</span><br><span class="line"><span class="attribute">LEDS3</span>=0;</span><br><span class="line"><span class="attribute">LEDS2</span>=1;</span><br><span class="line"><span class="attribute">LEDS1</span>=0;</span><br><span class="line"><span class="attribute">P0</span>=LEDChar[x-1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="attribute">x</span>==4)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">LEDS4</span>=0;</span><br><span class="line"><span class="attribute">LEDS3</span>=0;</span><br><span class="line"><span class="attribute">LEDS2</span>=0;</span><br><span class="line"><span class="attribute">LEDS1</span>=1;</span><br><span class="line"><span class="attribute">P0</span>=LEDChar[x-1];</span><br><span class="line"><span class="attribute">x</span>=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录-共阴数码管真值表（部分）"><a href="#附录-共阴数码管真值表（部分）" class="headerlink" title="附录 - 共阴数码管真值表（部分）"></a>附录 - 共阴数码管真值表（部分）</h2><table><thead><tr><th align="center">字符</th><th align="center">真值</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0x3F</td></tr><tr><td align="center">1</td><td align="center">0x06</td></tr><tr><td align="center">2</td><td align="center">0x5B</td></tr><tr><td align="center">3</td><td align="center">0x4F</td></tr><tr><td align="center">4</td><td align="center">0x66</td></tr><tr><td align="center">5</td><td align="center">0x6D</td></tr><tr><td align="center">6</td><td align="center">0x7D</td></tr><tr><td align="center">7</td><td align="center">0x07</td></tr><tr><td align="center">8</td><td align="center">0x7F</td></tr><tr><td align="center">9</td><td align="center">0x6F</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机定时器及其应用</title>
      <link href="/2020/10/29/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/10/29/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>简单整理并记录一些之前在玩51单片机时遇到的东西，算是一个备忘录吧。</p><p> 单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a> </p><a id="more"></a><h2 id="定时器的寄存器"><a href="#定时器的寄存器" class="headerlink" title="定时器的寄存器"></a>定时器的寄存器</h2><p>标准51单片机内有<code>T0</code>和<code>T1</code>两个定时器，但现在很多51单片机还会额外增加定时器，例如STC89C52一共有3个定时器（增加了<code>T2</code>）。</p><h3 id="与定时器有关的特殊功能寄存器"><a href="#与定时器有关的特殊功能寄存器" class="headerlink" title="与定时器有关的特殊功能寄存器"></a>与定时器有关的特殊功能寄存器</h3><h4 id="定时值存储寄存器"><a href="#定时值存储寄存器" class="headerlink" title="定时值存储寄存器"></a>定时值存储寄存器</h4><p>定时值存储寄存器用于存储定时器的计数值；定时器的计数值每经过一个机器周期自动加1。</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">SFR地址</th><th align="center">复位值</th></tr></thead><tbody><tr><td align="center">TH0</td><td align="center">T0高字节</td><td align="center">0x8C</td><td align="center">0x00</td></tr><tr><td align="center">TL0</td><td align="center">T0低字节</td><td align="center">0x8A</td><td align="center">0x00</td></tr><tr><td align="center">TH1</td><td align="center">T1高字节</td><td align="center">0x8D</td><td align="center">0x00</td></tr><tr><td align="center">TL1</td><td align="center">T1低字节</td><td align="center">0x8B</td><td align="center">0x00</td></tr></tbody></table><h4 id="定时器控制寄存器TCON"><a href="#定时器控制寄存器TCON" class="headerlink" title="定时器控制寄存器TCON"></a>定时器控制寄存器TCON</h4><p>定时器控制寄存器TCON用于控制定时器的启动、停止以及标志定时器溢出和中断情况。</p><table><thead><tr><th align="center">位</th><th align="center">符号</th><th align="center">描述</th><th align="center">复位值</th></tr></thead><tbody><tr><td align="center">7</td><td align="center">TF1</td><td align="center"><code>T1</code>溢出标志。<code>T1</code>发生溢出时，硬件置1。清零方式：软件清零，或者进入定时器中断时硬件清零。</td><td align="center">0</td></tr><tr><td align="center">6</td><td align="center">TR1</td><td align="center"><code>T1</code>运行控制位。软件置1来启动定时器；软件清零来停止定时器。</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">TF0</td><td align="center"><code>T0</code>溢出标志。<code>T0</code>发生溢出时，硬件置1。清零方式：软件清零，或者进入定时器中断时硬件清零。</td><td align="center">0</td></tr><tr><td align="center">4</td><td align="center">TR0</td><td align="center"><code>T0</code>运行控制位。软件置1来启动定时器；软件清零来停止定时器。</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">IE1</td><td align="center">外部中断1请求标志。</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">IT1</td><td align="center">外部中断1触发方式选择位。</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">IE0</td><td align="center">外部中断0请求标志。</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">IT0</td><td align="center">外部中断0触发方式选择位。</td><td align="center">0</td></tr></tbody></table><h4 id="定时器模式寄存器TMOD"><a href="#定时器模式寄存器TMOD" class="headerlink" title="定时器模式寄存器TMOD"></a>定时器模式寄存器TMOD</h4><p>定时器有多种工作模式，工作模式的选择由TMOD来控制。</p><h5 id="TMOD的位分配"><a href="#TMOD的位分配" class="headerlink" title="TMOD的位分配"></a>TMOD的位分配</h5><p><strong>注：</strong>标有<code>T1</code>的符号表示控制定时器<code>T1</code>的位，标有<code>T0</code>的符号表示控制定时器<code>T0</code>的位。</p><table><thead><tr><th align="center">位</th><th align="center">符号</th><th align="center">复位值</th></tr></thead><tbody><tr><td align="center">7</td><td align="center">GATE(T1)</td><td align="center">0</td></tr><tr><td align="center">6</td><td align="center">C/T(T1)</td><td align="center">0</td></tr><tr><td align="center">5</td><td align="center">M1(T1)</td><td align="center">0</td></tr><tr><td align="center">4</td><td align="center">M0(T1)</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">GATE(T0)</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">C/T(T0)</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">M1(T0)</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">M0(T0)</td><td align="center">0</td></tr></tbody></table><h5 id="TMOD的位描述"><a href="#TMOD的位描述" class="headerlink" title="TMOD的位描述"></a>TMOD的位描述</h5><table><thead><tr><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GATE</td><td align="center">门控位。当GATE=0时，只要TCON中的TR0或TR1为1，就能启动相应的定时器/计数器（<code>T0</code>和<code>T1</code>也可用作计数器）；当GATE=1时，只有TCON中的TR0或TR1为1，且外部中断引脚INT0或INT1为高电平时，才能启动相应的定时器/计数器。</td></tr><tr><td align="center">C/T</td><td align="center">定时器/计数器模式选择位。C/T=0为定时器模式；C/T=1为计数器模式。</td></tr></tbody></table><h5 id="TMOD的M1、M0和工作模式"><a href="#TMOD的M1、M0和工作模式" class="headerlink" title="TMOD的M1、M0和工作模式"></a>TMOD的M1、M0和工作模式</h5><table><thead><tr><th align="center">M1</th><th align="center">M0</th><th align="center">工作模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">兼容8048单片机的13位定时器。</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">THn和TLn组成一个16位的定时器。</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">8位自动重装载模式，定时器溢出后把THn重装载到TLn。</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">禁用定时器<code>T1</code>，定时器<code>T0</code>变成两个8位定时器。</td></tr></tbody></table><p><strong>注：</strong>工作模式0现已基本不再使用；工作模式3使用频率也较少。</p><p><strong>工作模式1：</strong>由THn和TLn组成一个16位的定时器，计数范围<strong>0~65535</strong>，溢出后，只要不对THn和TLn重新赋值，则<strong>从0开始计数</strong>；</p><p><strong>工作模式2</strong>：8位自动重装载模式，<strong>只有TLn做加1计数，计数范围0~255</strong>，THn保持原值不发生变化，<strong>TLn溢出后</strong>，TFn直接置1，并<strong>将THn的值直接赋给TLn</strong>，TLn从新值开始计数。</p><h6 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h6><p>程序运行结果：<a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a>开发板上编号为<code>D8</code>的LED以先点亮1秒后熄灭1秒的规律来循环亮灭<del>（不太懂怎么用语言来描述这个结果 (灬ºωº灬) ）</del>。</p><p>程序说明：</p><p>用作时钟源的晶振的频率为11.0592MHz<del>（才不是呢ε(┬┬﹏┬┬)3，这块开发板用的是12MHz的晶振(ノへ￣、)）</del>，则时钟周期为1/11059200秒，<a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a>默认一个机器周期等于12个时钟周期，即为12/11059200秒；由<code>x*12/11059200=0.02</code>得<code>x=18432</code>，即在0.02秒内经过了18432个机器周期；由<code>y+18432=65536</code>得<code>y=47104</code>，即将一个定时器得初值设定为47104后，经过0.02秒（即18432个机器周期）后，该定时器溢出（65535再加1才是溢出）；由<code>z*0.02=1</code>得<code>z=50</code>，即在1秒内该定时器溢出50次。</p><p>假设定时器从0开始计数一直到65536溢出，定时器的最大定时值约为0.07秒，若需要实现时间更长的定时，需要灵活设定定时器初值和倍数关系。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">sbit LED=P2^<span class="number">7</span>;</span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> x;<span class="comment">//记录T0溢出次数</span></span><br><span class="line">TMOD=<span class="number">0x01</span>;<span class="comment">//设置T0以工作模式1运行</span></span><br><span class="line">TH0=<span class="number">0xB8</span>;<span class="comment">//十进制数47104转换成十六进制数为B800</span></span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">//启动T0</span></span><br><span class="line">LED=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TF0==<span class="number">1</span>)<span class="comment">//判断T0是否溢出</span></span><br><span class="line">&#123;</span><br><span class="line">TH0=<span class="number">0xB8</span>;<span class="comment">//对T0重新赋值</span></span><br><span class="line">TL0=<span class="number">0x00</span>;</span><br><span class="line">TF0=<span class="number">0</span>;<span class="comment">//清零T0溢出标志</span></span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">LED=~LED;<span class="comment">//对P2^7进行取反操作，即0-&gt;1，1-&gt;0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>TCON的地址为0x88，<strong>可位寻址</strong>，即<strong>可单独对一个位进行操作</strong>，例如<code>TR0=1</code>；</p><p>TMOD的地址为0x89，<strong>不可位寻址</strong>，即要操作就<strong>必须一次性对该寄存器所有位进行操作</strong>，不能对其中某一位单独进行操作，例如：把定时器1的工作模式设定为2，则对TMOD赋值<code>00100000</code>（二进制），表达式则为<code>TMOD=0x20</code>（十六进制）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机程序（点亮LED）</title>
      <link href="/2020/10/25/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%82%B9%E4%BA%AELED%EF%BC%89/"/>
      <url>/2020/10/25/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%82%B9%E4%BA%AELED%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文记录了自己在折腾51单片机时编写过的点亮LED的程序(<em>/ω＼</em>)，以作备份。</p><p>单片机： <a href="http://www.stcmcudata.com/datasheet/STC89C52.pdf" target="_blank" rel="noopener">STC89C52</a><br>开发板： <a href="http://www.prechin.net/forum.php?mod=viewthread&tid=35264" target="_blank" rel="noopener">HC6800-MS</a></p><a id="more"></a><h2 id="点亮一个LED"><a href="#点亮一个LED" class="headerlink" title="点亮一个LED"></a>点亮一个LED</h2><p>运行结果：HC6800-MS开发板上的编号为<code>D8</code>的LED常亮。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;<span class="comment">//包含特殊功能寄存器定义的头文件</span></span><br><span class="line">sbit LED=P2^<span class="number">7</span>;<span class="comment">//位地址声明</span></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED=<span class="number">0</span>;<span class="comment">//低电平点亮LED</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LED闪烁"><a href="#LED闪烁" class="headerlink" title="LED闪烁"></a>LED闪烁</h2><p>运行结果：HC6800-MS开发板上的编号为<code>D8</code>的LED闪烁。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">sbit LED=P2^<span class="number">7</span>;</span><br><span class="line"><span class="built_in">void</span> Delaytime(<span class="built_in">int</span> x);<span class="comment">//声明非精确延时函数</span></span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED=<span class="number">0</span>;<span class="comment">//低电平点亮LED</span></span><br><span class="line">Delaytime(<span class="number">10000</span>);<span class="comment">//延时</span></span><br><span class="line">LED=<span class="number">1</span>;<span class="comment">//高电平熄灭LED</span></span><br><span class="line">Delaytime(<span class="number">10000</span>);<span class="comment">//延时</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Delaytime(<span class="built_in">int</span> x)<span class="comment">//定义非精确延时函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> y;</span><br><span class="line"><span class="keyword">for</span>(;x&gt;<span class="number">0</span>;x--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">10</span>;y&gt;<span class="number">0</span>;y--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流水LED"><a href="#流水LED" class="headerlink" title="流水LED"></a>流水LED</h2><p>运行结果：HC6800-MS开发板上的编号为<code>D1</code>~<code>D8</code>的LED，往左依次先点亮后熄灭，再往右依次先点亮后熄灭；依此循环。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">#include&lt;<span class="built_in">int</span>rins.h&gt;<span class="comment">//包含_crol_()和_cror_()函数的头文件</span></span><br><span class="line">#define LED P2</span><br><span class="line"><span class="built_in">void</span> Delaytime(<span class="built_in">int</span> x);</span><br><span class="line"><span class="built_in">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line">LED=<span class="number">0xfe</span>;<span class="comment">//1111_1110，定义P2的8个I/O输出的电平</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">7</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">LED=_crol_(LED,<span class="number">1</span>);<span class="comment">//左移一位</span></span><br><span class="line">Delaytime(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">7</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">LED=_cror_(LED,<span class="number">1</span>);<span class="comment">//右移一位</span></span><br><span class="line">Delaytime(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> Delaytime(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> y;</span><br><span class="line"><span class="keyword">for</span>(;x&gt;<span class="number">0</span>;x--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">10</span>;y&gt;<span class="number">0</span>;y--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB绘制二维曲线（基本）</title>
      <link href="/2020/10/22/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/"/>
      <url>/2020/10/22/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下(ﾉ∀`*)。</p><a id="more"></a><h2 id="绘图基本函数"><a href="#绘图基本函数" class="headerlink" title="绘图基本函数"></a>绘图基本函数</h2><p>在MATLAB语言中，最基本且应用最广泛的绘图函数是绘制曲线函数<code>plot</code>，利用它可在二维平面上绘制不同的曲线。<code>plot</code>函数的用法如下：</p><h3 id="plot-y"><a href="#plot-y" class="headerlink" title="plot(y)"></a>plot(y)</h3><p>绘制以<code>y</code>为纵坐标的二维曲线。</p><h4 id="y为向量时的plot-y"><a href="#y为向量时的plot-y" class="headerlink" title="y为向量时的plot(y)"></a>y为向量时的plot(y)</h4><p>当<code>y</code>为长度为<code>n</code>的向量时，则纵坐标为<code>y</code>，MATLAB根据<code>y</code>向量的元素序号自动生成横坐标，为<code>1:n</code>的向量。</p><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; y0=[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">y0 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; plot(y0)</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/plot(y0).png" alt></p><h4 id="y为矩阵时的plot-y"><a href="#y为矩阵时的plot-y" class="headerlink" title="y为矩阵时的plot(y)"></a>y为矩阵时的plot(y)</h4><p>当<code>y</code>为<code>m*n</code>矩阵时，<code>plot(y)</code>则将矩阵的每一列画一条曲线，共<code>n</code>条曲线，每条曲线自动用不同颜色表示，每条曲线横坐标为向量<code>1:m</code>，<code>m</code>为矩阵的行数。</p><h5 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; y1=[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">y1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; plot(y1)</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/plot(y1).png" alt></p><h3 id="plot-x-y"><a href="#plot-x-y" class="headerlink" title="plot(x,y)"></a>plot(x,y)</h3><p>绘制以<code>x</code>为横坐标，<code>y</code>为纵坐标的二维曲线。</p><h4 id="x和y都为向量时的plot-x-y"><a href="#x和y都为向量时的plot-x-y" class="headerlink" title="x和y都为向量时的plot(x,y)"></a>x和y都为向量时的plot(x,y)</h4><p><code>x</code>和<code>y</code>的长度必须相等。</p><h5 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x0=[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span>];</span><br><span class="line">&gt;&gt; y0=[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">&gt;&gt; plot(x0,y0)</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/plot(x0,y0).png" alt></p><h4 id="x为向量、y为矩阵时的plot-x-y"><a href="#x为向量、y为矩阵时的plot-x-y" class="headerlink" title="x为向量、y为矩阵时的plot(x,y)"></a>x为向量、y为矩阵时的plot(x,y)</h4><p><code>x</code>的长度必须和<code>y</code>的行数或列数相等。</p><p>当向量<code>x</code>的长度和矩阵<code>y</code>的行数相等时，向量<code>x</code>和<code>y</code>的每一列向量画一条曲线；</p><p>当向量<code>x</code>的长度和矩阵<code>y</code>的列数相等时，向量<code>x</code>和<code>y</code>的每一行向量画一条曲线；</p><p>若<code>y</code>为方阵，<code>x</code>和<code>y</code>的行数、列数都相等，向量<code>x</code>和<code>y</code>的每一列向量画一条曲线。</p><h4 id="x为矩阵、y为向量时的plot-x-y"><a href="#x为矩阵、y为向量时的plot-x-y" class="headerlink" title="x为矩阵、y为向量时的plot(x,y)"></a>x为矩阵、y为向量时的plot(x,y)</h4><p><code>x</code>的行数或列数必须和<code>y</code>的长度相等。绘制方法与上一种情况类似。</p><h4 id="x和y都为矩阵时的plot-x-y"><a href="#x和y都为矩阵时的plot-x-y" class="headerlink" title="x和y都为矩阵时的plot(x,y)"></a>x和y都为矩阵时的plot(x,y)</h4><p><code>x</code>和<code>y</code>的大小必须相等，<code>x</code>的每一列与<code>y</code>对应的每一列画一条曲线。</p><h2 id="线性图格式设置"><a href="#线性图格式设置" class="headerlink" title="线性图格式设置"></a>线性图格式设置</h2><h3 id="设置曲线的线型、颜色和数据点标识"><a href="#设置曲线的线型、颜色和数据点标识" class="headerlink" title="设置曲线的线型、颜色和数据点标识"></a>设置曲线的线型、颜色和数据点标识</h3><p>为了便于曲线比较，MATLAB语言提供了一些绘图选项，可以控制所绘的曲线的线型、颜色和数据点的标识符号。命令格式如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">plot</span><span class="params">(x,y,<span class="string">'选项'</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="线型、颜色和数据点标识定义"><a href="#线型、颜色和数据点标识定义" class="headerlink" title="线型、颜色和数据点标识定义"></a>线型、颜色和数据点标识定义</h4><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><table><thead><tr><th align="center">类型</th><th align="center">选型</th></tr></thead><tbody><tr><td align="center">蓝色</td><td align="center">b</td></tr><tr><td align="center">绿色</td><td align="center">g</td></tr><tr><td align="center">红色</td><td align="center">r</td></tr><tr><td align="center">青色</td><td align="center">c</td></tr><tr><td align="center">紫红色</td><td align="center">m</td></tr><tr><td align="center">黄色</td><td align="center">y</td></tr><tr><td align="center">黑色</td><td align="center">k</td></tr><tr><td align="center">白色</td><td align="center">w</td></tr></tbody></table><h5 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h5><table><thead><tr><th align="center">类型</th><th align="center">选项</th></tr></thead><tbody><tr><td align="center">实线</td><td align="center">-</td></tr><tr><td align="center">点线</td><td align="center">:</td></tr><tr><td align="center">虚线</td><td align="center">–</td></tr><tr><td align="center">点画线</td><td align="center">-.</td></tr></tbody></table><h5 id="数据点标识"><a href="#数据点标识" class="headerlink" title="数据点标识"></a>数据点标识</h5><table><thead><tr><th align="center">类型</th><th align="center">选项</th></tr></thead><tbody><tr><td align="center">实点标记</td><td align="center">.</td></tr><tr><td align="center">圆圈标记</td><td align="center">o</td></tr><tr><td align="center">叉号标记</td><td align="center">x</td></tr><tr><td align="center">十字标记</td><td align="center">+</td></tr><tr><td align="center">星号标记</td><td align="center">*</td></tr><tr><td align="center">方块标记</td><td align="center">s</td></tr><tr><td align="center">钻石标记</td><td align="center">d</td></tr><tr><td align="center">下三角标记</td><td align="center">v</td></tr><tr><td align="center">上三角标记</td><td align="center">^</td></tr><tr><td align="center">左三角标记</td><td align="center">&lt;</td></tr><tr><td align="center">右三角标记</td><td align="center">&gt;</td></tr><tr><td align="center">五角星标记</td><td align="center">p</td></tr><tr><td align="center">六角形标记</td><td align="center">h</td></tr></tbody></table><p>不同类型的选项可以组合使用。</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="symbol">x</span>=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="literal">pi</span>;</span><br><span class="line">&gt;&gt; y1=<span class="built_in">sin</span>(<span class="symbol">x</span>);</span><br><span class="line">&gt;&gt; y2=<span class="built_in">cos</span>(<span class="symbol">x</span>);</span><br><span class="line">&gt;&gt; plot(<span class="symbol">x</span>,y1,<span class="string">'b-o'</span>,<span class="symbol">x</span>,y2,<span class="string">'r-.d'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/1.png" alt></p><h3 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h3><p>MATLAB语言可以通过函数<code>axis</code>设置坐标轴的刻度和范围来调整坐标轴。<code>axis</code>函数常用的调用格式如下：</p><table><thead><tr><th align="center">函数命令</th><th align="center">功能及说明</th></tr></thead><tbody><tr><td align="center">axis auto</td><td align="center">使用默认设置</td></tr><tr><td align="center">axis ([xmin,xmax,ymin,ymax])</td><td align="center">设定坐标范围，且要求xmin&lt;xmax，ymin&lt;ymax</td></tr><tr><td align="center">axis equal</td><td align="center">横纵坐标使用等长刻度</td></tr><tr><td align="center">axis square</td><td align="center">采用正方形坐标系</td></tr><tr><td align="center">axis normal</td><td align="center">默认矩形坐标系</td></tr><tr><td align="center">axis tight</td><td align="center">把数据范围设为坐标范围</td></tr><tr><td align="center">axis image</td><td align="center">横纵轴采用等长刻度，且坐标框紧贴数据范围</td></tr><tr><td align="center">axis manual</td><td align="center">保持当前坐标范围不变</td></tr><tr><td align="center">axis fill</td><td align="center">在manual方式下，使坐标充满整个绘图区域</td></tr><tr><td align="center">axis on</td><td align="center">显示坐标轴</td></tr><tr><td align="center">axis off</td><td align="center">取消坐标轴</td></tr><tr><td align="center">axis xy</td><td align="center">普通直角坐标，原点在左下方</td></tr><tr><td align="center">axis ij</td><td align="center">矩阵式坐标，原点在左上方</td></tr><tr><td align="center">axis vis3d</td><td align="center">保持高宽比不变，三维旋转时避免图形大小变化</td></tr></tbody></table><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="symbol">x</span>=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="literal">pi</span>;</span><br><span class="line">&gt;&gt; <span class="symbol">y</span>=<span class="built_in">sin</span>(<span class="symbol">x</span>);</span><br><span class="line">&gt;&gt; plot(<span class="symbol">x</span>,<span class="symbol">y</span>);axis([<span class="number">0</span> <span class="number">4</span>*<span class="literal">pi</span> <span class="number">-2</span> <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/axis.png" alt></p><h3 id="网格线和坐标边框"><a href="#网格线和坐标边框" class="headerlink" title="网格线和坐标边框"></a>网格线和坐标边框</h3><h4 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h4><p>为了便于读数，MATLAB语言可以使用<code>grid on</code>函数在坐标系中添加网格线，网格线根据坐标轴的刻度使用虚线分隔；使用<code>grid off</code>函数取消网格线。</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="symbol">x</span>=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="literal">pi</span>;</span><br><span class="line">&gt;&gt; <span class="symbol">y</span>=<span class="built_in">sin</span>(<span class="symbol">x</span>);</span><br><span class="line">&gt;&gt; plot(<span class="symbol">x</span>,<span class="symbol">y</span>);axis([<span class="number">0</span> <span class="number">4</span>*<span class="literal">pi</span> <span class="number">-2</span> <span class="number">2</span>]);grid on</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/grid.png" alt></p><h4 id="坐标边框"><a href="#坐标边框" class="headerlink" title="坐标边框"></a>坐标边框</h4><p>MATLAB语言可以使用<code>box on</code>函数实现添加坐标边框，<code>box off</code>函数取消坐标边框。</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="symbol">x</span>=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="literal">pi</span>;</span><br><span class="line">&gt;&gt; <span class="symbol">y</span>=<span class="built_in">sin</span>(<span class="symbol">x</span>);</span><br><span class="line">&gt;&gt; plot(<span class="symbol">x</span>,<span class="symbol">y</span>);axis([<span class="number">0</span> <span class="number">4</span>*<span class="literal">pi</span> <span class="number">-2</span> <span class="number">2</span>]);box off</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/box.png" alt></p><h2 id="图形修饰"><a href="#图形修饰" class="headerlink" title="图形修饰"></a>图形修饰</h2><p>MATLAB语言提供了很多图形修饰函数，实现对图形添加标题，横纵坐标轴的标签，图形某一部分文本标注，不同曲线的图例标识等功能。</p><h3 id="标题和标签设置"><a href="#标题和标签设置" class="headerlink" title="标题和标签设置"></a>标题和标签设置</h3><p>MATLAB语言提供<code>title</code>函数和<code>label</code>函数实现添加图形的标题和坐标轴的标签，其调用格式如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">title</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">xlabel</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">ylabel</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">zlabel</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>title</code>为设置图形标题的函数；</p><p><code>xlabel</code>、<code>ylabel</code>、<code>zlabel</code>分别为设置<code>x</code>、<code>y</code>、<code>z</code>坐标轴标签的函数；</p><p><code>str</code>为注释字符串，也可为结构数组。</p><h3 id="图形的文本标注"><a href="#图形的文本标注" class="headerlink" title="图形的文本标注"></a>图形的文本标注</h3><p>MATLAB语言提供<code>text</code>和<code>gtext</code>函数，能在坐标系某一位置标注文本注释，其调用格式如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">text</span><span class="params">(x,y,<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">gtext</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">gtext</span><span class="params">(&#123;<span class="string">'str1'</span>;<span class="string">'str2'</span>;<span class="string">'str3'</span>;...&#125;)</span></span></span><br></pre></td></tr></table></figure><p><code>text(x,y,&#39;str&#39;)</code>函数能在坐标系位置<code>(x,y)</code>处添加文本注释<code>str</code>；</p><p><code>gtext(&#39;str&#39;)</code>可以为鼠标选择的位置处添加文本注释<code>str</code>；</p><p><code>gtext({&#39;str1&#39;;&#39;str2&#39;;&#39;str3&#39;;...})</code>一次放置一个字符串，多次放置在鼠标指定的位置上。</p><h3 id="图例设置"><a href="#图例设置" class="headerlink" title="图例设置"></a>图例设置</h3><p>MATLAB语言可用<code>legend</code>函数添加图例，其调用格式为：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">legend</span><span class="params">(<span class="string">'str1'</span>,<span class="string">'str2'</span>,...,<span class="string">'location'</span>,LOC)</span></span></span><br></pre></td></tr></table></figure><p><code>str1</code>、<code>str2</code>为图例标题，与图形内曲线依次对应；</p><p><code>LOC</code>为图例位置参数。</p><p><code>legend off</code>用于取消图例。</p><h4 id="图例位置参数"><a href="#图例位置参数" class="headerlink" title="图例位置参数"></a>图例位置参数</h4><table><thead><tr><th align="center">位置参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">‘North’</td><td align="center">图内的顶部</td></tr><tr><td align="center">‘South’</td><td align="center">图内的底部</td></tr><tr><td align="center">‘East’</td><td align="center">图内的右侧</td></tr><tr><td align="center">‘West’</td><td align="center">图内的左侧</td></tr><tr><td align="center">‘NorthEast’</td><td align="center">图内右上角</td></tr><tr><td align="center">‘NorthWest’</td><td align="center">图内左上角</td></tr><tr><td align="center">‘SouthEast’</td><td align="center">图内右下角</td></tr><tr><td align="center">‘SouthWest’</td><td align="center">图内左下角</td></tr><tr><td align="center">‘Best’</td><td align="center">最佳位置</td></tr><tr><td align="center">‘NorthOutside’</td><td align="center">图外的顶部</td></tr><tr><td align="center">‘SouthOutside’</td><td align="center">图外的底部</td></tr><tr><td align="center">‘EastOutside’</td><td align="center">图外的右侧</td></tr><tr><td align="center">‘WestOutside’</td><td align="center">图外的左侧</td></tr><tr><td align="center">‘NorthEastOutside’</td><td align="center">图外右上角</td></tr><tr><td align="center">‘NorthWestOutside’</td><td align="center">图外左上角</td></tr><tr><td align="center">‘SouthEastOutside’</td><td align="center">图外右下角</td></tr><tr><td align="center">‘SouthWestOutside’</td><td align="center">图外左下角</td></tr><tr><td align="center">BestOutside</td><td align="center">图外最佳位置</td></tr></tbody></table><h3 id="用鼠标获取二维图形数据"><a href="#用鼠标获取二维图形数据" class="headerlink" title="用鼠标获取二维图形数据"></a>用鼠标获取二维图形数据</h3><p>MATLAB语言中的<code>ginput</code>函数可实现用鼠标从图形（<strong>仅适用于二维图形</strong>）获取数据功能，其调用方式如下：</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">x</span>,<span class="symbol">y</span>]=ginput(n)</span><br></pre></td></tr></table></figure><p><code>n</code>是通过鼠标在图形中获取数据点的个数；</p><p><code>x</code>和<code>y</code>用来存储所获取的坐标，是列向量，每次获取的坐标点为列向量的一个元素。</p><h2 id="图形保持"><a href="#图形保持" class="headerlink" title="图形保持"></a>图形保持</h2><p>一般情况下，MATLAB每执行一次<code>plot</code>，就刷新一次当前图形窗口，原有的图形将被覆盖，但可以使用图形保持命令<code>hold</code>函数。</p><p><code>hold on</code>是保持原有图形；</p><p><code>hold off</code>是刷新原有图形。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">t</span>=(<span class="symbol">0:0</span>.<span class="symbol">1:2</span>*<span class="built_in">pi</span>)';</span><br><span class="line">&gt;&gt; <span class="symbol">y1</span>=<span class="number">3</span>*<span class="built_in">exp</span>(-<span class="number">0.3</span>*<span class="built_in">t</span>)*[<span class="number">1</span>,-<span class="number">1</span>];</span><br><span class="line">&gt;&gt; <span class="symbol">y2</span>=<span class="number">3</span>*<span class="built_in">exp</span>(-<span class="number">0.3</span>*<span class="built_in">t</span>).*<span class="built_in">sin</span>(<span class="number">3</span>*<span class="built_in">t</span>);</span><br><span class="line">&gt;&gt; plot(<span class="built_in">t</span>,<span class="symbol">y1</span>,'<span class="symbol">r:</span>')</span><br><span class="line">&gt;&gt; hold on</span><br><span class="line">&gt;&gt; plot(<span class="built_in">t</span>,<span class="symbol">y2</span>,'b-')</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/%E5%9B%BE%E5%BD%A2%E4%BF%9D%E6%8C%81.png" alt></p><h2 id="多个图形绘制"><a href="#多个图形绘制" class="headerlink" title="多个图形绘制"></a>多个图形绘制</h2><p>MATLAB语言提供<code>subplot</code>函数，实现一个图形窗口绘制多个图形的功能，其调用方式如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">subplot</span><span class="params">(m,n,p)</span></span></span><br></pre></td></tr></table></figure><p>将图形窗口分割成<code>m*n</code>子图，第<code>p</code>个为当前图；</p><p>子图排序：左上方为第一个，从左向右从上向下依次排序。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">t</span>=(<span class="symbol">0:0</span>.<span class="symbol">1:2</span>*<span class="built_in">pi</span>);</span><br><span class="line">&gt;&gt; <span class="symbol">y1</span>=<span class="built_in">sin</span>(<span class="built_in">t</span>);</span><br><span class="line">&gt;&gt; <span class="symbol">y2</span>=<span class="built_in">cos</span>(<span class="built_in">t</span>);</span><br><span class="line">&gt;&gt; <span class="symbol">y3</span>=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">t</span>);</span><br><span class="line">&gt;&gt; <span class="symbol">y4</span>=<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">t</span>);</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);plot(<span class="built_in">t</span>,<span class="symbol">y1</span>)</span><br><span class="line">&gt;&gt; title('<span class="built_in">sin</span>(<span class="built_in">t</span>)')</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);plot(<span class="built_in">t</span>,<span class="symbol">y2</span>)</span><br><span class="line">&gt;&gt; title('<span class="built_in">cos</span>(<span class="built_in">t</span>)')</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);plot(<span class="built_in">t</span>,<span class="symbol">y3</span>)</span><br><span class="line">&gt;&gt; title('<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">t</span>)')</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);plot(<span class="built_in">t</span>,<span class="symbol">y4</span>)</span><br><span class="line">&gt;&gt; title('<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">t</span>)')</span><br></pre></td></tr></table></figure><p><img src="/images/MATLAB%E7%BB%98%E5%88%B6%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89/%E5%A4%9A%E4%B8%AA%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记——类与对象（一）</title>
      <link href="/2020/10/16/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/10/16/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>简单整理一下 (つд⊂) 。</p><a id="more"></a><h2 id="类与对象的基本概念"><a href="#类与对象的基本概念" class="headerlink" title="类与对象的基本概念"></a>类与对象的基本概念</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是Java中抽象的概念集合，表示一组共性的产物，类中定义了共性的属性和方法。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是类中的一个个体的表示，有各自具体的属性和方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，类是对象的模板，对象是类的实例。</p><h2 id="类与对象的定义和使用"><a href="#类与对象的定义和使用" class="headerlink" title="类与对象的定义和使用"></a>类与对象的定义和使用</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>Java中使用关键字<code>class</code>来定义类。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> &lt;<span class="type">类的名称</span>&gt;// <span class="keyword">public</span>表示类的访问级别</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;类的属性&gt;;</span><br><span class="line">    &lt;类的方法&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    String <span class="type">name</span>;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> tags()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("name: "+<span class="type">name</span>+"");</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("age: "+age+"");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的声明和实例化"><a href="#对象的声明和实例化" class="headerlink" title="对象的声明和实例化"></a>对象的声明和实例化</h3><p>类在定义完成后，必须依靠对象才能使用。</p><p><strong>注：类属于引用数据类型，引用数据类型需要内存的分配和使用。</strong></p><h4 id="方式一：先声明后实例化对象"><a href="#方式一：先声明后实例化对象" class="headerlink" title="方式一：先声明后实例化对象"></a>方式一：先声明后实例化对象</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">类的名称</span>&gt;</span> <span class="tag">&lt;<span class="name">对象的名称</span>&gt;</span>=null;</span><br><span class="line"><span class="tag">&lt;<span class="name">对象的名称</span>&gt;</span>=new <span class="tag">&lt;<span class="name">类的名称</span>&gt;</span>();</span><br></pre></td></tr></table></figure><h5 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Person0 per=<span class="literal">null</span>;</span><br><span class="line">per=<span class="keyword">new</span> <span class="type">Person0</span>();<span class="comment">// 关键字new的主要作用是分配内存空间</span></span><br></pre></td></tr></table></figure><h4 id="方式二：声明并实例化对象"><a href="#方式二：声明并实例化对象" class="headerlink" title="方式二：声明并实例化对象"></a>方式二：声明并实例化对象</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">类的名称</span>&gt;</span> <span class="tag">&lt;<span class="name">对象的名称</span>&gt;</span>=new <span class="tag">&lt;<span class="name">类的名称</span>&gt;</span>();</span><br></pre></td></tr></table></figure><h5 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Person1 per=<span class="keyword">new</span> <span class="type">Person1</span>();</span><br></pre></td></tr></table></figure><h3 id="使用对象操作类"><a href="#使用对象操作类" class="headerlink" title="使用对象操作类"></a>使用对象操作类</h3><p>当一个实例化对象产生后，可按照如下的方式进行类的操作：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;对象的名称&gt;</span>.<span class="params">&lt;类的属性&gt;</span>;<span class="comment">// 表示调用类中的属性</span></span><br><span class="line"><span class="params">&lt;对象的名称&gt;</span>.<span class="params">&lt;类的方法&gt;</span>();<span class="comment">// 表示调用类中的方法</span></span><br></pre></td></tr></table></figure><h4 id="举个栗子-3"><a href="#举个栗子-3" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">per.<span class="attribute">name</span>=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">per.<span class="attribute">age</span>=18;</span><br><span class="line">per.tags();</span><br></pre></td></tr></table></figure><h3 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>堆内存：存储对象的属性及其赋值，需要使用关键字<code>new</code>来分配空间。</p><p>栈内存：存储堆内存的地址。</p><p>一旦分配了堆内存的空间，其内就会存储类中定义的属性及其赋值，并且属性的赋值都是其对应的数据类型的默认值。</p><h4 id="举个栗子-4"><a href="#举个栗子-4" class="headerlink" title="举个栗子"></a>举个栗子</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name+<span class="string">""</span>);</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age+<span class="string">""</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Person0 per=null;</span><br><span class="line">       per=<span class="keyword">new</span> Person0();</span><br><span class="line">       per.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">       per.age=<span class="number">18</span>;</span><br><span class="line">       per.tags();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name+<span class="string">""</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person1 per=<span class="keyword">new</span> Person1();</span><br><span class="line">        per.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">        per.age=<span class="number">18</span>;</span><br><span class="line">        per.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="/images/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>方式一和方式二两种对象实例化方式的区别仅在于图示中的①和②；方式一的先声明后实例化对象实际就是把①与②分步骤进行，方式二的声明并实例化对象实际就是把①和②组合进行。</p><h3 id="对象的引用传递"><a href="#对象的引用传递" class="headerlink" title="对象的引用传递"></a>对象的引用传递</h3><p>引用传递的精髓：同一块堆内存空间，可以同时被多个栈内存所指向，不同的栈可以修改同一块堆内存的内容。</p><h4 id="举个栗子-5"><a href="#举个栗子-5" class="headerlink" title="举个栗子"></a>举个栗子</h4><h5 id="一"><a href="#一" class="headerlink" title="一"></a>一</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name+<span class="string">""</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person2 per0=<span class="keyword">new</span> Person2();</span><br><span class="line">        per0.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">        per0.age=<span class="number">18</span>;</span><br><span class="line">        Person2 per1=per0;</span><br><span class="line">        per1.age=<span class="number">19</span>;</span><br><span class="line">        per0.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分配图示如下：</p><p><img src="/images/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt></p><h5 id="二"><a href="#二" class="headerlink" title="二"></a>二</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tags</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name: "</span>+name+<span class="string">""</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age: "</span>+age+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person3 per0=<span class="keyword">new</span> Person3();</span><br><span class="line">        per0.name=<span class="string">"NIMITIZ"</span>;</span><br><span class="line">        per0.age=<span class="number">18</span>;</span><br><span class="line">        Person3 per1=<span class="keyword">new</span> Person3();</span><br><span class="line">        per1.name=<span class="string">"NIMITIZ-FBH"</span>;</span><br><span class="line">        per1.age=<span class="number">19</span>;</span><br><span class="line">        per0=per1;</span><br><span class="line">        per0.age=<span class="number">17</span>;</span><br><span class="line">        per0.tags();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分配图示如下：</p><p><img src="/images/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt></p><hr><p>先折腾到这里，以后再补充 σ`∀´)σ 。</p><p>本文整理自</p><p><a href="https://blog.csdn.net/wei_zhi/article/details/52745268" target="_blank" rel="noopener">Java类和对象 详解（一）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB程序结构</title>
      <link href="/2020/10/10/MATLAB%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2020/10/10/MATLAB%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>MATLAB语言有三种常用的程序控制结构：顺序结构、选择结构和循环结构。本文主要记录与这三种程序控制结构相关的部分内容作为笔记 (っ・Д・)っ 。</p><a id="more"></a><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>MATLAB语言的数据输入、数据处理和数据输出命令都是按照顺序结构执行的。</p><h3 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h3><p>MATLAB语言可使用<code>input</code>函数从键盘输入数据，其调用方式如下：</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span>=input(<span class="string">'提示信息'</span>)</span><br></pre></td></tr></table></figure><p><code>提示信息</code>表示字符串，用于提示用户应该输入什么数据，等待用户从键盘输入数据，赋值给变量<code>x</code>。</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="meta">x</span><span class="meta">=input(</span><span class="string">'输入变量：'</span>)</span><br><span class="line">输入变量：3</span><br><span class="line"></span><br><span class="line"><span class="meta">x</span> =</span><br><span class="line"></span><br><span class="line">     3</span><br></pre></td></tr></table></figure><p>执行该语句时，命令行窗口显示<code>输入变量：</code>，然后等待用户从键盘输入<code>x</code>的值。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">str</span>=<span class="keyword">input</span>(<span class="string">'提示信息'</span>,<span class="string">'s'</span>)</span><br></pre></td></tr></table></figure><p>用于用户输入一个字符串，赋值给字符变量<code>str</code>。</p><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">str</span>=<span class="keyword">input</span>(<span class="string">'NAME:'</span>,<span class="string">'s'</span>)</span><br><span class="line">NAME:NIMITIZ</span><br><span class="line"></span><br><span class="line"><span class="keyword">str</span> =</span><br><span class="line"></span><br><span class="line">    <span class="string">'NIMITIZ'</span></span><br></pre></td></tr></table></figure><h3 id="数据的输出"><a href="#数据的输出" class="headerlink" title="数据的输出"></a>数据的输出</h3><p>MATLAB语言可以使用<code>disp</code>函数实现在命令行窗口显示输出信息，其调用方式如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">disp</span><span class="params">(<span class="string">'输出信息'</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>输出信息既可以是字符串，也可以是矩阵。</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; disp(<span class="string">'NIMITIZ'</span>)</span><br><span class="line">NIMITIZ</span><br><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">&gt;&gt; disp(A)</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>MATLAB语言中的选择结构有三种常用语句：<code>if</code>语句、<code>switch</code>语句和<code>try</code>语句。</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>与C语言很类似，但是<strong><code>if</code>和<code>end</code>必须配对使用</strong>，<code>end</code>置于循环体的末尾。</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件</span><br><span class="line">语句组</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span></span><br><span class="line">语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">语句组<span class="number">2</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span></span><br><span class="line">语句组<span class="number">1</span></span><br><span class="line">elseif 条件<span class="number">2</span></span><br><span class="line">语句组<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">elseif 条件m</span><br><span class="line">语句组m</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">语句组n</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="symbol">x</span>=input(<span class="string">'x：'</span>);</span><br><span class="line"><span class="symbol">x</span>：<span class="number">3</span></span><br><span class="line">&gt;&gt; <span class="keyword">if</span> <span class="symbol">x</span>&gt;<span class="number">0</span></span><br><span class="line"><span class="symbol">y</span>=<span class="built_in">sqrt</span>(<span class="symbol">x</span>);</span><br><span class="line">disp([<span class="string">'y='</span>,num2str(<span class="symbol">y</span>)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="symbol">y</span>=<span class="number">1.7321</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="symbol">x</span>=input(<span class="string">'x：'</span>);</span><br><span class="line"><span class="symbol">x</span>：<span class="number">-3</span></span><br><span class="line">&gt;&gt; <span class="keyword">if</span> <span class="symbol">x</span>&gt;<span class="number">0</span></span><br><span class="line"><span class="symbol">y</span>=<span class="built_in">sqrt</span>(<span class="symbol">x</span>);</span><br><span class="line">disp([<span class="string">'y='</span>,num2str(<span class="symbol">y</span>)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>在MATLAB语言中，<code>switch</code>语句也用于多项选择。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式</span><br><span class="line"><span class="keyword">case</span> 表达式<span class="number">1</span></span><br><span class="line">     语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> 表达式<span class="number">2</span></span><br><span class="line">     语句组<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> 表达式m</span><br><span class="line">     语句组m</span><br><span class="line">otherwise</span><br><span class="line">     语句组n</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h3><p>在MATLAB语言中，<code>try</code>语句是一种试探性执行语句，其格式为：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">语句组<span class="number">2</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>try</code>语句先试探执行<code>语句组1</code>，如果<code>语句组1</code>在执行过程中出现错误，则将错误信息赋值给系统变量<code>lasterr</code>，并转去执行<code>语句组2</code>。</p><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>用<code>try</code>语句求解函数<code>y=x*sin(x)</code>的值，自变量<code>x</code>的取值范围[0,pi]，步长为<code>pi/10</code>。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span> x=<span class="number">0</span><span class="symbol">:pi/</span><span class="number">10</span><span class="symbol">:pi</span>;</span><br><span class="line"><span class="meta">&gt;&gt;</span> try</span><br><span class="line">y=x*sin(x);</span><br><span class="line">catch</span><br><span class="line">y=x.*sin(x);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="meta">&gt;&gt;</span> y</span><br><span class="line"></span><br><span class="line">y =</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span>    <span class="number">0</span>.0971    <span class="number">0</span>.<span class="number">3693</span>    <span class="number">0</span>.<span class="number">7625</span>    <span class="number">1.1951</span>    <span class="number">1.5708</span>    <span class="number">1.7927</span>    <span class="number">1.7791</span>    <span class="number">1.4773</span>    <span class="number">0</span>.<span class="number">8737</span>    <span class="number">0</span>.<span class="number">0000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span> lasterr</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="string">'错误使用  * </span></span><br><span class="line"><span class="string">     用于矩阵乘法的维度不正确。请检查并确保第一个矩阵中的列数与第二个矩阵中的行数匹配。要执行按元素相乘，请使用 '</span>.*<span class="string">'。'</span></span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>MATLAB语言有两种循环结构语句：<code>for</code>循环语句和<code>while</code>循环语句。其使用方式都与C语言类似。</p><h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=表达式<span class="number">1</span>:表达式<span class="number">2</span>:表达式<span class="number">3</span></span><br><span class="line">    循环体语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><code>表达式1</code>的值为循环变量的初始值，<code>表达式2</code>的值为步长，<code>表达式3</code>的值为循环变量的终值；</li><li>当步长为1时，可以省略<code>表达式2</code>；</li><li>当步长为负值时，初值大于终值；</li><li>循环体内不能对循环变量重新设置；</li><li>for循环允许嵌套使用；</li><li><code>for</code>和<code>end</code>配套使用。</li></ul><h4 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">sum</span>=<span class="number">0</span>;</span><br><span class="line">&gt;&gt; <span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">100</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="built_in">sum</span>+k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&gt;&gt; <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式</span><br><span class="line">  循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>与C语言类似，没什么好记录的（～￣▽￣～）。</p><h4 id="举个栗子-3"><a href="#举个栗子-3" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">sum</span>=<span class="number">0</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">n</span>=<span class="number">0</span>;</span><br><span class="line">&gt;&gt; while <span class="built_in">sum</span>&lt;<span class="number">800</span></span><br><span class="line"><span class="built_in">n</span>=<span class="built_in">n</span>+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">sum</span>=<span class="built_in">sum</span>+<span class="built_in">n</span>;</span><br><span class="line">end</span><br><span class="line">&gt;&gt; <span class="built_in">n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">n</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">40</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">820</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冯·诺伊曼结构与哈佛结构的简要笔记</title>
      <link href="/2020/10/02/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/10/02/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h2><p> 冯·诺伊曼结构也被称为普林斯顿结构，是一种将指令（程序）和数据混合存储在同一个存储器中、共享数据总线的计算机设计概念结构。</p><a id="more"></a><p><img src="/images/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%BB%93%E6%9E%84%EF%BC%88%E7%AE%80%E5%9B%BE%EF%BC%89.png" alt></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>指令（程序）和数据都以二进制数存储于存储器中，可按地址寻访</li><li>指令（程序）由操作码（指明需要进行的操作）和地址码（指明需要操作的数据在存储器中的地址）组成</li><li>指令（程序）顺序执行</li><li>以运算器为中心，输入/输出设备与存储器之间的数据传输均通过运算器中转</li></ul><p><strong>注：早期的冯·诺伊曼计算机以运算器为中心，但这会导致运算效率的降低（因为数据的传输均通过运算器中转），现代计算机对其进行了改进，以存储器为中心。</strong></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/images/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%E7%BB%93%E6%9E%84%EF%BC%88%E6%97%A9%E6%9C%9F%EF%BC%89.png" alt></p><ul><li><p>运算器：主要执行各种算术运算、位运算和逻辑运算的部件，也叫算术逻辑单元（ALU）；ALU与浮点运算单元（FPU）不同，FPU仅对浮点数进行操作</p></li><li><p>控制器：由指令寄存器、程序计数器、操作控制器、指令译码器和时序产生器组成，负责协调计算机的有序运行；其与运算器共同组成中央处理器（CPU）</p><ul><li>指令寄存器：用来保存当前执行或即将执行的指令的一种寄存器</li><li>程序计数器：指明程序中下一次要执行的指令地址的一种计数器</li><li>操作控制器：根据时序信号和操作码内容来产生操作控制信号，保障指令的顺利执行</li><li>指令译码器：通过分析操作码来识别出需要进行的操作</li><li>时序产生器：产生定时脉冲信号，为计算机的运行提供时间标志</li></ul></li><li><p>存储器</p><ul><li>内部存储器：即运行内存</li><li>外部存储器：即磁盘、闪存等非易失性存储器 </li></ul></li><li><p>输入设备：没什么好说明的 (・ε・) </p></li><li><p>输出设备：同上 (・ε・) </p></li></ul><h3 id="优、缺点"><a href="#优、缺点" class="headerlink" title="优、缺点"></a>优、缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以将指令当作数据，有利于程序的修改</li><li>指令和数据共用同一存储器，可提高存储器的利用率</li><li>总线结构相对简单</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于取指令和取操作数使用的是同一数据总线，因此不能同时取指令和取操作数，必须采用分时复用的方式进行，这样就会影响了CPU的运行效率</li></ul><h2 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h2><p>哈佛结构是一种将指令（程序）和数据分开存储到不同的存储器的一种计算机设计概念结构。</p><p><img src="/images/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%EF%BC%88%E7%AE%80%E5%9B%BE%EF%BC%89.png" alt></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>使用两个独立的存储器分别存储数据和指令，每个存储器独立编址、独立访问</li><li>两个存储器都有独立的数据总线和地址总线与CPU进行通信</li></ul><h3 id="优、缺点-1"><a href="#优、缺点-1" class="headerlink" title="优、缺点"></a>优、缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可同时取指令和取操作数</li><li>可以采取流水线的方式使指令顺序执行时的效率更高</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>结构设计比较复杂</li><li>较难修改指令，不利于程序的升级</li><li>数据存储和指令存储相互独立，会导致RAM的利用率不高</li></ul><hr><p>资料整理自</p><p><a href="https://blog.csdn.net/u014470361/article/details/79774331?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160161228619195246647465%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160161228619195246647465&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-9-79774331.pc_first_rank_v2_rank_v28&utm_term=%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84&spm=1018.2118.3001.4187" target="_blank" rel="noopener">什么是冯诺依曼结构、哈佛结构、改进型哈佛结构？</a></p><p><a href="https://blog.csdn.net/starshinning975/article/details/53089273" target="_blank" rel="noopener">冯诺依曼计算机结构</a></p><p><a href="https://blog.csdn.net/qiangwudi9847/article/details/102486255" target="_blank" rel="noopener">冯诺依曼结构概述</a></p><p><a href="https://blog.csdn.net/farmwang/article/details/50086891?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160161980719724835830145%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160161980719724835830145&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-50086891.pc_first_rank_v2_rank_v28&utm_term=cpu%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E5%99%A8&spm=1018.2118.3001.4187" target="_blank" rel="noopener">cpu控制器</a></p><p>如有补充或错误指出，请大佬在评论区留言，感激不尽(≧∀≦)ゞ。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB矩阵的分析</title>
      <link href="/2020/09/28/MATLAB%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2020/09/28/MATLAB%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><p>MATLAB语言用<code>det()</code>函数求解方阵的行列式的值。</p><a id="more"></a><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; D=det(A)</span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">     <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的秩和迹"><a href="#矩阵的秩和迹" class="headerlink" title="矩阵的秩和迹"></a>矩阵的秩和迹</h2><h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><p>与矩阵线性无关的行数或列数称为矩阵的秩。MATLAB语言用<code>rank()</code>函数求解矩阵的秩。</p><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; X=rank(A)</span><br><span class="line"></span><br><span class="line">X =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="方阵的迹"><a href="#方阵的迹" class="headerlink" title="方阵的迹"></a>方阵的迹</h3><p>一个方阵的迹等于方阵的对角线元素之和，也等于方阵的特征值之和。MATLAB语言用<code>trace()</code>函数求解方阵的迹。</p><h4 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; x=trace(A)</span><br><span class="line"></span><br><span class="line">x =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的逆和伪逆"><a href="#矩阵的逆和伪逆" class="headerlink" title="矩阵的逆和伪逆"></a>矩阵的逆和伪逆</h2><h3 id="方阵的逆矩阵"><a href="#方阵的逆矩阵" class="headerlink" title="方阵的逆矩阵"></a>方阵的逆矩阵</h3><p>对于一个方阵A，如果存在一个同阶方阵B，使得<code>A*B=B*A=I（I为单位矩阵）</code>，则称B为A的逆矩阵，A也为B的逆矩阵。MATLAB语言用<code>inv()</code>函数求解一个方阵的逆矩阵。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; B=inv(A)</span><br><span class="line"></span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.2000</span>    <span class="number">0.4000</span>   <span class="number">-0.2000</span></span><br><span class="line">   <span class="number">-0.4000</span>    <span class="number">0.2000</span>    <span class="number">0.4000</span></span><br><span class="line">    <span class="number">0.8000</span>   <span class="number">-0.4000</span>    <span class="number">0.2000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A*B</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="矩阵的伪逆矩阵"><a href="#矩阵的伪逆矩阵" class="headerlink" title="矩阵的伪逆矩阵"></a>矩阵的伪逆矩阵</h3><p>如果矩阵A不是一个方阵，或者A为非满秩矩阵，那么就不存在逆矩阵，但可以求广义上的逆矩阵，称为伪逆矩阵。MATLAB语言用<code>pinv()</code>函数求解伪逆矩阵。</p><h4 id="举个栗子-3"><a href="#举个栗子-3" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; B=pinv(A)</span><br><span class="line"></span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.1667</span>    <span class="number">0.3333</span></span><br><span class="line">   <span class="number">-0.3333</span>    <span class="number">0.3333</span></span><br><span class="line">    <span class="number">0.8333</span>   <span class="number">-0.3333</span></span><br></pre></td></tr></table></figure><h3 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h3><p>在线性代数中，可以用矩阵求逆的方法求解线性方程组的解。</p><h4 id="举个栗子-4"><a href="#举个栗子-4" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>求解如下线性方程组。</p><p><img src="/images/MATLAB%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%86%E6%9E%90/%E9%99%84%E6%B3%A8.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>;<span class="number">3</span> <span class="number">1</span> <span class="number">-1</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">&gt;&gt; b=[<span class="number">3</span>;<span class="number">6</span>;<span class="number">4</span>];</span><br><span class="line">&gt;&gt; x=inv(a)*b</span><br><span class="line"></span><br><span class="line">x =</span><br><span class="line"></span><br><span class="line">    <span class="number">2.2500</span></span><br><span class="line">    <span class="number">0.5000</span></span><br><span class="line">    <span class="number">1.2500</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h2><p>设A为n阶方阵，使得等式<code>Av=Dv</code>成立，则D称为A的特征值，向量v称为A的特征向量。MATLAB语言用<code>eig()</code>函数求解方阵的特征值和特征向量，常用的两种格式：</p><ul><li><code>E=eig(A)</code>求解方阵A的特征值，构成向量E；</li><li><code>[v,D]=eig(A)</code>求解方阵A的特征值，构成对角矩阵，并求解A的特征向量v。</li></ul><h3 id="举个栗子-5"><a href="#举个栗子-5" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span> <span class="number">0.25</span>;<span class="number">0.5</span> <span class="number">0.25</span> <span class="number">2</span>];</span><br><span class="line">&gt;&gt; [v,D]=eig(A)</span><br><span class="line"></span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.5334</span>   <span class="number">-0.6834</span>    <span class="number">0.6435</span></span><br><span class="line">   <span class="number">-0.8456</span>   <span class="number">-0.5326</span>    <span class="number">0.3174</span></span><br><span class="line">   <span class="number">-0.0211</span>    <span class="number">0.4992</span>    <span class="number">0.6966</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.6246</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">1.0488</span>         <span class="number">0</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>    <span class="number">2.5758</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A*v</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.3332</span>   <span class="number">-0.7168</span>    <span class="number">1.6574</span></span><br><span class="line">    <span class="number">0.5282</span>   <span class="number">-0.5586</span>    <span class="number">0.8176</span></span><br><span class="line">    <span class="number">0.0132</span>    <span class="number">0.5236</span>    <span class="number">1.7942</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; v*D</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.3332</span>   <span class="number">-0.7168</span>    <span class="number">1.6574</span></span><br><span class="line">    <span class="number">0.5282</span>   <span class="number">-0.5586</span>    <span class="number">0.8176</span></span><br><span class="line">    <span class="number">0.0132</span>    <span class="number">0.5236</span>    <span class="number">1.7942</span></span><br></pre></td></tr></table></figure><h3 id="附注-1"><a href="#附注-1" class="headerlink" title="附注"></a>附注</h3><p>特征值还可应用于求解一元多次方程的根。先将方程的多项式系数组成行向量a，然后用<code>compan()</code>函数构造成伴随矩阵A，最后再用<code>eig()</code>函数求解A的特征值，该特征值就是方程的根。</p><h4 id="举个栗子-6"><a href="#举个栗子-6" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>求解如下的一元多次方程。</p><p><img src="/images/MATLAB%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%86%E6%9E%90/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E6%96%B9%E7%A8%8B.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">1</span> <span class="number">-5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">-6</span> <span class="number">0</span>];</span><br><span class="line">&gt;&gt; A=compan(a);</span><br><span class="line">&gt;&gt; x1=eig(A)</span><br><span class="line"></span><br><span class="line">x1 =</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span></span><br><span class="line">    <span class="number">3.0000</span></span><br><span class="line">    <span class="number">2.0000</span></span><br><span class="line">    <span class="number">1.0000</span></span><br><span class="line">   <span class="number">-1.0000</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的信息获取函数"><a href="#矩阵的信息获取函数" class="headerlink" title="矩阵的信息获取函数"></a>矩阵的信息获取函数</h2><h3 id="size-函数"><a href="#size-函数" class="headerlink" title="size()函数"></a>size()函数</h3><p>MATLAB语言可以用<code>size()</code>函数来获取矩阵的行数和列数。函数的调用方式如下：</p><ul><li><code>D=size(A)</code>返回一个由行数和列数构成的两个元素的行向量</li><li><code>[M,N]=size(A)</code>返回矩阵A的行数为<code>M</code>，列数为<code>N</code></li></ul><h4 id="举个栗子-7"><a href="#举个栗子-7" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; D=size(A)</span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; [M,N]=size(A)</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="length-函数"><a href="#length-函数" class="headerlink" title="length()函数"></a>length()函数</h3><p>MATLAB语言可以用<code>length()</code>函数来获取矩阵的行数和列数的较大者。函数的调用方式如下：</p><ul><li><code>d=length(A)</code></li></ul><h4 id="举个栗子-8"><a href="#举个栗子-8" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; d=length(A)</span><br><span class="line"></span><br><span class="line">d =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="numel-函数"><a href="#numel-函数" class="headerlink" title="numel()函数"></a>numel()函数</h3><p>MATLAB语言可以用<code>numel()</code>函数来获取矩阵的元素的总个数。函数的调用方式如下：</p><ul><li><code>n=numel(A)</code></li></ul><h4 id="举个栗子-9"><a href="#举个栗子-9" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; n=numel(A)</span><br><span class="line"></span><br><span class="line">n =</span><br><span class="line"></span><br><span class="line">     <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>free命令笔记</title>
      <link href="/2020/09/25/free%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/25/free%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><code>free</code>命令用于列出Linux中缓存、物理内存以及虚拟内存的使用情况，是Linux监控中比较常用的命令之一。</p><a id="more"></a><h2 id="命令格式及选项"><a href="#命令格式及选项" class="headerlink" title="命令格式及选项"></a>命令格式及选项</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span> &lt;选项&gt;</span><br></pre></td></tr></table></figure><h3 id="命令常用选项"><a href="#命令常用选项" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><p><code>-b</code>        以<code>Byte</code>为单位列出使用情况</p><p><code>-k</code>        以<code>KB</code>为单位列出使用情况</p><p><code>-m</code>        以<code>MB</code>为单位列出使用情况</p><p><code>-g</code>        以<code>GB</code>为单位列出使用情况</p><p><code>-h</code>        以合适的单位列出使用情况</p><p><code>-t</code>        显示每一列的总和</p><p><code>-s &lt;num&gt;</code>        每<code>num</code>秒刷新一次使用情况</p><p><code>-c &lt;num&gt;</code>        刷新<code>num</code>次使用情况，常与<code>-s &lt;num&gt;</code>搭配使用</p><p><code>-o</code>        不显示缓冲区调节列（Ubuntu 20.04 LTS不可用）</p><p><code>-V</code>        显示该程序的版本信息（Ubuntu 20.04 LTS不可用）</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span></span><br></pre></td></tr></table></figure><p><img src="/images/free%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/free.png" alt></p><h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><p><code>共享（shared）</code>        一般是临时文件系统使用的内存</p><p><code>缓冲/缓存（buff/cache）</code>        内核缓冲区以及页面缓存和Slab分配机制使用的内存</p><p><code>可用（available）</code>        预计可被新启动的应用程序使用的内存（排除交换空间，但包括页面缓存在内，并且                                          不是所有的可回收的Slab内存都可真正被回收，因为可能有被占用的部分）</p><h4 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h4><h5 id="交换空间（Swap-Space）"><a href="#交换空间（Swap-Space）" class="headerlink" title="交换空间（Swap Space）"></a>交换空间（Swap Space）</h5><p>交换空间是<strong>磁盘</strong>上的一块区域，<strong>既可以是一个分区，也可以是一个文件</strong>。当物理内存使用紧张时，Linux会把内存中不常用的数据保存到交换空间，以空出更多的物理内存供其他进程使用；当系统需要访问已经存储到交换空间中的数据时，则将交换空间中相应的数据加载到内存。适当使用交换空间不会对系统运行造成负面影响，但使用过多会导致系统的读写性能有较为明显的下降（因为频繁地对磁盘读写，而磁盘的读写速度远低于内存）。</p><h5 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h5><p>把进程读取过的数据尽量留在内存中，尽量把对磁盘的访问转变为对内存的访问（当有进程需要读取该数据时，首先检查该数据是否还存在于页面缓存（即内存），如果是，则直接从内存读取数据；如果不是，再从磁盘读取数据），从而减少对磁盘的读取。</p><h6 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h6><p>Linux中内存都以“<strong>页</strong>”为单位进行管理，通常大小为<strong>4KB</strong>。</p><h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><p>当磁盘中的数据被调入内存但未被进程使用时，其被存储在缓冲区中，等待被进程调用。</p><h5 id="Slab分配机制"><a href="#Slab分配机制" class="headerlink" title="Slab分配机制"></a>Slab分配机制</h5><p>如果一个进程需要频繁地申请和释放内存，那么通过Slab分配机制它可以预先申请一部分的内存以供备用，当该进程需要使用内存时，则直接对该部分内存进行访问读写，而不需要再由操作系统分配内存，从而间接提高该进程读写内存的速度（因为省去了进程申请内存及操作系统为该进程分配内存的时间）。该机制还可有助于解决内存碎片化的问题，因为有些进程对内存的申请和释放非常频繁，而这些进程实际每个只使用不多于一个页面（4KB）的内存空间，但每个进程却都需要向操作系统申请一个页面，从而导致内存利用率的下降及带来碎片化问题，因此需要Slab分配机制，把若干个进程使用的内存空间分配于同一页面内，这样就不需要为每一个进程都分配页面，从而节省了内存空间，减少内存的碎片化。</p><h2 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h2><p><code>free</code>命令列出的信息是从<code>/proc/meminfo</code>文件中获取的，可使用<code>cat</code>命令查看该文件。</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cat</span> /<span class="meta">proc</span>/meminfo</span><br></pre></td></tr></table></figure><hr><p>本文整理自</p><p><a href="https://linux.cn/article-9232-1.html" target="_blank" rel="noopener">6 个例子让初学者掌握 free 命令</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/7994666.html" target="_blank" rel="noopener">linux free 命令</a></p><p><a href="http://www.pulpcode.cn/2017/02/01/user-buffer-and-kernel-buffer/" target="_blank" rel="noopener">用户进程缓冲区和内核缓冲区</a></p><p><a href="https://blog.csdn.net/wenqian1991/article/details/25652147" target="_blank" rel="noopener">【Linux 内核】内存管理（三）slab分配器</a></p><p>因为涉及到比较多Linux内核方面的知识，而我又是个初（菜）学（鸡）者 (つд⊂) ，因此本文可能存在或多或少的错误 (◞‸◟) ，请大佬多多指教，非常感谢 (≧∀≦)ゞ 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>You-Get的使用</title>
      <link href="/2020/09/23/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/23/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇关于You-Get的安装的文章，也简单折腾了一下，不过很快就忘了这件事 (´ﾟдﾟ`) ，直到今天才想起来，继续折腾（真的不是我想咕咕咕 ( ˘･з･) ）。</p><p>本文记录了You-Get的常用命令。</p><a id="more"></a><h2 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h2><p>在CMD中输入并运行以下命令即可执行下载操作。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">you-<span class="built_in">get</span> &lt;<span class="built_in">URL</span>&gt;<span class="comment"># &lt;URL&gt;是指视频/音频/图片的链接，下同</span></span><br></pre></td></tr></table></figure><p><img src="/images/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.png" alt></p><p>默认下载路径<code>C:\Users\Administrator</code>。</p><h2 id="暂停-继续下载-amp-amp-自定义下载路径"><a href="#暂停-继续下载-amp-amp-自定义下载路径" class="headerlink" title="暂停/继续下载&amp;&amp;自定义下载路径"></a>暂停/继续下载&amp;&amp;自定义下载路径</h2><p>使用以下命令可自定义下载路径。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">you-<span class="built_in">get</span> -o <span class="string">"&lt;目标路径&gt;"</span> &lt;<span class="built_in">URL</span>&gt;</span><br></pre></td></tr></table></figure><p>在下载过程中，如需暂停下载，则在CMD中使用<code>Ctrl + C</code>组合键，未下载完成的文件以<code>DOWNLOAD 文件 (.download)</code>保存在默认/自定义路径；使用原命令（上一条命令）即可恢复下载。</p><p><img src="/images/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%9A%82%E5%81%9C%E4%B8%8B%E8%BD%BD.png" alt></p><h2 id="自定义输出文件名"><a href="#自定义输出文件名" class="headerlink" title="自定义输出文件名"></a>自定义输出文件名</h2><p>使用<code>-O</code>选项可自定义下载后的文件名。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">you-get -O <span class="tag">&lt;<span class="name">自定义的文件名</span>&gt;</span> <span class="tag">&lt;<span class="name">URL</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D.png" alt></p><h2 id="查看详细信息"><a href="#查看详细信息" class="headerlink" title="查看详细信息"></a>查看详细信息</h2><p>使用<code>-i</code>选项可查看下载源的详细信息（文件格式、分辨率，文件大小）；使用<code>--format=&lt;&gt;</code>选项可选择需要下载的分辨率和文件格式（You-Get默认下载最高画质）。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">you-<span class="builtin-name">get</span> -i &lt;URL&gt;# 查看详细信息，信息中的<span class="string">"- format:"</span>表示所选项</span><br><span class="line">you-<span class="builtin-name">get</span> <span class="attribute">--format</span>=&lt;&gt; &lt;URL&gt;# 选择需要下载的分辨率和文件格式，<span class="string">"&lt;&gt;"</span>为所选项</span><br></pre></td></tr></table></figure><p><img src="/images/You-Get%E7%9A%84%E4%BD%BF%E7%94%A8/%E9%80%89%E6%8B%A9.png" alt></p><p><strong>不同选项可组合使用。</strong></p><h2 id="升级You-Get"><a href="#升级You-Get" class="headerlink" title="升级You-Get"></a>升级You-Get</h2><p>网站的不定期更新可能会导致You-Get无法解析下载这些视频/音频/图片，因此建议保持电脑上的You-Get为最新版本。更新You-Get的方法如下：</p><p>在CMD中执行以下命令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> <span class="comment">--upgrade you-get</span></span><br></pre></td></tr></table></figure><p>You-Get的官方镜像源在国外，因此下载速度可能会比较慢，可使用以下命令从清华大学开源软件镜像站下载。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade you-<span class="builtin-name">get</span> <span class="attribute">--index-url</span>=https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><hr><p>本文整理自</p><p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方中文说明</a></p><p><a href="https://blog.lussac.net/archives/4/" target="_blank" rel="noopener"> You-Get的安装及使用方法 </a></p>]]></content>
      
      
      
        <tags>
            
            <tag> You-Get </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB矩阵及其运算</title>
      <link href="/2020/09/22/MATLAB%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/22/MATLAB%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>矩阵是MATLAB最基本和最重要的数据对象，因为MATLAB中大部分的运算是基于矩阵运算。</p><a id="more"></a><h2 id="矩阵的创建"><a href="#矩阵的创建" class="headerlink" title="矩阵的创建"></a>矩阵的创建</h2><h3 id="直接输入矩阵"><a href="#直接输入矩阵" class="headerlink" title="直接输入矩阵"></a>直接输入矩阵</h3><p>MATLAB语言最简单的创建矩阵的方法是在命令窗口直接输入矩阵；规则如下：</p><ul><li><p>将所有矩阵元素置于同一<code>[]</code>内</p></li><li><p>同一行的不同元素之间用<code>,</code>或者<code>空格符</code>来分隔</p></li><li><p>不同行用<code>;</code>或者<code>回车符</code>分隔</p></li></ul><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>生成矩阵A：</p><p><img src="/images/MATLAB%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E7%9F%A9%E9%98%B5.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">6</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">6</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="冒号生成矩阵"><a href="#冒号生成矩阵" class="headerlink" title="冒号生成矩阵"></a>冒号生成矩阵</h3><p>在MATLAB语言中，可利用<code>;</code>生成一个步长相等的一维数组或行向量；规则如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">x=<span class="string">a:</span><span class="string">step:</span>b</span><br></pre></td></tr></table></figure><ul><li><p><code>a</code>是一维数组或行向量的第一个元素，<code>b</code>是其最后一个元素，<code>step</code>是步长增量</p></li><li><p>冒号表达式可生成一个由<code>a</code>开始到<code>b</code>结束，以步长<code>step</code>自增或自减（<code>step</code>&lt;0，<code>b</code>&lt;<code>a</code>）的一维数组或行向量</p></li><li><p>如果步长<strong><code>step</code>=1</strong>，则冒号表达式可以省略步长</p></li></ul><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=<span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X3=<span class="number">10</span>:<span class="number">-2</span>:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">X3 =</span><br><span class="line"></span><br><span class="line">    <span class="number">10</span>     <span class="number">8</span>     <span class="number">6</span>     <span class="number">4</span>     <span class="number">2</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="利用函数生成矩阵"><a href="#利用函数生成矩阵" class="headerlink" title="利用函数生成矩阵"></a>利用函数生成矩阵</h3><h4 id="linspace函数"><a href="#linspace函数" class="headerlink" title="linspace函数"></a>linspace函数</h4><p>MATLAB语言可用<code>linspace</code>函数生成初值、终值和元素个数已知的一维数组或行向量，元素之间是等差数列；规则如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span>=linspace(a,b,n)</span><br></pre></td></tr></table></figure><ul><li><p><code>a</code>和<code>b</code>分别是生成一维数组或行向量的初值和终值，<code>n</code>是元素个数；<strong>当<code>n</code>省略时，自动生成100个元素</strong></p></li><li><p>当<code>a</code>&gt;<code>b</code>，元素之间是等差递减；当<code>a</code>&lt;<code>b</code>，元素之间是等差递增</p></li></ul><h5 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=linspace(<span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">    <span class="number">10</span>     <span class="number">9</span>     <span class="number">8</span>     <span class="number">7</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X3=linspace(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X3 =</span><br><span class="line"></span><br><span class="line">  列 <span class="number">1</span> 至 <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">1.0909</span>    <span class="number">1.1818</span>    <span class="number">1.2727</span>    <span class="number">1.3636</span>    <span class="number">1.4545</span>    <span class="number">1.5455</span>    <span class="number">1.6364</span>    <span class="number">1.7273</span>    <span class="number">1.8182</span>    <span class="number">1.9091</span>    <span class="number">2.0000</span>    <span class="number">2.0909</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">14</span> 至 <span class="number">26</span></span><br><span class="line"></span><br><span class="line">    <span class="number">2.1818</span>    <span class="number">2.2727</span>    <span class="number">2.3636</span>    <span class="number">2.4545</span>    <span class="number">2.5455</span>    <span class="number">2.6364</span>    <span class="number">2.7273</span>    <span class="number">2.8182</span>    <span class="number">2.9091</span>    <span class="number">3.0000</span>    <span class="number">3.0909</span>    <span class="number">3.1818</span>    <span class="number">3.2727</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">27</span> 至 <span class="number">39</span></span><br><span class="line"></span><br><span class="line">    <span class="number">3.3636</span>    <span class="number">3.4545</span>    <span class="number">3.5455</span>    <span class="number">3.6364</span>    <span class="number">3.7273</span>    <span class="number">3.8182</span>    <span class="number">3.9091</span>    <span class="number">4.0000</span>    <span class="number">4.0909</span>    <span class="number">4.1818</span>    <span class="number">4.2727</span>    <span class="number">4.3636</span>    <span class="number">4.4545</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">40</span> 至 <span class="number">52</span></span><br><span class="line"></span><br><span class="line">    <span class="number">4.5455</span>    <span class="number">4.6364</span>    <span class="number">4.7273</span>    <span class="number">4.8182</span>    <span class="number">4.9091</span>    <span class="number">5.0000</span>    <span class="number">5.0909</span>    <span class="number">5.1818</span>    <span class="number">5.2727</span>    <span class="number">5.3636</span>    <span class="number">5.4545</span>    <span class="number">5.5455</span>    <span class="number">5.6364</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">53</span> 至 <span class="number">65</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5.7273</span>    <span class="number">5.8182</span>    <span class="number">5.9091</span>    <span class="number">6.0000</span>    <span class="number">6.0909</span>    <span class="number">6.1818</span>    <span class="number">6.2727</span>    <span class="number">6.3636</span>    <span class="number">6.4545</span>    <span class="number">6.5455</span>    <span class="number">6.6364</span>    <span class="number">6.7273</span>    <span class="number">6.8182</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">66</span> 至 <span class="number">78</span></span><br><span class="line"></span><br><span class="line">    <span class="number">6.9091</span>    <span class="number">7.0000</span>    <span class="number">7.0909</span>    <span class="number">7.1818</span>    <span class="number">7.2727</span>    <span class="number">7.3636</span>    <span class="number">7.4545</span>    <span class="number">7.5455</span>    <span class="number">7.6364</span>    <span class="number">7.7273</span>    <span class="number">7.8182</span>    <span class="number">7.9091</span>    <span class="number">8.0000</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">79</span> 至 <span class="number">91</span></span><br><span class="line"></span><br><span class="line">    <span class="number">8.0909</span>    <span class="number">8.1818</span>    <span class="number">8.2727</span>    <span class="number">8.3636</span>    <span class="number">8.4545</span>    <span class="number">8.5455</span>    <span class="number">8.6364</span>    <span class="number">8.7273</span>    <span class="number">8.8182</span>    <span class="number">8.9091</span>    <span class="number">9.0000</span>    <span class="number">9.0909</span>    <span class="number">9.1818</span></span><br><span class="line"></span><br><span class="line">  列 <span class="number">92</span> 至 <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="number">9.2727</span>    <span class="number">9.3636</span>    <span class="number">9.4545</span>    <span class="number">9.5455</span>    <span class="number">9.6364</span>    <span class="number">9.7273</span>    <span class="number">9.8182</span>    <span class="number">9.9091</span>   <span class="number">10.0000</span></span><br></pre></td></tr></table></figure><h4 id="logspace函数"><a href="#logspace函数" class="headerlink" title="logspace函数"></a>logspace函数</h4><p>MATLAB语言可用<code>logspace</code>函数生成一维数组或行向量，元素之间是对数等比数列；规则如下：</p><ul><li>第一个元素是10^<code>a</code>，最后一个元素是10^<code>b</code>，元素个数是<code>n</code></li><li>如果<code>b</code>的值是<code>pi</code>，则该函数生成<code>a</code>到<code>pi</code>之间<code>n</code>个对数等比数列</li></ul><h5 id="举个栗子-3"><a href="#举个栗子-3" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=logspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">   <span class="number">10.0000</span>   <span class="number">12.9155</span>   <span class="number">16.6810</span>   <span class="number">21.5443</span>   <span class="number">27.8256</span>   <span class="number">35.9381</span>   <span class="number">46.4159</span>   <span class="number">59.9484</span>   <span class="number">77.4264</span>  <span class="number">100.0000</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=logspace(<span class="number">1</span>,pi,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">   <span class="number">10.0000</span>    <span class="number">8.7928</span>    <span class="number">7.7314</span>    <span class="number">6.7980</span>    <span class="number">5.9774</span>    <span class="number">5.2558</span>    <span class="number">4.6213</span>    <span class="number">4.0634</span>    <span class="number">3.5729</span>    <span class="number">3.1416</span></span><br></pre></td></tr></table></figure><h3 id="利用文本文件生成矩阵"><a href="#利用文本文件生成矩阵" class="headerlink" title="利用文本文件生成矩阵"></a>利用文本文件生成矩阵</h3><p>MATLAB语言中的矩阵还可以由文本文件（.txt）生成。在<code>软件安装目录\bin</code>路径下新建文本文件并在其中输入矩阵，然后在命令窗口内使用<code>load</code>函数调用该文本文件。</p><p><strong>文件内容不含变量名称，文件名为矩阵变量名。</strong></p><h4 id="举个栗子-4"><a href="#举个栗子-4" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>生成矩阵A：</p><p><img src="/images/MATLAB%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/%E5%88%A9%E7%94%A8%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E7%9F%A9%E9%98%B5.png" alt></p><p><img src="/images/MATLAB%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6.png" alt></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; load A.txt</span><br><span class="line">&gt;&gt; A</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="特殊矩阵的生成"><a href="#特殊矩阵的生成" class="headerlink" title="特殊矩阵的生成"></a>特殊矩阵的生成</h2><h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>MATLAB语言中可使用<code>eye</code>函数来生成单位矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=eye(n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=eye(m,n)</span><br></pre></td></tr></table></figure><ul><li><code>X1=eye(n)</code>表示生成<code>n</code>*<code>n</code>的单位矩阵</li><li><code>X2=eye(m,n)</code>表示生成<code>m</code>*<code>n</code>的单位矩阵</li></ul><h4 id="举个栗子-5"><a href="#举个栗子-5" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=eye(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=eye(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="0矩阵"><a href="#0矩阵" class="headerlink" title="0矩阵"></a>0矩阵</h3><p>MATLAB语言中可使用<code>zeros</code>函数来生成0矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=zeros(n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=zeros(m,n)</span><br></pre></td></tr></table></figure><ul><li><code>X1=zeros(n)</code>表示生成<code>n</code>*<code>n</code>的0矩阵</li><li><code>X2=zeros(m,n)</code>表示生成<code>m</code>*<code>n</code>的0矩阵</li></ul><h4 id="举个栗子-6"><a href="#举个栗子-6" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=zeros(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=zeros(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="1矩阵"><a href="#1矩阵" class="headerlink" title="1矩阵"></a>1矩阵</h3><p>MATLAB语言中可使用<code>ones</code>函数来生成1矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=<span class="literal">on</span>es(n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=<span class="literal">on</span>es(m,n)</span><br></pre></td></tr></table></figure><ul><li><code>X1=ones(n)</code>表示生成<code>n</code>*<code>n</code>的1矩阵</li><li><code>X2=ones(m,n)</code>表示生成<code>m</code>*<code>n</code>的1矩阵</li></ul><h4 id="举个栗子-7"><a href="#举个栗子-7" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=ones(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=ones(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="魔方矩阵"><a href="#魔方矩阵" class="headerlink" title="魔方矩阵"></a>魔方矩阵</h3><p>魔方矩阵是指行和列、正和反斜对角线元素之和都相等的矩阵，MATLAB语言中可使用<code>magic</code>函数来生成魔方矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X</span>=magic(n)</span><br></pre></td></tr></table></figure><p><code>X=magic(n)</code>表示生成<code>n</code><em><code>n</code>的魔方矩阵*</em>（n大于0且n不等于2）**</p><h4 id="举个栗子-8"><a href="#举个栗子-8" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X=magic(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X =</span><br><span class="line"></span><br><span class="line">     <span class="number">8</span>     <span class="number">1</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">5</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">9</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h5><ul><li><p>计算每列的和</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=sum(X)</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">    <span class="number">15</span>    <span class="number">15</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>计算每行的和</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&gt;&gt; B=sum(X')</span><br><span class="line"></span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">    <span class="number">15</span>    <span class="number">15</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="0-1均匀分布随机矩阵"><a href="#0-1均匀分布随机矩阵" class="headerlink" title="0~1均匀分布随机矩阵"></a>0~1均匀分布随机矩阵</h3><p>MATLAB语言中可使用<code>rand</code>函数生成0~1均匀分布的随机矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=rand(n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=rand(m,n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X3</span>=a+(b-a)*rand(m,n)</span><br></pre></td></tr></table></figure><ul><li><code>X1=rand(n)</code>表示生成<code>n</code>*<code>n</code>个元素值为0~1均匀分布的随机矩阵</li><li><code>X2=rand(m,n)</code>表示生成<code>m</code>*<code>n</code>个元素值为0~1均匀分布的随机矩阵</li><li><code>X3=a+(b-a)*rand(m,n)</code>表示生成<code>m</code>*<code>n</code>个元素值为<code>a</code>~<code>b</code>均匀分布的随机矩阵</li></ul><h4 id="举个栗子-9"><a href="#举个栗子-9" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=rand(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8147</span>    <span class="number">0.9134</span>    <span class="number">0.2785</span></span><br><span class="line">    <span class="number">0.9058</span>    <span class="number">0.6324</span>    <span class="number">0.5469</span></span><br><span class="line">    <span class="number">0.1270</span>    <span class="number">0.0975</span>    <span class="number">0.9575</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9649</span>    <span class="number">0.9706</span>    <span class="number">0.4854</span></span><br><span class="line">    <span class="number">0.1576</span>    <span class="number">0.9572</span>    <span class="number">0.8003</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X3=<span class="number">10</span>+(<span class="number">15</span><span class="number">-10</span>)*rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X3 =</span><br><span class="line"></span><br><span class="line">   <span class="number">10.7094</span>   <span class="number">14.5787</span>   <span class="number">14.7975</span></span><br><span class="line">   <span class="number">12.1088</span>   <span class="number">13.9610</span>   <span class="number">13.2787</span></span><br></pre></td></tr></table></figure><h3 id="正态分布随机矩阵"><a href="#正态分布随机矩阵" class="headerlink" title="正态分布随机矩阵"></a>正态分布随机矩阵</h3><p>MATLAB语言中可使用<code>randn</code>函数生成均值为0，单位方差的正态分布随机矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=randn(n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=randn(m,n)<span class="comment">;</span></span><br><span class="line"><span class="attr">X3</span>=a+sqrt(b)*randn(m,n)</span><br></pre></td></tr></table></figure><ul><li><code>X1=randn(n)</code>表示生成<code>n</code>*<code>n</code>个元素且均值为0，方差为1的正态分布随机矩阵</li><li><code>X2=randn(m,n)</code>表示生成<code>m</code>*<code>n</code>个元素且均值为0，方差为1的正态分布随机矩阵</li><li><code>X3=a+sqrt(b)*randn(m,n)</code>表示生成<code>m</code>*<code>n</code>个元素且均值为<code>a</code>，方差为<code>b</code>的正态分布随机矩阵</li></ul><h4 id="举个栗子-10"><a href="#举个栗子-10" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X1=randn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">   <span class="number">-1.2075</span>    <span class="number">0.4889</span>   <span class="number">-0.3034</span></span><br><span class="line">    <span class="number">0.7172</span>    <span class="number">1.0347</span>    <span class="number">0.2939</span></span><br><span class="line">    <span class="number">1.6302</span>    <span class="number">0.7269</span>   <span class="number">-0.7873</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X2=randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8884</span>   <span class="number">-1.0689</span>   <span class="number">-2.9443</span></span><br><span class="line">   <span class="number">-1.1471</span>   <span class="number">-0.8095</span>    <span class="number">1.4384</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X3=<span class="number">1</span>+sqrt(<span class="number">0.1</span>)*randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X3 =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.1028</span>    <span class="number">1.4333</span>    <span class="number">0.9677</span></span><br><span class="line">    <span class="number">0.7613</span>    <span class="number">0.4588</span>    <span class="number">0.9236</span></span><br></pre></td></tr></table></figure><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>MATLAB语言中可以使用<code>diag</code>函数来生成对角矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X</span>=diag(v,k)</span><br></pre></td></tr></table></figure><ul><li><code>X=diag(v,k)</code>表示生成以向量<code>v</code>元素作为矩阵<code>X</code>的第<code>k</code>条对角线元素的对角矩阵</li><li>当<code>k</code>=0时，<code>v</code>为<code>X</code>的主对角线；当<code>k</code>&gt;0时，<code>v</code>为<code>X</code>的主对角线上方第<code>k</code>条对角线的元素；当<code>k</code>&lt;0时，<code>v</code>为<code>X</code>的主对角线下方第<code>k</code>条对角线的元素</li></ul><h4 id="举个栗子-11"><a href="#举个栗子-11" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">&gt;&gt; X1=diag(v)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; X2=diag(v,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">3</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; X3=diag(v,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">X3 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>若<code>X</code>是一个矩阵，则<code>diag(X)</code>是提取矩阵<code>X</code>的对角线矩阵。</p><h4 id="举个栗子-12"><a href="#举个栗子-12" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">X =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; Y=diag(X)</span><br><span class="line"></span><br><span class="line">Y =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>MATLAB语言中可以使用<code>tril</code>和<code>triu</code>函数来生成三角矩阵，其调用方式如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">X1</span>=tril(X,k)<span class="comment">;</span></span><br><span class="line"><span class="attr">X2</span>=triu(X,k)</span><br></pre></td></tr></table></figure><ul><li><code>X1=tril(X,k)</code>表示生成矩阵<code>X</code>中第<code>k</code>条对角线的下三角部分的矩阵</li><li><code>X2=triu(X,k)</code>表示生成矩阵<code>X</code>中第<code>k</code>条对角线的上三角部分的矩阵</li><li><code>k</code>=0为<code>X</code>的主对角线；<code>k</code>&gt;0为<code>X</code>的主对角线以上；<code>k</code>&lt;0为<code>X</code>的主对角线以下</li></ul><h4 id="举个栗子-13"><a href="#举个栗子-13" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X=ones(<span class="number">4</span>);</span><br><span class="line">&gt;&gt; X1=tril(X,<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">X1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; X2=triu(X,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">X2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的修改"><a href="#矩阵的修改" class="headerlink" title="矩阵的修改"></a>矩阵的修改</h2><h3 id="矩阵部分替换"><a href="#矩阵部分替换" class="headerlink" title="矩阵部分替换"></a>矩阵部分替换</h3><p>MATLAB语言可以部分替换矩阵的某个值、某行或某列，方式如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">A(<span class="params">m</span>,<span class="params">n</span>)</span>=a1;</span><br><span class="line"><span class="constructor">A(<span class="params">m</span>,:)</span>=<span class="literal">[<span class="identifier">a1</span>,<span class="identifier">a2</span>,<span class="operator">...</span>,<span class="identifier">an</span>]</span>;</span><br><span class="line"><span class="constructor">A(:,<span class="params">n</span>)</span>=<span class="literal">[<span class="identifier">a1</span>,<span class="identifier">a2</span>,<span class="operator">...</span>,<span class="identifier">am</span>]</span></span><br></pre></td></tr></table></figure><ul><li><code>A(m,n)=a1</code>表示替换矩阵<code>A</code>中的第<code>m</code>行，第<code>n</code>列元素为<code>a1</code></li><li><code>A(m,:)=[a1,a2,...,an]</code>表示替换矩阵<code>A</code>中第<code>m</code>行的所有元素为<code>a1,a2,...,an</code></li><li><code>A(:,n)=[a1,a2,...,am]</code>表示替换矩阵<code>A</code>中第<code>n</code>列的所有元素为<code>a1,a2,...,am</code></li></ul><h4 id="举个栗子-14"><a href="#举个栗子-14" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(<span class="number">2</span>,<span class="number">2</span>)=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>    <span class="number">10</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(<span class="number">2</span>,:)=[<span class="number">14</span> <span class="number">15</span> <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">    <span class="number">14</span>    <span class="number">15</span>    <span class="number">16</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:,<span class="number">2</span>)=[<span class="number">12</span> <span class="number">15</span> <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>    <span class="number">12</span>     <span class="number">3</span></span><br><span class="line">    <span class="number">14</span>    <span class="number">15</span>    <span class="number">16</span></span><br><span class="line">     <span class="number">7</span>    <span class="number">18</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="矩阵部分删除"><a href="#矩阵部分删除" class="headerlink" title="矩阵部分删除"></a>矩阵部分删除</h3><p>MATLAB语言可以部分删除矩阵的行或列，方式如下：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">A<span class="comment">(:,n)=[];</span></span><br><span class="line"><span class="comment">A(m,:)</span>=[]</span><br></pre></td></tr></table></figure><ul><li><code>A(:,n)=[]</code>表示删除矩阵<code>A</code>的第<code>n</code>列</li><li><code>A(m,:)=[]</code>表示删除矩阵<code>A</code>的第<code>m</code>行</li></ul><h4 id="举个栗子-15"><a href="#举个栗子-15" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(<span class="number">2</span>,:)=[]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:,<span class="number">2</span>)=[]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="矩阵部分扩展"><a href="#矩阵部分扩展" class="headerlink" title="矩阵部分扩展"></a>矩阵部分扩展</h3><h4 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h4><p>MATLAB语言可以部分扩展矩阵，方式如下：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">A</span>=[A<span class="comment">;B C]</span></span><br></pre></td></tr></table></figure><ul><li><code>A</code>为原矩阵，<code>B</code>和<code>C</code>为要扩展的元素，<code>M</code>为扩展后的矩阵</li><li><strong><code>B</code>和<code>C</code>的行数都要相等</strong></li><li><strong><code>B</code>和<code>C</code>的列数之和要与<code>A</code>的列数相等</strong></li></ul><h5 id="举个栗子-16"><a href="#举个栗子-16" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; B=zeros(<span class="number">2</span>);</span><br><span class="line">&gt;&gt; C=eye(<span class="number">2</span>);</span><br><span class="line">&gt;&gt; M=[A;B C]</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="平铺矩阵函数"><a href="#平铺矩阵函数" class="headerlink" title="平铺矩阵函数"></a>平铺矩阵函数</h4><p>MATLAB语言可以利用平铺矩阵函数<code>repmat</code>扩展矩阵，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">M=repmat<span class="comment">(A,m,n)</span></span><br></pre></td></tr></table></figure><ul><li><code>M=repmat(A,m,n)</code>表示将矩阵<code>A</code>复制扩展为<code>m*n</code>块</li></ul><h5 id="举个栗子-17"><a href="#举个栗子-17" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M=repmat(A,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="指定维数拼接函数"><a href="#指定维数拼接函数" class="headerlink" title="指定维数拼接函数"></a>指定维数拼接函数</h4><p>MATLAB语言可以使用指定维数拼接函数<code>cat</code>拼接矩阵，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="name">M1</span>=cat<span class="comment">(1,A,B)</span>;</span><br><span class="line"><span class="name">M2</span>=cat<span class="comment">(2,A,B)</span>;</span><br><span class="line"><span class="name">M3</span>=cat<span class="comment">(3,A,B)</span></span><br></pre></td></tr></table></figure><ul><li><code>M1=cat(1,A,B)</code>表示垂直拼接</li><li><code>M2=cat(2,A,B)</code>表示水平拼接</li><li><code>M3=cat(3,A,B)</code>表示三维拼接</li></ul><h5 id="举个栗子-18"><a href="#举个栗子-18" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=eye(<span class="number">2</span>);</span><br><span class="line">&gt;&gt; B=zeros(<span class="number">2</span>);</span><br><span class="line">&gt;&gt; M1=cat(<span class="number">1</span>,A,B)</span><br><span class="line"></span><br><span class="line">M1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M2=cat(<span class="number">2</span>,A,B)</span><br><span class="line"></span><br><span class="line">M2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M3=cat(<span class="number">3</span>,A,B)</span><br><span class="line"></span><br><span class="line">M3(:,:,<span class="number">1</span>) =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">M3(:,:,<span class="number">2</span>) =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="矩阵结构变换"><a href="#矩阵结构变换" class="headerlink" title="矩阵结构变换"></a>矩阵结构变换</h3><h4 id="上下行对调"><a href="#上下行对调" class="headerlink" title="上下行对调"></a>上下行对调</h4><p>MATLAB语言可以使用<code>flipud</code>函数来上下变换矩阵的结构，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">M=flipud<span class="comment">(A)</span></span><br></pre></td></tr></table></figure><h5 id="举个栗子-19"><a href="#举个栗子-19" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M=flipud(A)</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="左右列对调"><a href="#左右列对调" class="headerlink" title="左右列对调"></a>左右列对调</h4><p>MATLAB语言可以使用<code>fliplr</code>函数来左右变换矩阵的结构，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">M=fliplr<span class="comment">(A)</span></span><br></pre></td></tr></table></figure><h5 id="举个栗子-20"><a href="#举个栗子-20" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">3</span> <span class="number">6</span>;<span class="number">2</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">4</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M=fliplr(A)</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">6</span>     <span class="number">3</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">8</span>     <span class="number">4</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="逆（顺）时针旋转"><a href="#逆（顺）时针旋转" class="headerlink" title="逆（顺）时针旋转"></a>逆（顺）时针旋转</h4><p>MATLAB语言可以使用函数<code>rot90</code>旋转矩阵的结构，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="name">M1</span>=rot<span class="number">90</span><span class="comment">(A)</span>;</span><br><span class="line"><span class="name">M2</span>=rot<span class="number">90</span><span class="comment">(A,k)</span></span><br></pre></td></tr></table></figure><ul><li><code>M1=rot90(A)</code>表示将矩阵<code>A</code>逆时针旋转<code>pi/2</code></li><li><code>M2=rot90(A,k)</code>表示将矩阵<code>A</code>旋转<code>k</code>倍的<code>pi/2</code>；当<code>k</code>&gt;0时，逆时针旋转；当<code>k</code>&lt;0时，顺时针旋转</li></ul><h5 id="举个栗子-21"><a href="#举个栗子-21" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M1=rot90(A)</span><br><span class="line"></span><br><span class="line">M1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">5</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M2=rot90(A,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">M2 =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">6</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>MATLAB语言中转置用<code>&#39;</code>运算符，方式如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">M</span>=A'</span><br></pre></td></tr></table></figure><h5 id="举个栗子-22"><a href="#举个栗子-22" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M=A'</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="变维"><a href="#变维" class="headerlink" title="变维"></a>变维</h4><p>MATLAB语言可以使用<code>reshape</code>函数实现矩阵变维，调用方式如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">M=reshape<span class="comment">(A,m,n)</span></span><br></pre></td></tr></table></figure><ul><li><code>M=reshape(A,m,n)</code>表示以矩阵<code>A</code>的元素构成<code>m*n</code>维<code>M</code>矩阵</li></ul><h5 id="举个栗子-23"><a href="#举个栗子-23" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=<span class="number">1</span>:<span class="number">8</span></span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M=reshape(A,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">M =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>     <span class="number">5</span>     <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>     <span class="number">4</span>     <span class="number">6</span>     <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的基本运算（非全部）"><a href="#矩阵的基本运算（非全部）" class="headerlink" title="矩阵的基本运算（非全部）"></a>矩阵的基本运算（非全部）</h2><h3 id="矩阵的除法运算"><a href="#矩阵的除法运算" class="headerlink" title="矩阵的除法运算"></a>矩阵的除法运算</h3><p>在MATLAB语言中，有左除（运算符：<code>\</code>）和右除（运算符：<code>/</code>）两种除法运算。若矩阵<code>A</code>为非奇异方阵，<code>A\B</code>等效于<code>A</code>的逆矩阵左乘矩阵<code>B</code>，即<code>inv(A)*B</code>；<code>B/A</code>等效于<code>A</code>的逆矩阵右乘矩阵<code>B</code>，即<code>B*inv(A)</code></p><h4 id="举个栗子-24"><a href="#举个栗子-24" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">&gt;&gt; B=[<span class="number">1</span> <span class="number">3</span>;<span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">&gt;&gt; M1=A\B</span><br><span class="line"></span><br><span class="line">M1 =</span><br><span class="line"></span><br><span class="line">         <span class="number">0</span>   <span class="number">-5.0000</span></span><br><span class="line">    <span class="number">0.5000</span>    <span class="number">4.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M2=B/A</span><br><span class="line"></span><br><span class="line">M2 =</span><br><span class="line"></span><br><span class="line">    <span class="number">2.5000</span>   <span class="number">-0.5000</span></span><br><span class="line">   <span class="number">-2.5000</span>    <span class="number">1.5000</span></span><br></pre></td></tr></table></figure><h3 id="矩阵的乘方运算"><a href="#矩阵的乘方运算" class="headerlink" title="矩阵的乘方运算"></a>矩阵的乘方运算</h3><p>在MATLAB语言中，当<code>A</code>是方阵，<code>n</code>为大于0的整数时，矩阵<code>A</code>的<code>n</code>次乘方运算可以表示为<code>A^n</code>；当<code>n</code>为小于0的整数时，<code>A^n</code>表示<code>A</code>的逆矩阵的<code>-n</code>次方</p><h4 id="举个栗子-25"><a href="#举个栗子-25" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">&gt;&gt; M1=A^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">M1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span>    <span class="number">10</span></span><br><span class="line">    <span class="number">15</span>    <span class="number">22</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; M2=A^<span class="number">-2</span></span><br><span class="line"></span><br><span class="line">M2 =</span><br><span class="line"></span><br><span class="line">    <span class="number">5.5000</span>   <span class="number">-2.5000</span></span><br><span class="line">   <span class="number">-3.7500</span>    <span class="number">1.7500</span></span><br></pre></td></tr></table></figure><h3 id="矩阵的点运算"><a href="#矩阵的点运算" class="headerlink" title="矩阵的点运算"></a>矩阵的点运算</h3><p>在MATLAB语言中，点运算是一种特殊的运算，其运算符有<code>.*</code>、<code>./</code>、<code>.\</code>、<code>.^</code>四种。点运算规则是对应元素进行相关运算，具体如下：</p><ul><li>若两个矩阵<code>A</code>和<code>B</code>进行点乘运算，要求矩阵维度相同，对应元素相乘</li><li>若<code>A</code>和<code>B</code>两个矩阵同维，则<code>A./B</code>表示<code>A</code>矩阵除以<code>B</code>矩阵的对应元素；<code>B.\A</code>表示<code>A</code>矩阵除以<code>B</code>矩阵的对应元素</li><li>若<code>A</code>和<code>B</code>两个矩阵同维，则<code>A.^B</code>表示两个矩阵对应元素进行乘方运算</li><li><code>A.^b</code>表示矩阵<code>A</code>的每个元素与标量<code>b</code>做乘方运算；<code>a.^B</code>表示标量<code>a</code>与矩阵<code>B</code>的每个元素进行乘方运算</li></ul><h4 id="举个栗子-26"><a href="#举个栗子-26" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">&gt;&gt; B=[<span class="number">1</span> <span class="number">-1</span>;<span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">&gt;&gt; C=A.*B</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>    <span class="number">-2</span></span><br><span class="line">     <span class="number">6</span>     <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C=A./B</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.0000</span>   <span class="number">-2.0000</span></span><br><span class="line">    <span class="number">1.5000</span>    <span class="number">4.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C=B.\A</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.0000</span>   <span class="number">-2.0000</span></span><br><span class="line">    <span class="number">1.5000</span>    <span class="number">4.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C=A.^B</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">0.5000</span></span><br><span class="line">    <span class="number">9.0000</span>    <span class="number">4.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a=<span class="number">2</span>;b=<span class="number">2</span>;</span><br><span class="line">&gt;&gt; C=A.^b</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">16</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C=a.^B</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">2.0000</span>    <span class="number">0.5000</span></span><br><span class="line">    <span class="number">4.0000</span>    <span class="number">2.0000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux小记（二）</title>
      <link href="/2020/09/17/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/17/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文记录了Termux调用Android手机系统功能的相关笔记。</p><a id="more"></a><hr><p>Termux除了可以赋予Android手机一定的Linux服务器职能外，还可直接调用Android手机系统功能，这是服务器所不能做到的。<del>其实是自己太无聊才折腾 (つд⊂)</del></p><h2 id="Termux-API的安装"><a href="#Termux-API的安装" class="headerlink" title="Termux:API的安装"></a>Termux:API的安装</h2><p>通过<a href="https://play.google.com/store/apps/details?id=com.termux.api" target="_blank" rel="noopener">google Play</a>或<a href="https://f-droid.org/packages/com.termux.api/" target="_blank" rel="noopener">F-Droid</a>在手机上安装插件Termux:API。</p><p><strong>Termux:API的下载源必须与Termux本体的一致</strong>（例如：Termux的本体从Google Play获取，那么Termux:API也必须要从Google Play获取），否则，会因为安装包签名不一致而无法使用。</p><p>随后，需要在系统（MIUI 12 by Android 10，其他ROM及Android版本同理）中允许Termux:API自启动，否则，在调用系统功能时，命令将一直挂起而无法正常执行 (((ﾟДﾟ;))) 。</p><h2 id="termux-api的安装"><a href="#termux-api的安装" class="headerlink" title="termux-api的安装"></a>termux-api的安装</h2><p>Termux:API安装完毕后，还需要在Termux上安装<code>termux-api</code>。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> termux-api</span><br></pre></td></tr></table></figure><h2 id="相关命令整理（非全部）"><a href="#相关命令整理（非全部）" class="headerlink" title="相关命令整理（非全部）"></a>相关命令整理（非全部）</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">termux-<span class="keyword">battery-status</span><span class="comment"># 获取设备电池的相关信息</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">termux-brightness &lt;数值&gt;# 修改设备屏幕的显示亮度（数值范围：<span class="number">0</span>~<span class="number">255</span>）</span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">termux-<span class="built_in">call</span>-<span class="built_in">log</span><span class="meta"># 获取通话记录（该功能在Android 10上被Google禁止）</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">termux-camera-<span class="builtin-name">info</span># 获取相机信息</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">termux-camera-photo <span class="params">&lt;-c 相机序号（可在上条命令中获取）&gt;</span> <span class="params">&lt;输出文件&gt;</span><span class="meta"># 调用相机拍照，照片以JPEG格式存储</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">termux-clipboard-<span class="keyword">set</span> &lt;文本内容&gt;<span class="comment"># 设置系统剪贴板的文本内容</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">termux-clipboard-<span class="keyword">get</span><span class="comment"># 获取系统剪贴板的文本内容</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">termux-contact-<span class="built_in">list</span><span class="comment"># 获取联系人信息</span></span><br></pre></td></tr></table></figure><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">termux-<span class="keyword">dialog</span><span class="meta"># 显示文本输入对话框</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-fingerprint<span class="meta"># 调用指纹传感器以验证身份</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-sensor -l<span class="meta"># 列出可用的传感器</span></span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">termux-sensor -<span class="keyword">a</span><span class="comment"># 列出传感器的实时信息</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-sensor -c<span class="meta"># 释放传感器资源</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">termux-sms-<span class="built_in">list</span><span class="comment"># 列出收到的短信</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">termux-sms-send -n <span class="params">&lt;目标号码&gt;</span> <span class="params">&lt;文本内容&gt;</span><span class="meta"># 向目标号码发送短信（该功能在Android 10上被Google禁止）</span></span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">termux-telephony-<span class="built_in">call</span> &lt;目标号码&gt;<span class="meta"># 呼叫目标号码</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-telephony-deviceinfo<span class="meta"># 获取电话设备的信息</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">termux-torch <span class="keyword">on</span><span class="comment"># 打开LED灯</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">termux-torch <span class="keyword">off</span><span class="comment"># 关闭LED灯</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-tts-engines<span class="meta"># 列出设备上的文本转语音（TTS）引擎</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">termux-vibrate -d <span class="params">&lt;震动持续时间（单位：ms）&gt;</span><span class="meta"># 设备震动若干ms</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">termux<span class="literal">-vibrate</span> <span class="operator">-f</span><span class="comment"># 设备即使在静音模式下也强制震动</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">termux-wifi-connectioninfo<span class="meta"># 获取当前连接的WIFI的信息</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">termux-wifi-<span class="keyword">scaninfo</span><span class="comment"># 获取最近一次WIFI扫描的信息</span></span><br></pre></td></tr></table></figure><h3 id="附注："><a href="#附注：" class="headerlink" title="附注："></a>附注：</h3><p>对于每个命令，可使用<code>-h</code>选项来获取帮助（全英文警告 Σ(lliдﾟﾉ)ﾉ ）</p><p>其他命令可参考<a href="https://wiki.termux.com/wiki/Termux:API" target="_blank" rel="noopener">官方记录</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Termux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows编程小记（一）</title>
      <link href="/2020/09/13/Windows%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/13/Windows%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文记录了部分在使用C语言编写Windows应用程序的过程中会涉及的基本知识。</p><a id="more"></a><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p><code>API</code>全称<code>Application Programming Interface</code>，即<code>应用程序编程接口</code>，Windows把计算机底层复杂的操作（在计算机上层即使执行诸如文件打开、读取、关闭这样看似简单的操作，到了底层是非常复杂的 (☉д⊙) ）用函数表示并编译成动态链接库（DLL），在软件开发过程中，通过调用这些函数即可轻松执行相关操作，从而显著提高开发效率。</p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>在Windows编程中，窗口、控件（窗口中的输入区域、菜单、按钮等）、图像、音频、视频等都被称为<code>资源（Resource）</code>。不同的资源都对应唯一的一个ID，称为<code>句柄（Handle）</code>。程序通过句柄获取对应的资源的信息，也可以使用、修改该资源。</p><h2 id="Windows的消息机制"><a href="#Windows的消息机制" class="headerlink" title="Windows的消息机制"></a>Windows的消息机制</h2><p>用户敲击键盘、点击鼠标、拖动窗口、选择菜单、输入文字等所有操作都被称为<code>事件（Event）</code>，当有事件发生时，Windows会生成一个<code>消息</code>（Message，结构体的一种）并存储到一个由系统维护的<code>队列</code>（数据结构的一种）中，应用程序从队列中获取消息，调用事件处理函数，随后响应用户的操作。</p><p>Windows向队列中存储消息与应用程序从队列中获取消息并不是同步的，只要有事件发生，Windows就会把消息存储到队列中，至于消息什么时候被获取，这就是应用程序的事了 ( ˘･з･) 。</p><h3 id="消息结构体"><a href="#消息结构体" class="headerlink" title="消息结构体"></a>消息结构体</h3><p>消息是一个结构体，定义为：</p><figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">HWND hwnd;<span class="comment">//消息所属的窗口</span></span><br><span class="line">UINT message;<span class="comment">//消息类型</span></span><br><span class="line">WPARAM wParam;<span class="comment">//指定消息的附加信息</span></span><br><span class="line">LPARAM lParam;<span class="comment">//指定消息的附加信息</span></span><br><span class="line">DWORD time;<span class="comment">//消息存储到队列中的时间</span></span><br><span class="line">POINT pt;<span class="comment">//鼠标指针的当前位置</span></span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure><hr><p>整理自</p><p><a href="http://c.biancheng.net/cpp/html/2845.html" target="_blank" rel="noopener">Windows API的概念</a></p><p><a href="http://c.biancheng.net/cpp/html/2947.html" target="_blank" rel="noopener">与windows编程有关的重要概念</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现进制转换</title>
      <link href="/2020/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>昨天开始折腾如何通过C语言实现进制转换，简单记录一下 (つ´ω`)つ 。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MENU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***********************************************"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                    进制转换                    "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               1.二进制转换十进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               2.十进制转换二进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               3.八进制转换十进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               4.十进制转换八进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               5.十进制转十六进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               6.十六进制转十进制                  "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                   0.退出程序                      "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***********************************************"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoToTen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的二进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;number);</span><br><span class="line">    <span class="keyword">int</span> m=number;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=m%<span class="number">10</span>;</span><br><span class="line">        m/=<span class="number">10</span>;</span><br><span class="line">        sum+=n*<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二进制整数 %lld 转换为十进制整数 %d"</span>,number,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TenToTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的十进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">    <span class="keyword">int</span> m=number;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>,a[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=m%<span class="number">2</span>;</span><br><span class="line">        m/=<span class="number">2</span>;</span><br><span class="line">        a[i]=n;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"十进制整数 %d 转换为二进制整数 "</span>,number);</span><br><span class="line">    <span class="keyword">for</span>(i--;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightToTen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的八进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">    <span class="keyword">int</span> m=number;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=m%<span class="number">10</span>;</span><br><span class="line">        m/=<span class="number">10</span>;</span><br><span class="line">        sum+=n*<span class="built_in">pow</span>(<span class="number">8</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"八进制整数 %d 转换为十进制整数 %d"</span>,number,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TenToEight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的十进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">    <span class="keyword">int</span> m=number;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>,a[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=m%<span class="number">8</span>;</span><br><span class="line">        m/=<span class="number">8</span>;</span><br><span class="line">        a[i]=n;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"十进制整数 %d 转换为八进制整数 "</span>,number);</span><br><span class="line">    <span class="keyword">for</span>(i--;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TenToSixteen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的十进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">    <span class="keyword">char</span> arr[]=<span class="string">"0123456789abcdef"</span>;</span><br><span class="line">    <span class="keyword">int</span> m=number;</span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">0</span>,a[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=m%<span class="number">16</span>;</span><br><span class="line">        m/=<span class="number">16</span>;</span><br><span class="line">        a[i]=arr[n];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"十进制整数 %d 转换为十六进制整数 "</span>,number);</span><br><span class="line">    <span class="keyword">for</span>(i--;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SixteenToTen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个待转换的十六进制整数："</span>);</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%x"</span>,&amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"十六进制整数 %x 转换为十进制整数 %d"</span>,number,number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MENU();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入0~6以选择需要执行的操作："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">switch</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:TwoToTen();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:TenToTwo();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:EightToTen();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:TenToEight();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:TenToSixteen();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:SixteenToTen();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Nextcloud搭建私有云存储（入门）</title>
      <link href="/2020/09/05/%E4%BD%BF%E7%94%A8Nextcloud%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2020/09/05/%E4%BD%BF%E7%94%A8Nextcloud%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>相对于百度网盘、天翼云盘等商业化云存储，私有云存储从客户端到服务端都可自主受控，在一定程度上能更有保障的维护自己的隐私<del>存放小姐姐视频而不被和谐</del>，而且还不受运营商的上传、下载速度以及流量的限制，总的来说，相较于商业化云存储，私有云存储可让拥有者获得更大的自由度 ︿(￣︶￣)︿ 。</p><a id="more"></a><p>好吧，我承认其实就是因为自己太无聊，所以才折腾来玩玩 (つ´ω`)つ 。</p><hr><h2 id="Nextcloud简介"><a href="#Nextcloud简介" class="headerlink" title="Nextcloud简介"></a>Nextcloud简介</h2><p><a href="https://nextcloud.com/" target="_blank" rel="noopener">Nextcloud</a>是一款开源的私有云存储方案（<a href="https://github.com/nextcloud" target="_blank" rel="noopener">GitHub</a>），其脱胎于同为开源项目的私有云存储解决方案<a href="https://owncloud.com/" target="_blank" rel="noopener">ownCloud</a>。</p><p>Nextcloud的服务端可部署于私人服务器；支持包括MySQL、MariaDB、SQLite等多种数据库；支持用户群组使用和管理；支持通过Windows、macOS、Linux、Android、iOS客户端以及网页端上传和下载文件，同时实现文本编辑、文件查看以及分享等功能；另外，Nextcloud可与Google Drive、OneDrive、Dropbox等云盘对接。</p><h2 id="Nextcloud服务端部署"><a href="#Nextcloud服务端部署" class="headerlink" title="Nextcloud服务端部署"></a>Nextcloud服务端部署</h2><p>首先要有一个安装了CentOS 7 64位操作系统（以下安装方法在更高版本的CentOS 8上将不可用，原因未明）的VPS，我用的服务商是<a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr</a>，其他的像是<a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>等服务商也没问题。我使用Docker部署Nextcloud服务端。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>首先，通过镜像源安装Docker</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo yum -y <span class="keyword">install</span> docker</span><br></pre></td></tr></table></figure><p>接着，启动Docker</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><p>然后，设置开机自启动Docker</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="builtin-name">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="安装Nextcloud服务端"><a href="#安装Nextcloud服务端" class="headerlink" title="安装Nextcloud服务端"></a>安装Nextcloud服务端</h3><p>安装经Docker打包的Nextcloud服务端</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">8080</span>:<span class="number">80</span> nextcloud</span><br></pre></td></tr></table></figure><h3 id="访问Nextcloud服务端"><a href="#访问Nextcloud服务端" class="headerlink" title="访问Nextcloud服务端"></a>访问Nextcloud服务端</h3><p>在浏览器访问服务器的8080端口，即<code>&lt;服务器IP&gt;:8080</code>。</p><p><img src="/images/%E4%BD%BF%E7%94%A8Nextcloud%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt></p><p>首次访问需要创建管理员账号；</p><p>数据目录和数据库的配置默认不变（其实我还不是很懂数据库相关的 。･ﾟ･(つд`ﾟ)･ﾟ･ ）；如果只是个人简单地用于文件存储，我认为选择SQLite即可（忽略 性能警告 ）。</p><h2 id="使用Nextcloud"><a href="#使用Nextcloud" class="headerlink" title="使用Nextcloud"></a>使用Nextcloud</h2><p>Nextcloud服务端部署完成后，即可投入使用，自由存取文件。毕竟我只是简单地用作文件存储，没有群组使用，在线编辑等需求，就暂时不往下折腾了（才不是因为我懒(・ε・)）。如果有大佬看到本文，还希望能多多指教，感激不尽(^u^)。</p><hr><p>本文参考自</p><p><a href="https://www.cnblogs.com/javazhiyin/p/12877133.html" target="_blank" rel="noopener">厉害了，如何搭建一套自己的私有网盘？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 私有云存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现二进制文件的复制</title>
      <link href="/2020/09/04/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/09/04/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>简单记录一下C语言实现二进制文件复制的代码 (๑´ㅂ`๑) 。</p><a id="more"></a><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int ma<span class="meta">in(</span>void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">FILE</span> <span class="comment">*fp0;</span></span><br><span class="line"><span class="meta">FILE</span> <span class="comment">*fp1;</span></span><br><span class="line"><span class="meta">if</span>((fp0<span class="meta">=fopen(</span><span class="string">"G:\\来自  Google Chrome\\测试0.mp3"</span>,<span class="string">"rb"</span>))==<span class="meta">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"源文件无法打开！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">if</span>((fp1<span class="meta">=fopen(</span><span class="string">"G:\\来自  Google Chrome\\测试1.MP3"</span>,<span class="string">"wb"</span>))==<span class="meta">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"文件复制发生错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int ch;</span><br><span class="line"><span class="meta">while</span>((ch=fgetc(fp0))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">fputc(</span>ch,fp1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">fclose(</span>fp0);</span><br><span class="line"><span class="meta">fclose(</span>fp1);</span><br><span class="line"><span class="meta">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现对文本文件内容的加密和解密</title>
      <link href="/2020/09/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/"/>
      <url>/2020/09/01/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>之前折腾了字符串的加密和解密，今天就进阶一下 (つд⊂) ，折腾了对文本文件内容的加密和解密，写下本文以作笔记。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp1,*fp2,*fp3,*fp4;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数字0选择加密，输入数字1选择解密。\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数字："</span>);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((fp1=fopen(<span class="string">"G:\\来自  Dev-C++\\待加密的文本文件.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待加密的文本文件无法打开！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ch0;<span class="comment">//定义一个用于存放fgetc()函数返回值的整型变量（因为需要容纳的EOF为负数，char不能是负数，所以返回值类型不能是char） </span></span><br><span class="line">fp2=fopen(<span class="string">"G:\\来自  Dev-C++\\已加密的文本文件.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">while</span>((ch0=fgetc(fp1))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">ch0++;<span class="comment">//每个字符对应的ASCII值加上1 </span></span><br><span class="line">fputc(ch0,fp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ch0_0;</span><br><span class="line"><span class="keyword">if</span>((ch0_0=feof(fp1))!=<span class="number">0</span>)<span class="comment">//判断文件内部指针是否指向文件末尾 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待加密的文本文件已完成加密！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> CH0;</span><br><span class="line"><span class="keyword">if</span>((CH0=ferror(fp1))!=<span class="number">0</span>)<span class="comment">//判断文件操作是否发生错误 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"待加密的文本文件读取发生错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp1);<span class="comment">//关闭文件 </span></span><br><span class="line">fclose(fp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((fp3=fopen(<span class="string">"G:\\来自  Dev-C++\\已加密的文本文件.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"已加密的文本文件无法打开！"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ch1;</span><br><span class="line">fp4=fopen(<span class="string">"G:\\来自  Dev-C++\\已解密的文本文件.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">while</span>((ch1=fgetc(fp3))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">ch1--;</span><br><span class="line">fputc(ch1,fp4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ch1_1;</span><br><span class="line"><span class="keyword">if</span>((ch1_1=feof(fp3))!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加密后的文本文件已解密！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> CH1;</span><br><span class="line"><span class="keyword">if</span>((CH1=ferror(fp3))!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加密后的文本文件读取发生错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp3);</span><br><span class="line">fclose(fp4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言笔记——fgets()和fputs()函数</title>
      <link href="/2020/08/16/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94fgets()%E5%92%8Cfputs()%E5%87%BD%E6%95%B0/"/>
      <url>/2020/08/16/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94fgets()%E5%92%8Cfputs()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><code>fgets()</code>和<code>fputs()</code>函数每次能读和写一个字符串，相较于每次只能读、写一个字符的<code>fgetc()</code>、<code>fputs()</code>函数来说，效率更高。</p><a id="more"></a><h2 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets()函数"></a>fgets()函数</h2><p><code>fgets()</code>函数用来从目标文件中读取一个字符串，并保存到字符数组中，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> n,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p><code>str</code>表示字符数组，<code>n</code>为需要读取的字符数目，<code>fp</code>为文件指针。</p><p><strong>读取到的字符串会在末尾自动添加<code>\0</code></strong>，n个字符也包括<code>\0</code>，实际上只读取<code>n-1</code>个字符。</p><p>读取成功时，<code>fgets()</code>函数返回字符数组首地址；读取失败或文件内部指针指向文件末尾时，<code>fgets()</code>函数返回<code>NULL</code>。</p><p><strong>在读取到<code>n-1</code>个字符之前，如果出现换行或文件末尾，则读取结束</strong>；不管<code>n</code>的值多大，<code>fgets()</code>函数一次只能读取一行数据。</p><p>如果把<code>fgets()</code>函数嵌入循环语句，则可无视<code>n</code>的大小٩(๑´3｀๑)۶，从文件开头读取到文件末尾（当然，这个过程中<code>fgets()</code>函数被执行了多次(っ●ω●)っ）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"G:\\来自  Dev-C++\\练习.txt"</span>,<span class="string">"rt"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件无法打开！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[n];</span><br><span class="line"><span class="keyword">while</span>((fgets(str,n,fp))!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(feof(fp)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件读取成功！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ferror(fp)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件读取出现错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs()函数"></a>fputs()函数</h2><p><code>fputs()</code>函数用来向目标文件写入一个字符串，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> *str,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p><code>str</code>表示需要写入的字符串，<code>fp</code>为文件指针。</p><p>写入成功时，<code>fputs()</code>函数返回非负数；写入失败时，<code>fputs()</code>函数返回<code>EOF</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"G:\\来自  Dev-C++\\练习.txt"</span>,<span class="string">"at+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件无法打开！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入字符串："</span>);</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">ch=<span class="built_in">fputs</span>(str,fp);<span class="comment">//向目标文件写入字符串并把返回值赋值给变量ch </span></span><br><span class="line"><span class="keyword">if</span>(ch!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"写入成功！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"写入失败！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如有错误，请在评论区多多指教，感激不尽ヽ( ^ω^ ゞ )。</p><p>本文内容整理自</p><p><a href="http://c.biancheng.net/view/2070.html" target="_blank" rel="noopener">C语言fgets和fputs函数的用法详解（以字符串的形式读写文件）</a></p><p><a href="https://blog.csdn.net/daiyutage/article/details/8540932" target="_blank" rel="noopener">C语言文件操作之fgets（）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言笔记——fgetc()和fputc()函数</title>
      <link href="/2020/08/14/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94fgetc()%E5%92%8Cfputc()%E5%87%BD%E6%95%B0/"/>
      <url>/2020/08/14/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94fgetc()%E5%92%8Cfputc()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在C语言中，<code>fgetc()</code>和<code>fputc()</code>都是用于文件操作的函数，其均在<code>&lt;stdio.h&gt;</code>头文件中。</p><a id="more"></a><h2 id="fgetc-函数"><a href="#fgetc-函数" class="headerlink" title="fgetc()函数"></a>fgetc()函数</h2><p><code>fgetc()</code>函数可从文件中每次读取一个字符，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p><code>fgetc()</code>函数读取成功时，返回读取到的字符；读取到文件末尾或读取失败时返回<code>EOF</code>。<code>EOF</code>是<code>&lt;stdio.h&gt;</code>头文件中定义的一个宏，它的值是负数，一般为-1（<strong><code>EOF</code>不绝对为-1，也可以是其他负数，这取决于编译器</strong>），<code>fgetc()</code>的返回值类型之所以为<code>int</code>，就是为了容纳这个负数（<code>char</code>不能是负数）。</p><h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"G:\\来自  Dev-C++\\练习.txt"</span>,<span class="string">"r+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无法打开文件！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=fgetc(fp))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">if</span>((x=feof(fp))!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件读取完毕！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">if</span>((y=ferror(fp))!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件读取发生错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用<code>fgetc()</code>函数后，该指针会向后移动一个字节，所以可以连续多次使用<code>fgetc()</code>函数读取多个字符。<strong>位置指针仅仅是一个标志</strong>，表示文件读写到的位置，也就是读写到第几个字节，它<strong>不表示地址</strong>。文件每读写一次，位置指针就会移动一次，它<strong>不需要在程序中定义和赋值</strong>，而是由系统自动设置，对用户是隐藏的。</p><h4 id="对EOF的说明"><a href="#对EOF的说明" class="headerlink" title="对EOF的说明"></a>对EOF的说明</h4><p><code>EOF</code>本来表示文件末尾，意味着读取结束，但是很多函数在读取错误时也返回<code>EOF</code>，那么需要使用<code>&lt;stdio.h&gt;</code>头文件中的<code>feof()</code>和<code>ferror()</code>函数来判断文件是读取完毕还是读取错误。</p><p><code>feof()</code>函数用来判断文件内部指针是否指向文件末尾，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>当指向文件末尾时，返回非零值，否则返回零。</p><p><code>ferror()</code>函数用来判断文件操作是否错误，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>当文件操作出现错误时，返回非零值，否则返回零。</p><h2 id="fputc-函数"><a href="#fputc-函数" class="headerlink" title="fputc()函数"></a>fputc()函数</h2><p><code>fputc()</code>函数可向文件中每次写入一个字符，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch,FILE *fp)</span></span>;<span class="comment">//ch表示写入的字符</span></span><br></pre></td></tr></table></figure><p><code>fputc</code>函数写入成功时，返回写入的字符；写入失败时返回<code>EOF</code>，返回值类型为<code>int</code>也是为了容纳这个负数。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"G:\\来自  Dev-C++\\练习.txt"</span>,<span class="string">"wt+"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件无法打开！"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入字符串："</span>);</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=getchar())!=<span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">fputc(ch,fp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被写入的文件可以使用写、读写、追加三种方式打开，使用写或读写方式打开一个已存在的文件时将清除原有的文件内容，如需保留原有文件内容，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时，则新建文件。</p><hr><p>如有错误，请在评论区留言，非常感谢(ﾉ&gt;ω&lt;)ﾉ。</p><p>本文内容整理自</p><p><a href="http://c.biancheng.net/view/2068.html" target="_blank" rel="noopener">C语言fgetc和fputc函数用法详解（以字符形式读写文件）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作——fopen()函数</title>
      <link href="/2020/08/13/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94fopen()%E5%87%BD%E6%95%B0/"/>
      <url>/2020/08/13/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94fopen()%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在C语言中，<code>&lt;stdio.h&gt;</code>头文件中的<code>fopen()</code>函数可用于（以文本文件或二进制文件的方式）打开文件，其调用方法为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br></pre></td></tr></table></figure><p><code>FILE</code>为是<code>&lt;stdio.h&gt;</code>头文件中的一个专门用来保存文件信息的结构体，不需要知道其具体结构，只需要知道用法即可；<code>path</code>为文件路径；<code>mode</code>为打开方式。</p><a id="more"></a><p>当文件打开出错时，<code>fopen()</code>函数返回一个空指针<code>NULL</code>；如果定义一个<code>FILE</code>类型的指针<code>*fp</code>用于接收<code>fopen()</code>函数的反馈，则可判断目标文件是否打开成功。</p><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"G:\\来自  Dev-C++\\练习.txt"</span>,<span class="string">"r"</span>))!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"目标文件打开成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"目标文件打开失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件打开方式由<code>r</code>（读）、<code>w</code>（写）、<code>a</code>（追加）、<code>+</code>（读和写）、<code>t</code>（文本文件）、<code>b</code>（二进制文件）六个字符表示；调用<code>fopen()</code>函数时必须指明读写权限，但可以不指明读写方式（<strong>此时读写方式默认为<code>t</code></strong>）；读写权限和读写方式可以组合使用，但<strong>不能将读写方式放置在读写权限的开头</strong>。</p><table><thead><tr><th align="center">打开方式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">以只读方式打开文件，文件<strong>必须</strong>存在</td></tr><tr><td align="center">r+</td><td align="center">以读/写方式打开文件，文件<strong>必须</strong>存在</td></tr><tr><td align="center">rb+</td><td align="center">以读/写方式打开一个二进制文件，只允许读/写数据</td></tr><tr><td align="center">rt+</td><td align="center">以读/写方式打开一个文本文件，允许读和写</td></tr><tr><td align="center">w</td><td align="center">打开只写文件。<strong>若文件存在，则长度清零</strong>；若文件不存在，则新建文件</td></tr><tr><td align="center">w+</td><td align="center">打开可读/写文件。<strong>若文件存在，则长度清零</strong>；若文件不存在，则新建文件</td></tr><tr><td align="center">a</td><td align="center">以追加内容的方式打开只写文件。若文件不存在，则新建文件；若文件存在，则向文件追加内容（<strong>EOF符保留</strong>）</td></tr><tr><td align="center">a+</td><td align="center">以追加内容的方式打开可读/写的文件。若文件不存在，则新建文件；若文件存在，则向文件追加内容（原来的EOF符<strong>不</strong>保留）</td></tr><tr><td align="center">wb</td><td align="center">以只写方式打开或新建一个二进制文件，只允许写入</td></tr><tr><td align="center">wb+</td><td align="center">以读/写方式打开或新建一个二进制文件，允许读和写</td></tr><tr><td align="center">wt+</td><td align="center">以读/写方式打开或新建一个文本文件，允许读和写</td></tr><tr><td align="center">at+</td><td align="center">以读/写方式打开一个文本文件，允许读或追加内容</td></tr><tr><td align="center">ab+</td><td align="center">以读/写方式打开一个二进制文件，允许读或追加内容</td></tr></tbody></table><hr><p>如有错误，请在评论留言，非常感谢( ^ω^)。</p><p>本文整理自</p><p><a href="http://c.biancheng.net/view/2054.html" target="_blank" rel="noopener">C语言fopen函数的用法，C语言打开文件详解</a></p><p><a href="http://c.biancheng.net/cpp/html/250.html" target="_blank" rel="noopener">C语言fopen()函数：打开一个文件并返回文件指针</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言随机数</title>
      <link href="/2020/08/11/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2020/08/11/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天（2020/8/10）探究了如何使用C语言来生成随机数后，深夜写下此文作为笔记 (<em>/ω＼</em>) 。</p><a id="more"></a><h2 id="rand-函数"><a href="#rand-函数" class="headerlink" title="rand()函数"></a>rand()函数</h2><p>在C语言中，可以使用<code>&lt;stdlib.h&gt;</code>头文件中的<code>rand()</code>函数来生成随机数。<code>rand()</code>会随机生成一个位于<strong>0~RAND_MAX</strong>区间的整数，<code>RAND_MAX</code>是<code>&lt;stdlib.h&gt;</code>头文件中的一个宏，用来指示<code>rand()</code>函数返回的随机数的最大值，但C语言中并没有规定<code>RAND_MAX</code>的具体数值，只是规定该值最小为<strong>32767</strong>。在实际使用中一般也不需要知道<code>RAND_MAX</code>的具体数值。</p><h3 id="rand-函数的使用"><a href="#rand-函数的使用" class="headerlink" title="rand()函数的使用"></a>rand()函数的使用</h3><p>用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=rand();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rand-函数的局限性"><a href="#rand-函数的局限性" class="headerlink" title="rand()函数的局限性"></a>rand()函数的局限性</h3><p>如果多次运行以上的代码，产生的随机数是相同的，因为<code>rand()</code>函数产生的随机数是伪随机数，是用一个“种子”（seed，数值）根据特定公式运算生成的。当计算机在每一次启动时，“种子”是随机的，但当计算机完成启动后，“种子”一般就不再发生改变；因此，当计算机启动后，只使用<code>rand()</code>函数生成的随机数是固定不变的，直至计算机的下一次启动。</p><h2 id="srand-函数"><a href="#srand-函数" class="headerlink" title="srand()函数"></a>srand()函数</h2><p>使用<code>&lt;stdlib.h&gt;</code>头文件中的<code>srand()</code>函数可以修改“种子”，该函数需要一个<code>unsigned int</code>类型的参数作为修改“种子”的参考，该参数可以是当前的系统时间，也可以是其它变量例如当前的进程号。</p><h3 id="srand-函数的使用"><a href="#srand-函数的使用" class="headerlink" title="srand()函数的使用"></a>srand()函数的使用</h3><p>用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>使用<code>&lt;time.h&gt;</code>头文件中的<code>time()</code>函数可以获得当前的系统时间（精确度：秒）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> x=rand();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成一定范围内的随机数"><a href="#生成一定范围内的随机数" class="headerlink" title="生成一定范围内的随机数"></a>生成一定范围内的随机数</h2><p>在实际开发中，一般需要生成在某一个范围内的随机数，那么这时就可以使用取余运算来实现随机数的范围限定。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>生成0~9的随机数：</p><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="keyword">rand</span>()%10;<span class="comment">//此时生成随机数的下限和上限分别是0和9</span></span><br></pre></td></tr></table></figure><p>生成20~29的随机数：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x=rand()%<span class="number">10</span>+<span class="number">20</span>;<span class="comment">//此时相对于范围0~9，生成随机数的下限和上限分别增加了20</span></span><br></pre></td></tr></table></figure><p>生成14~22的随机数：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x=rand()%<span class="number">9</span>+<span class="number">14</span>;<span class="comment">//此时相对于范围0~8，生成随机数的下限和上限分别增加了14</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>生成范围为a~b的随机数x：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int x=<span class="built_in">rand</span>()<span class="comment">%(b-a+1)+a;</span></span><br></pre></td></tr></table></figure><h2 id="连续生成多个随机数"><a href="#连续生成多个随机数" class="headerlink" title="连续生成多个随机数"></a>连续生成多个随机数</h2><p>可以使用循环语法实现连续生成多个随机数。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>连续生成10个10~27范围内的随机数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//srand()函数不能放置于循环体内</span></span><br><span class="line"><span class="keyword">int</span> x=rand()%<span class="number">18</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong><code>srand()</code>函数不能放置于循环体内</strong>。假如<code>srand()</code>函数放置于循环体内，因为<code>rand()</code>函数是使用<code>srand()</code>函数的返回值来运算的，而<code>srand()</code>函数的每一次重新调用，<code>srand()</code>函数在每一秒内（<code>srand((unsigned)time(NULL));</code>的精确度为秒，而该循环算法的运算速度极快）运算得到的结果都是一致的，因此<code>rand()</code>函数的返回值都是一致的。</p><hr><p>如有错误，请大佬在评论区多多指教，不胜感激ヾ(≧▽≦*)o。</p><p>本文整理自</p><p><a href="http://c.biancheng.net/view/2043.html" target="_blank" rel="noopener">C语言随机数生成教程，C语言rand和srand用法详解</a></p><p><a href="https://blog.csdn.net/xyphf/article/details/72938174" target="_blank" rel="noopener">C语言，如何取一组固定范围的随机数-xyphf</a></p><p><a href="https://blog.csdn.net/brk1985/article/details/33722471" target="_blank" rel="noopener">随机数函数srand和rand()的使用心得</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下su和sudo命令的区别</title>
      <link href="/2020/07/31/Linux%E4%B8%8Bsu%E5%92%8Csudo%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/31/Linux%E4%B8%8Bsu%E5%92%8Csudo%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>su</code>和<code>sudo</code>是Linux中两个最常用的切换到root用户的命令，虽然功能类似，但在使用上还是有不少差异。</p><a id="more"></a><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p><code>su</code>是切换到root用户的传统命令，其主要用法是：</p><ul><li><code>su</code>：不带参数直接输入<code>su</code>将切换到root用户，需要输入root密码</li><li><code>su -</code>：等同于<code>su -l</code>，切换到root用户并启用root的环境变量（等同于以root身份登录，而<code>su</code>在切换到root用户之后依然保留原始用户的环境变量）</li><li><code>su -l 用户名</code>：切换到其他用户，需要输入该用户的密码</li><li><code>su -c 命令</code>：以root用户的身份执行命令，类似于sudo，不同之处是需要输入root密码</li></ul><p><code>su</code>命令主要用来切换root身份，前提是<strong>需要知道root密码</strong>。</p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><code>sudo</code>可以在<strong>不泄露或不设置root密码</strong>的前提下让用户执行特权命令，并且<code>sudo</code>提供命令历史记录。<code>sudo</code>一些常见用法：</p><ul><li><code>sudo 命令</code>：以root身份执行命令，命令需要在默认PATH路径下，否则会出现错误提示</li><li><code>sudo -i</code>：以root身份登录</li><li><code>sudo -s</code>：一般等同于<code>sudo bash</code>，进入root环境，但不改变工作目录</li><li><code>sudo su</code>：以<code>sudo</code>方式执行<code>su</code>命令</li></ul><h2 id="su和sudo的主要区别"><a href="#su和sudo的主要区别" class="headerlink" title="su和sudo的主要区别"></a>su和sudo的主要区别</h2><ol><li><code>su</code>可以不带参数执行，<code>sudo</code>不行</li><li><code>su</code>获取root权限时输入的是root密码，而<code>sudo</code>需要输入的是用户密码</li><li>当root密码未设置时，<code>sudo</code>能获取root权限，<code>su</code>不行</li><li>只有<code>/etc/sudoers</code>（操作系统：Ubuntu 20.04 LTS；Ubuntu其他版本或其他发行版可能略有不同）文件中的用户才能使用<code>sudo</code>命令；任何人都能使用<code>su</code>命令</li><li><code>su</code>可以切换到其他用户，<code>sudo</code>只能切换到root用户（虽然<code>sudo su -l 用户名</code>也可以切换到其他用户，但这是<code>su</code>的能力）</li><li><code>sudo</code>只允许使用root权限运行<strong>单</strong>个命令，<code>su</code>会在终端的当前会话中打开一个子会话，同时允许使用root权限运行尽可能<strong>多</strong>的命令，直至退出</li></ol><hr><p>本文整理自</p><p><a href="https://tlanyan.me/difference-between-sudo-su-in-linux/" target="_blank" rel="noopener">Linux系统su和sudo命令的区别</a></p><p><a href="https://blog.csdn.net/suwu150/article/details/71554302?utm_source=app" target="_blank" rel="noopener">深入理解 sudo 与 su 之间的区别</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux小记——APT和Dpkg</title>
      <link href="/2020/07/31/Linux%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94APT%E5%92%8CDpkg/"/>
      <url>/2020/07/31/Linux%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94APT%E5%92%8CDpkg/</url>
      
        <content type="html"><![CDATA[<p>APT（Advanced Packaging Tools）和Dpkg（Debian Package Manager）都是Debian及其派生的Linux发行版上的包管理工具；当前使用的操作系统为Ubuntu 20.04 LTS。</p><a id="more"></a><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>在镜像源中，软件包的相关信息（例如版本号、依赖关系等）会被记录下来并生成软件包列表，本地系统的APT可从镜像源获取软件包列表；当APT收到软件包管理的请求（例如安装、升级、卸载等）时，它就通过读取软件包列表、分析软件包的依赖关系并与本地系统已有的软件包进行信息对比并判断是否需要从镜像源获取软件包，随后APT可卸载软件包或访问镜像源来获取软件包并进行解压、安装、配置。</p><p><strong>相较于Dpkg，APT可为软件包依赖关系的判断和解决提供便利，但APT无法安装系统本地的软件包。</strong></p><h2 id="Dpkg"><a href="#Dpkg" class="headerlink" title="Dpkg"></a>Dpkg</h2><p>Dpkg也可用于安装、卸载软件包，但作为<strong>相对底层的工具</strong>（与此相对的，APT为相对上层的工具），<strong>Dpkg可以安装本地的软件包，但不解决软件包的依赖关系，并且不关心镜像源内的软件</strong>。</p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><h3 id="apt-update和apt-upgrade的区别"><a href="#apt-update和apt-upgrade的区别" class="headerlink" title="apt update和apt upgrade的区别"></a>apt update和apt upgrade的区别</h3><p><code>apt update</code>用于<strong>更新</strong>系统本地的软件包<strong>列表</strong>；<code>apt upgrade</code>用于<strong>升级</strong>软件包。</p><p>要升级软件包，APT首先会读取软件包列表，只有列表中软件包的版本新于本地软件包的版本，APT才会从镜像源获取新版本的软件包，所以<code>apt update</code>必须要在执行<code>apt upgrade</code>之前执行。</p><hr><p>本人小白一个(つд⊂)，如有错误，请在评论区留言，谢谢(^y^)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux小记（一）</title>
      <link href="/2020/07/29/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/29/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>一篇关于Termux目录结构和超级用户权限的小记(ﾉ∀`*)。</p><a id="more"></a><ol><li><p>与大多数Linux发行版不同，Termux不遵循<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="noopener">文件系统层次结构标准</a>，无法在标准路径下找到 /bin、/etc、/usr 等目录，但Termux提供了一个特殊的环境变量<code>PREFIX</code>，其相当于目录<code>/usr</code>。</p><p><img src="/images/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/usr.jpg" alt></p><p><img src="/images/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/USR.png" alt></p></li></ol><ol start="2"><li><p>用户主目录也在非常规位置。</p><p><img src="/images/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/home.jpg" alt></p><p><img src="/images/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/HOME.png" alt></p></li></ol><ol start="3"><li><p>Termux的<code>$PREFIX</code>路径和标准Linux根路径下的目录结构虽有差别，但存在一定的对应关系：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Termux的<span class="variable">$PREFIX</span><span class="regexp">/bin  &lt;=&gt;  标准Linux环境的 /</span>bin和<span class="regexp">/usr/</span>bin</span><br><span class="line">Termux的<span class="variable">$PREFIX</span><span class="regexp">/lib  &lt;=&gt;  标准Linux环境的 /</span>lib和<span class="regexp">/usr/</span>lib</span><br><span class="line">Termux的<span class="variable">$PREFIX</span><span class="regexp">/var  &lt;=&gt;  标准Linux环境的 /</span>var</span><br><span class="line">Termux的<span class="variable">$PREFIX</span><span class="regexp">/etc  &lt;=&gt;  标准Linux环境的 /</span>etc</span><br></pre></td></tr></table></figure><p><strong>基本可以认为Termux的<code>$PREFIX/</code>对应着标准Linux的<code>/</code>（根）路径。</strong></p></li></ol><ol start="4"><li><p>如果手机已root，使用<code>su</code>虽然可以切换为root用户，但是会有一些命令无法正常使用，毕竟这不是一个标准的Linux环境；但Termux中有代替su的程序<code>tsu</code>，可以通过<code>tsu</code>来获取root权限。</p><p>安装<code>tsu</code>：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pkg i -y tsu</span></span><br></pre></td></tr></table></figure><p>切换为root用户：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tsu</span></span><br></pre></td></tr></table></figure><p>使用root权限执行命令：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">tsudo <span class="tag">&lt;<span class="name">命令</span>&gt;</span></span><br></pre></td></tr></table></figure><p>返回到普通用户：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span><span class="regexp">//</span>也可以单独使用 CTRL+D 组合键</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>但对于一些必须要用到标准路径的程序，可以安装<code>proot</code>，并使用<code>termux-chroot</code>命令来模拟root环境和标准Linux目录结构，<strong>但存在一定的局限性</strong>。</p><p>安装<code>proot</code>：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pkg i -y proot</span></span><br></pre></td></tr></table></figure><p>执行<code>termux-chroot</code>：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">termux-chroot</span></span><br></pre></td></tr></table></figure><p>返回到普通用户：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span><span class="regexp">//</span>也可以单独使用 CTRL+D 组合键</span><br></pre></td></tr></table></figure><p><img src="/images/Termux%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/proot.jpg" alt></p></li></ol><hr><p>(,,・ω・,,)本文整理自</p><p><a href="https://p3terx.com/archives/termux-tutorial-1.html" target="_blank" rel="noopener">Termux 使用教程 #1 - Android 手机安装 Linux</a></p><p><a href="https://tonybai.com/2017/11/09/hello-termux/" target="_blank" rel="noopener">Hello，Termux</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Termux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Termux传输文件</title>
      <link href="/2020/07/28/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/28/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Android手机内置存储分区上的文件比如照片，视频，文档等除了除了能通过数据线传输到其他设备或使用奶牛快传、文叔叔这类服务商的中转服务器外，其实还可以利用Termux在Android手机上搭建一个文件服务器，同时目标设备和该Android手机接入同一局域网，则可以实现手机内文件的端对端单向传输ლ(╹◡╹ლ)。</p><a id="more"></a><h2 id="访问内置存储分区"><a href="#访问内置存储分区" class="headerlink" title="访问内置存储分区"></a>访问内置存储分区</h2><p>由于Termux默认只能访问其APP内的数据（位于Data分区），所以需要输入如下命令（不能在SSH客户端上输入），Android则会授予Termux读写手机存储的权限，选择“允许”即可。</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">termux-<span class="built_in">setup</span>-storage</span><br></pre></td></tr></table></figure><p>然后，安装<code>tree</code>程序。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> tree</span><br></pre></td></tr></table></figure><p>安装完成后，使用以下命令，即可创建目录<code>/data/data/com.termux/files/home/storage</code>，该目录下包含了指向内置存储分区的符号链接。</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tree</span> storage</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/storage.jpg" alt></p><h2 id="搭建服务端环境"><a href="#搭建服务端环境" class="headerlink" title="搭建服务端环境"></a>搭建服务端环境</h2><p>目前我了解到的可用于端对端文件传输的开发环境有两种(,,・ω・,,)：<code>Node.js</code>和<code>Python</code>。</p><h3 id="Node-js环境下搭建服务端"><a href="#Node-js环境下搭建服务端" class="headerlink" title="Node.js环境下搭建服务端"></a>Node.js环境下搭建服务端</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt <span class="keyword">install</span> nodejs</span><br></pre></td></tr></table></figure><h4 id="安装http-server"><a href="#安装http-server" class="headerlink" title="安装http-server"></a>安装http-server</h4><p>使用npm命令来安装模块http-server。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g <span class="keyword">http</span>-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><h4 id="运行http-server"><a href="#运行http-server" class="headerlink" title="运行http-server"></a>运行http-server</h4><p>通过Node.js来运行http-server模块。</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">http-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/js.jpg" alt></p><p>然后在目标设备得浏览器上输入Termux返回的IP和端口号即可访问服务端的内置存储分区；</p><p>如要结束http-server的运行，使用组合键<code>CTRL-C</code>。</p><h3 id="Python环境下搭建服务端"><a href="#Python环境下搭建服务端" class="headerlink" title="Python环境下搭建服务端"></a>Python环境下搭建服务端</h3><h4 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt <span class="keyword">install</span> python</span><br></pre></td></tr></table></figure><h4 id="运行http-server-1"><a href="#运行http-server-1" class="headerlink" title="运行http.server"></a>运行http.server</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">python -m http.server <span class="number">8080</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/python.jpg" alt></p><p>同样需要在目标设备的浏览器上输入服务端的IP和默认设置的端口号（即8080号端口）。</p><p>服务端的IP可使用<code>ifconfig</code>命令查询。</p><p><img src="/images/%E4%BD%BF%E7%94%A8Termux%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/ip.jpg" alt></p><p>若要结束http.server的运行，同样是使用组合键<code>CTRL-C</code>。</p><hr><p>萌新上路(つд⊂)，请多多指教ლ(╹◡╹ლ)，非常感谢(≧∀≦)ゞ。</p><p><strong>本文参考资料</strong></p><p><a href="https://p3terx.com/archives/termux-tutorial-1.html" target="_blank" rel="noopener">Termux 使用教程 #1 - Android 手机安装 Linux</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/07/termux-tutorial.html" target="_blank" rel="noopener">Termux 入门教程：架设手机 Server 下载文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Termux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xposed的安装和使用</title>
      <link href="/2020/07/26/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/26/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Xposed是一套在Android高权限下运行的开源的框架服务，可实现对Android系统或应用功能上的拓展。原版的<a href="https://github.com/rovo89/Xposed" target="_blank" rel="noopener">Xposed框架</a>发布于2017年7月；2019年1月，ElderDrivers在原版Xposed的基础上完成了一款依赖于riru框架的Magisk模块 —— <a href="https://github.com/ElderDrivers/EdXposed" target="_blank" rel="noopener">EdXposed</a>；2020年1月，EdXposed与原版Xposed的开发者达成共识，由<a href="http://edxp.meowcat.org/" target="_blank" rel="noopener">EdXposed</a>的开发者接手Xposed的维护和更新。</p><a id="more"></a><h2 id="Xposed的原理"><a href="#Xposed的原理" class="headerlink" title="Xposed的原理"></a>Xposed的原理</h2><p>在Android的/system/bin目录下，有一个用于启动Zygote进程的程序app_process（Zygote进程是Android创建新进程的核心进程），Xposed框架通过替换app_process程序实现对系统或应用的某些进程的拦截，然后加载特定Xposed模块的代码，并将该模块的进程注入（即替换被拦截的进程），从而达到修改运行结果的目的。</p><h2 id="EdXposed的安装"><a href="#EdXposed的安装" class="headerlink" title="EdXposed的安装"></a>EdXposed的安装</h2><p>因为EdXposed是由原版Xposed衍生而来的，且兼容原版Xposed，所以本文以EdXposed的安装为例（原版Xposed的安装方法与EdXposed不一样）。</p><p>EdXposed框架的安装并不难(っ・Д・)っ。</p><p>首先，安装Magisk框架（EdXposed实际上是一款Magisk模块），具体可见上一篇文章。</p><p>然后，在Magisk Manager中安装Riru - Core，Riru - Core是所有Riru模块运行的基础，有些ROM包可能会内置Riru - Core，就不需要再安装了，重复安装会卡开机界面，但也不能直接安装其它Riru模块，需要联系该ROM包的作者拿到专用的可以跳过Riru - Core检测的模块。</p><p><img src="/images/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/core.jpg" alt></p><p>刷入Riru - Core模块重启手机后，安装Riru - EdXposed模块，该模块有两个版本（YAHFA和SandHook），YAHFA版本的稳定性相对较高（相对没那么容易翻车），而SandHook版本的运行效率则相对较高（相对较少卡顿）。</p><p><img src="/images/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC.jpg" alt></p><p>再次重启手机后，安装EdXposed框架的图形管理界面EdXposed Manager（可从<a href="https://github.com/ElderDrivers/EdXposedManager/releases/tag/v4.5.7.0.0" target="_blank" rel="noopener">GitHub</a>下载）。</p><p><img src="/images/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/Manager.jpg" alt></p><p>如果一切顺利，打开EdXposed Manager，则提示“EdXposed 框架已激活”，就可以安装Xposed模块了。</p><p><img src="/images/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/%E6%BF%80%E6%B4%BB.jpg" alt></p><p>EdXposed Manager的使用和Magisk Manager类似(<em>´з｀</em>)。</p><h2 id="Xposed模块的安装和使用"><a href="#Xposed模块的安装和使用" class="headerlink" title="Xposed模块的安装和使用"></a>Xposed模块的安装和使用</h2><p>Xposed模块以APK的形式打包，可在EdXposed Manager下载，也可在<a href="https://www.coolapk.com/apk/tag/xposed" target="_blank" rel="noopener">酷安</a>下载或关注酷安上一些大佬们的分享，下载后像普通APP那样直接安装就可以了。</p><p>模块安装完成后，需要在EdXposed Manager侧边栏的“模块”选项中启用对应的模块。</p><p><img src="/images/Xposed%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/%E6%A8%A1%E5%9D%97.jpg" alt></p><p>至此，就可以愉快地使用Xposed了σ`∀´)σ。如有错误，请大佬多多指教。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TWRP和Magisk的初级使用</title>
      <link href="/2020/07/17/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/17/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>终于考完试了(ﾉ&gt;ω&lt;)ﾉ。</p><a id="more"></a><hr><h2 id="TWRP的初级使用"><a href="#TWRP的初级使用" class="headerlink" title="TWRP的初级使用"></a>TWRP的初级使用</h2><p>刷入TWRP后就可以刷入Magisk了，不过首先应当初步了解TWRP的使用。</p><h3 id="解密Data分区"><a href="#解密Data分区" class="headerlink" title="解密Data分区"></a>解密Data分区</h3><p>若Data分区被系统加密，则TWRP显示的内置存储分区中的文件名乱码，这时就需要使用TWRP的自动解密Data分区的功能，进入TWRP时，需要输入系统的锁屏密码来验证使用者身份（若无设置锁屏密码则不需要），验证通过后将自动解密Data分区。</p><h3 id="“设置”"><a href="#“设置”" class="headerlink" title="“设置”"></a>“设置”</h3><p>进入主界面后，界面的默认语言为英语，为了方便使用，需要到“设置”选项把界面语言改为”Chinese(Simplified)“（简体中文），当然，改成其它语言也没人拦着你。。。(っ・Д・)っ</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E8%AE%BE%E7%BD%AE.jpg" alt></p><p><img src="images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80.jpg" alt></p><h3 id="“安装”"><a href="#“安装”" class="headerlink" title="“安装”"></a>“安装”</h3><p>点击进入“安装”界面，可在此刷入文件（包括但不限于ROM包、Magisk框架）。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E5%AE%89%E8%A3%85.jpg" alt></p><h3 id="“清除”"><a href="#“清除”" class="headerlink" title="“清除”"></a>“清除”</h3><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%B8%85%E9%99%A4.jpg" alt></p><p>进入界面后，“滑动按钮确认恢复出厂”将会清除Dalvik、Cache和Data分区，也就是常说的“三清”（但不知道为什么界面会显示“双清”( ˘•ω•˘ )）。</p><p>另外，当刷入的系统与原系统差别过大（比如MIUI刷入Flyme）或ROM包的作者要求时，还需要选择“格式化Data分区”，此时会清除包括内置存储分区的所有数据，在此操作前务必转移重要的文件。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE%E7%A1%AE%E8%AE%A4%E6%81%A2%E5%A4%8D%E5%87%BA%E5%8E%82.jpg" alt></p><p>也可以在“高级清除”中自定义要清除的分区。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E9%AB%98%E7%BA%A7%E6%B8%85%E9%99%A4.jpg" alt></p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE%E7%A1%AE%E8%AE%A4%E6%B8%85%E9%99%A4.png" alt></p><h3 id="“备份”和“恢复”"><a href="#“备份”和“恢复”" class="headerlink" title="“备份”和“恢复”"></a>“备份”和“恢复”</h3><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D.jpg" alt></p><p>在刷机过程中，倘若“翻车”造成数据丢失，不仅可能造成手机内存储的重要资料的丢失，还有可能造成系统的其它分区损坏，进而导致手机“变砖”，这时如果有该分区的备份，则将会有利于“救砖”。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE%E7%A1%AE%E8%AE%A4%E5%A4%87%E4%BB%BD.png" alt></p><p>选择需要备份的分区，“滑动按钮确认备份”即可把目标分区备份至<strong>内置存储</strong>中；若要恢复备份，进入“恢复”界面，选择<strong>内置存储</strong>中的备份文件即可恢复。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%81%A2%E5%A4%8D.png" alt></p><h3 id="“高级”"><a href="#“高级”" class="headerlink" title="“高级”"></a>“高级”</h3><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E9%AB%98%E7%BA%A7.jpg" alt></p><p>在“高级”选项中，“ADB Sideload”选项用于清除Dalvik和Cache分区。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/adbsideload.jpg" alt></p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE%E5%BC%80%E5%A7%8B.png" alt></p><p>“终端命令”选项就是调出TWRP的终端（TWRP是一个经过大幅度精简的Linux），大多数的Linux命令都可以在此执行<del>闲得无聊的时候可以在TWRP中练习一下Linux命令(つд⊂)</del>。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4.jpg" alt></p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/Linux.png" alt></p><h2 id="Magisk的初级使用"><a href="#Magisk的初级使用" class="headerlink" title="Magisk的初级使用"></a>Magisk的初级使用</h2><p>Magisk是由一位台湾学生<a href="https://twitter.com/topjohnwu" target="_blank" rel="noopener">@topjohnwu</a>开发的一款Android框架，可获取系统的root以及通过安装拓展模块来实现功能的拓展；其原理是通过启动时在 boot 中创建钩子，把 /data/magisk.img 挂载到 /magisk，构建出一个在 system 基础上能够自定义替换，增加以及删除的文件系统，所有操作都在启动的时候完成，实际上并没有对 /system 分区进行修改（即 systemless 接口，以不触动 /system 的方式修改 /system）（来源：<a href="https://cn.apkjam.com/magisk.html" target="_blank" rel="noopener">安卓果酱</a>）。按照我的理解（萌新一枚，大佬勿喷，请多多指教，谢谢）(つд⊂)，其原理是系统启动时在Android的根目录下挂载一个虚拟分区，通过只对该分区进行读、写和执行（整个过程中并未对System分区进行修改）间接性地更改System分区的部分运行结果（以我目前（2020/7）的认知，这一间接性更改运行结果的原理我还想不通 (´∩ω∩｀) ，我唯一想到的实现方式是：Magisk挂载的虚拟分区劫持System分区的部分进程并在其中导入经过修改的进程进而实现对运行结果的修改，不知道是不是这样 (´∩ω∩｀) ）。</p><h3 id="刷入Magisk"><a href="#刷入Magisk" class="headerlink" title="刷入Magisk"></a>刷入Magisk</h3><p>先放下烧脑的运行机制，以后有能力了再琢磨(๑•́ ₃ •̀๑)。</p><p>Magisk的刷入并不难，进入TWRP的“安装”界面，找到要刷入的镜像。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E5%88%B7%E5%85%A5Magisk.jpg" alt></p><p>选中该镜像，“滑动按钮确认刷入”，默认安装完成后重启。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE%E7%A1%AE%E8%AE%A4%E5%88%B7%E5%85%A5.jpg" alt></p><p>（其实ROM包的刷入也基本是这样）</p><p>刷入Magisk框架的同时，也会安装Magisk的图形管理界面Magisk Manager。</p><h3 id="Magisk-Manager"><a href="#Magisk-Manager" class="headerlink" title="Magisk Manager"></a>Magisk Manager</h3><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/Manager.jpg" alt></p><p>打开Magisk Manager进入界面后，可检查Magisk框架是否正确安装。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E4%B8%BB%E7%95%8C%E9%9D%A2.jpg" alt></p><p><strong>如果框架和模块之间不存在任何兼容问题，就不推荐升级框架。</strong></p><h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7.jpg" alt></p><p>侧边栏的“超级用户”选项可管理系统是否对APP授予root权限。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%8E%88%E6%9D%83.jpg" alt></p><h4 id="Magisk模块"><a href="#Magisk模块" class="headerlink" title="Magisk模块"></a>Magisk模块</h4><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E6%A8%A1%E5%9D%97.jpg" alt></p><p>“模块”选项中可安装内置存储中的Magisk模块，并对已安装的模块进行管理（停用或删除）。</p><p><img src="/images/TWRP%E5%92%8CMagisk%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/%E5%8A%A0%E5%8F%B7.jpg" alt></p><p>侧边栏“下载”选项中可获取的模块比较少，可以从酷安大佬们的安利中获取模块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
            <tag> TWRP </tag>
            
            <tag> Magisk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android手机刷入第三方REC</title>
      <link href="/2020/07/12/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/"/>
      <url>/2020/07/12/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/</url>
      
        <content type="html"><![CDATA[<p>REC又称Recovery，其本体实际上是一个经过大幅度精简、带有简单图形界面的Linux，其作用类似于PC上的Windows PE，可用于对Android手机内文件的备份、修改以及系统的替换，但基本上手机厂商提供的官方REC相较于第三方REC存在很大的局限性，所以玩机前要把手机厂商提供的官方REC替换成第三方REC。目前（2020/7）主流的第三方REC是<a href="https://twrp.me/" target="_blank" rel="noopener">TWRP</a>和<a href="https://orangefox.download/zh-CN/" target="_blank" rel="noopener">OrangeFox</a>。本文使用Redmi K20 Pro刷入TWRP为示例，方法上大同小异。</p><a id="more"></a><p><strong>刷机前一定要备份数据！！！</strong></p><hr><h2 id="BootLoader解锁"><a href="#BootLoader解锁" class="headerlink" title="BootLoader解锁"></a>BootLoader解锁</h2><p>BootLoader中文名称为“引导加载程序”，在嵌入式操作系统中，BootLoader是在操作系统内核运行前运行的，其作用是将系统的软硬件环境调试至最佳状态，为操作系统内核的运行作准备。BootLoaer锁是手机厂商限制用户给手机刷入第三方ROM或第三方REC的一种机制，在刷入REC或ROM包等文件时，BootLoader会校验其文件签名，未通过校验则无法刷入，而只有官方签名才能通过校验，一方面是为了防止用户刷机不当造成手机变砖，另一方面也是为了维护手机厂商的利益（比如说你刷了类原生ROM，那么手机厂商就不能在你那台手机中植入广告来获利了）。总之，要想刷机，就必须要解除BootLoader对文件签名的校验，简称“解BL锁”（当然，不是所有手机刷机前都需要解BL锁，少部分机型没BL锁就不需要，例如小米4）。</p><h3 id="解BL锁的流程"><a href="#解BL锁的流程" class="headerlink" title="解BL锁的流程"></a>解BL锁的流程</h3><p>以小米（包括Redmi）为例，其它品牌的机型请参考各自的官方论坛的信息( ˘･з･)。</p><p>在<strong>设置</strong>中进入<strong>开发者选项</strong>（连续多次点击<strong>MIUI版本</strong>（在<strong>我的设备</strong>&gt;<strong>全部参数</strong>中可找到MIUI版本）即可在<strong>更多设置</strong>显示被隐藏的入口），开启<strong>OEM解锁</strong>，并点击进入<strong>设备解锁状态</strong>，<strong>绑定账号和设备</strong>。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9.jpg" alt></p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/%E7%BB%91%E5%AE%9A%E8%B4%A6%E5%8F%B7%E5%92%8C%E8%AE%BE%E5%A4%87.jpg" alt></p><p>进入小米官方的<a href="https://www.miui.com/unlock/index.html" target="_blank" rel="noopener">解锁页面</a>，下载官方提供的解锁工具（好像需要先申请(ㆀ˘･з･˘) ）并解压到电脑上，打开解锁工具，按照提示进行操作即可。</p><p><strong>尽量使用原装数据线连接手机和电脑，用第三方数据线连接可能会出现解锁工具无法识别手机的情况。</strong></p><h2 id="配置ADB"><a href="#配置ADB" class="headerlink" title="配置ADB"></a>配置ADB</h2><p>ADB （全称 Android Debug Bridge，一种能让Android设备与电脑相互通信的命令行工具，其对Android设备的执行权限介乎于#和$之间），在这里用来给Android手机刷入第三方REC。本文以在Windows 10上配置ADB为例。</p><h3 id="下载ADB工具包"><a href="#下载ADB工具包" class="headerlink" title="下载ADB工具包"></a>下载ADB工具包</h3><p>从此<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip" target="_blank" rel="noopener">地址</a>下载ADB工具包（可能需要科学上网），解压到C盘的根目录下。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/%E8%A7%A3%E5%8E%8B.png" alt></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>环境变量是操作系统用来指定运行环境的一些参数，比如某个程序的完整路径。在Windows中需要正确配置ADB的环境变量才能在CMD中使用ADB。</p><p>依次打开<strong>此电脑</strong>&gt;<strong>计算机</strong>&gt;<strong>属性</strong>&gt;<strong>高级系统设置</strong>&gt;<strong>环境变量</strong>，在<strong>用户变量</strong>中选择<strong>Path</strong>，依次点击<strong>编辑</strong>&gt;<strong>新建</strong>，输入刚才解压到C盘根目录下的工具包的路径；接着在<strong>系统变量</strong>中同样选择<strong>Path</strong>，依次点击<strong>编辑</strong>&gt;<strong>新建</strong>，输入刚才的路径，保存后退出。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F.png" alt></p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F.png" alt></p><p>打开<strong>CMD</strong>（<strong>Win+R组合键</strong>打开<strong>运行</strong>窗口，输入<strong>cmd</strong>，点击<strong>确定</strong>），输入 <code>adb version</code> ，若出现类似于以下的信息，则说明ADB已配置成功。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/adb.png" alt></p><h2 id="刷入第三方REC"><a href="#刷入第三方REC" class="headerlink" title="刷入第三方REC"></a>刷入第三方REC</h2><p>解了BL锁，配置好ADB后，就可以刷入第三方REC了。</p><p>进入TWRP的<a href="https://twrp.me/Devices/" target="_blank" rel="noopener">下载页面</a>（前面已经说了，本文以TWRP的刷入为例(ﾟω´)），点击选择要刷入的机型，下载适配该机型的TWRP至电脑C盘的根目录下。</p><p>用数据线连接手机和电脑，在CMD中输入 <code>adb devices</code> ，若列出手机的序列号，则说明手机和ADB连接成功。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/adbdevices.png" alt></p><p>接着输入 <code>adb reboot fastboot</code> ，将手机重启至fastboot模式（fastboot模式相较于Recovery模式更接近于硬件层，可用于REC的替换）。</p><p>然后输入 <code>fastboot devices</code> ，若列出手机的序列号，则说明手机在fastboot模式下与ADB连接成功。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/fastbootdevices.png" alt></p><p>输入 <code>fastboot flash recovery &quot;C盘根目录下REC的路径&quot;</code> ，稍等一会儿TWRP就被刷入到手机中了</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/fastbootflashrecovery.png" alt></p><p>不过这个时候还不能拔出数据线重启手机，否则刚被刷入的TWRP会被官方REC覆盖，正确做法是在CMD中输入 <code>fastboot boot &quot;C盘根目录下REC的路径&quot;</code> 来使手机重启到Recovery模式，当看到TWRP的界面后，才能拔出数据线，亦可重启手机。</p><p><img src="/images/Android%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9REC/fastbootboot.png" alt></p><hr><p>至此，第三方REC的刷入就成功了σ`∀´)σ。</p><p>本文如有错误，还请大佬多多指教。</p><p>考完试后再干一篇TWRP的使用文章d(`･∀･)b。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
            <tag> TWRP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android手机双清、三清、四清</title>
      <link href="/2020/07/10/Android%E6%89%8B%E6%9C%BA%E5%8F%8C%E6%B8%85%E3%80%81%E4%B8%89%E6%B8%85%E3%80%81%E5%9B%9B%E6%B8%85/"/>
      <url>/2020/07/10/Android%E6%89%8B%E6%9C%BA%E5%8F%8C%E6%B8%85%E3%80%81%E4%B8%89%E6%B8%85%E3%80%81%E5%9B%9B%E6%B8%85/</url>
      
        <content type="html"><![CDATA[<hr><p>本文为备忘录，鬼知道自己什么时候会忘记(´ﾟдﾟ`)。</p><a id="more"></a><h2 id="双清"><a href="#双清" class="headerlink" title="双清"></a>双清</h2><p>Cache<br>Data<br>清除系统和应用的缓存、用户数据，即恢复出厂设置。</p><h2 id="三清"><a href="#三清" class="headerlink" title="三清"></a>三清</h2><p>Dalvik/ART Cache<br>Cache<br>Data<br>清除虚拟机缓存、系统和应用的缓存、用户数据；刷机前基本上必选清除这三个分区。</p><h2 id="四清"><a href="#四清" class="headerlink" title="四清"></a>四清</h2><p>Dalvik/ART Cache<br>Cache<br>Data</p><p>System</p><p>清除虚拟机缓存、系统和应用缓存、用户数据、系统分区；如果不确定待刷入的ROM包是否在本机可用或内置存储分区中没有可用于本机的ROM包的时候，建议还是别选择四清，万一无法刷入某ROM包，这就很尴尬了|(*′口`)。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><code>格式化Data分区</code>即为彻底清空<code>Data</code>分区，将会删除所有应用、备份、图片、视频等数据，并移除对内部存储的加密，通常当刷入的ROM与原ROM差异较大时使用，具体视刷入的ROM包的刷机说明而定。</li><li>在刷入官方系统全量包时，必须在重启手机前刷入Magisk框架，避免第三方REC被厂商的REC替换。</li><li>在刷入ROM包前，注意该ROM包对底包有什么要求。</li></ul><hr><p>我还不是老司机(ﾉ∀`*)，如有错误，请在评论区多多指教。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米Android设备代号收录整理</title>
      <link href="/2020/06/25/%E5%B0%8F%E7%B1%B3Android%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7%E6%94%B6%E5%BD%95%E6%95%B4%E7%90%86/"/>
      <url>/2020/06/25/%E5%B0%8F%E7%B1%B3Android%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7%E6%94%B6%E5%BD%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>小米Android设备代号在一般情况下用不到，但在搜索刷机资源时，部分类原生ROM和第三方REC的网站上给出的并不是机型，而是其设备代号，这时就需要通过对照不同机型所对应的设备代号（<strong>不区分字母大小写</strong>）来找到合适的资源。</p><a id="more"></a><h2 id="小米数字系列"><a href="#小米数字系列" class="headerlink" title="小米数字系列"></a>小米数字系列</h2><p>小米手机青春版：<code>Mione</code></p><p>小米1： <code>Mione Plus</code></p><p>小米1S： <code>Mione Plus</code></p><p>小米2： <code>Aries</code></p><p>小米2S： <code>Aries</code></p><p>小米3移动版： <code>Taurus</code></p><p>小米3电信联通版（小米3W）： <code>Cancro</code></p><p>小米4： <code>Cancro</code></p><p>小米4C： <code>Libra</code></p><p>小米4i： <code>Ferrari</code></p><p>小米4S： <code>Aqua</code></p><p>小米5： <code>Gemini</code></p><p>小米5S： <code>Capricorn</code></p><p>小米5S Plus： <code>Natrium</code></p><p>小米5C： <code>Meri</code></p><p>小米5X： <code>Tiffany</code></p><p>小米A1： <code>Tissot</code></p><p>小米6： <code>Sagit</code></p><p>小米6X： <code>Wayne</code></p><p>小米8： <code>Dipper</code></p><p>小米8SE： <code>Sirius</code></p><p>小米8透明探索版： <code>ursa</code></p><p>小米8屏幕指纹版： <code>equuleus</code></p><p>小米8青春版： <code>platina</code></p><p>小米9： <code>cepheus</code></p><p>小米9透明探索版： <code>cepheus</code></p><p>小米9SE： <code>grus</code></p><p>小米Play： <code>lotus</code></p><p>小米9 Pro 5G： <code>crux</code></p><p>小米10： <code>umi</code></p><p>小米10 Pro： <code>cmi</code></p><p>小米10青春版： <code>vangogh</code></p><p>小米10 Lite： <code>monet</code></p><p>小米10至尊纪念版： <code>cas</code></p><p>小米10S： <code>thyme</code></p><p>小米11： <code>venus</code></p><h2 id="小米CC系列"><a href="#小米CC系列" class="headerlink" title="小米CC系列"></a>小米CC系列</h2><p>小米CC9： <code>pyxis</code></p><p>小米CC9e： <code>laurus</code></p><p>小米CC9美图定制版： <code>vela</code></p><p>小米CC9 Pro： <code>tucana</code></p><h2 id="小米Note系列"><a href="#小米Note系列" class="headerlink" title="小米Note系列"></a>小米Note系列</h2><p>小米Note： <code>Virgo</code></p><p>小米Note Pro： <code>Leo</code></p><p>小米Note2： <code>Scorpio</code></p><p>小米Note3： <code>Jason</code></p><p>小米Note10 Lite： <code>toco</code></p><h2 id="小米MIX系列"><a href="#小米MIX系列" class="headerlink" title="小米MIX系列"></a>小米MIX系列</h2><p>小米MIX： <code>Lithium</code></p><p>小米MIX2： <code>Chiron</code></p><p>小米MIX2S： <code>Polaris</code></p><p>小米MIX3： <code>Perseus</code></p><p>小米MIX3 5G： <code>andromeda</code></p><h2 id="小米Max系列"><a href="#小米Max系列" class="headerlink" title="小米Max系列"></a>小米Max系列</h2><p>小米Max： <code>Hydrogen</code></p><p>小米Max Pro： <code>Helium</code></p><p>小米Max2： <code>Oxygen</code></p><p>小米Max3： <code>Nitrogen</code></p><h2 id="Redmi-K系列"><a href="#Redmi-K系列" class="headerlink" title="Redmi K系列"></a>Redmi K系列</h2><p>Redmi K20： <code>davinci</code></p><p>Redmi K20 Pro： <code>raphael</code></p><p>Redmi K20 Pro 尊享版： <code>raphaels</code></p><p>Redmi K30： <code>Phoenix</code></p><p>Redmi K30 5G： <code>picasso</code></p><p>Redmi K30 Pro： <code>lmi</code></p><p>Redmi K30 Pro 变焦版： <code>lmipro</code></p><p>Redmi K30 至尊纪念版： <code>cezanne</code></p><p>Redmi K30S 至尊纪念版： <code>apollo</code></p><p>Redmi K40： <code>alioth</code></p><p>Redmi K40 Pro： <code>haydn</code></p><h2 id="红米-Redmi数字系列"><a href="#红米-Redmi数字系列" class="headerlink" title="红米/Redmi数字系列"></a>红米/Redmi数字系列</h2><p>红米1： <code>HM1</code></p><p>红米1S： <code>Armani</code></p><p>红米2： <code>wt88047</code></p><p>红米2A： <code>wt88047</code></p><p>红米3： <code>Ido</code></p><p>红米3S： <code>Land</code></p><p>红米3X： <code>Land</code></p><p>红米 Pro： <code>Omega</code></p><p>红米4： <code>Prada</code></p><p>红米4A： <code>Rolex</code></p><p>红米4X： <code>Santoni</code></p><p>红米5： <code>Vince</code></p><p>红米 5Plus： <code>Vince</code></p><p>红米6： <code>Cereus</code></p><p>红米6A： <code>Cereus</code></p><p>红米6 Pro： <code>Sakura</code></p><p>红米 S2： <code>Ysl</code></p><p>红米4 Pro： <code>Markew</code></p><p>红米5A： <code>Riva</code></p><p>Redmi 7： <code>Onclite</code></p><p>Redmi 7A： <code>pine</code></p><p>Redmi 8： <code>olive</code></p><p>Redmi 8A： <code>olivelite</code></p><p>Redmi 8A Dual： <code>olivewood</code></p><p>Redmi 9： <code>lancelot</code></p><p>Redmi 9A： <code>dandelion</code></p><p>Redmi 9C： <code>angelica</code></p><p>Redmi 10X 4G： <code>merlin</code></p><p>Redmi 10X 5G： <code>atom</code></p><p>Redmi 10X Pro 5G： <code>bomb</code></p><h2 id="红米-Redmi-Note系列"><a href="#红米-Redmi-Note系列" class="headerlink" title="红米/Redmi Note系列"></a>红米/Redmi Note系列</h2><p>红米Note： <code>Dior</code></p><p>红米Note 双卡版： <code>Gucci</code></p><p>红米Note2： <code>Hermes</code></p><p>红米Note3 双网通： <code>Hennessy</code></p><p>红米Note3 全网通： <code>Kenzo</code></p><p>红米Note4： <code>Nikel</code></p><p>红米Note4X（MTK平台）： <code>Nikel</code></p><p>红米Note4X（高通平台）： <code>Mido</code></p><p>红米Note5： <code>Whyred</code></p><p>Redmi Note7： <code>lavender</code></p><p>Redmi Note7 Pro： <code>Violet</code></p><p>Redmi Note8： <code>ginkgo</code></p><p>Redmi Note8 Pro： <code>begonia</code></p><p>Redmi Note9 4G： <code>lime</code></p><p>Redmi Note9 5G： <code>cannon</code></p><h2 id="小米平板系列"><a href="#小米平板系列" class="headerlink" title="小米平板系列"></a>小米平板系列</h2><p>小米平板1： <code>Mocha</code></p><p>小米平板2： <code>Latte</code></p><p>小米平板3： <code>Cappu</code></p><p>小米平板4： <code>Clover</code></p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>在手机上安装并运行<a href="https://www.coolapk.com/apk/bin.mt.plus" target="_blank" rel="noopener">MT管理器</a>，访问<code>/system/build.prop</code>，找出以下信息即可获知设备代号（本人设备：Redmi K20 Pro，MIUI 12 powered by Android 10，可能与其他设备或UI存在差异）。</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">ro.<span class="built_in">product</span>.system.<span class="keyword">name</span>=raphael</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B0%8F%E7%B1%B3Android%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7%E6%94%B6%E5%BD%95%E6%95%B4%E7%90%86/%E5%B0%8F%E7%B1%B3Android%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7%E6%94%B6%E5%BD%95%E6%95%B4%E7%90%86.jpg" alt></p><p>也可以使用ADB命令查询设备代号。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">adb</span> <span class="selector-tag">shell</span> <span class="selector-tag">getprop</span> <span class="selector-tag">ro</span><span class="selector-class">.product</span><span class="selector-class">.name</span></span><br></pre></td></tr></table></figure><hr><p>本文内容整理自 <a href="https://mp.weixin.qq.com/s/IBf8T8JR5oTEUrGWXfX-Aw" target="_blank" rel="noopener">小米手机全系列设备代号一览</a></p><p>如有错误，请在评论区留言。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现字符串的加密和解密</title>
      <link href="/2020/06/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/"/>
      <url>/2020/06/15/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>昨晚在一个公众号上看到一篇记载了如何用C语言对输入的字符串进行加密和解密的文章（<a href="https://mp.weixin.qq.com/s?__biz=MzIyNjQ3NDk2Mg==&mid=2247484037&idx=1&sn=08d776216886438521b6f1c36eebd447&chksm=e86eac38df19252ece577441b5227f5074ce6c726d4018aecdb2993e3c0652ffc9f6e6a62766&xtrack=1&scene=90&subscene=93&sessionid=1592185369&clicktime=1592185382&enterid=1592185382&ascene=56&devicetype=android-29&version=27000f3d&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=AQDjK%2ByNWGDaXSFLnGAJcU4%3D&pass_ticket=aTkJAT%2FqUgZwKygLF6kG9wPdY3aSGL%2FemDyFsYZtDpYSLXsmN8dB1x03%2FG6swSHr&wx_header=1" target="_blank" rel="noopener">原文</a>），于是今天早上就试了一下。</p><a id="more"></a><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数字 0 使用本程序对输入的明文进行加密\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数字 1 对使用本程序加密的密文进行解密\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数字以选择加密或解密："</span>);</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入需要加密的明文："</span>);</span><br><span class="line"><span class="keyword">char</span> encrypt[<span class="number">512</span>]=&#123;&#125;;  <span class="comment">//存放明文字符串 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;encrypt);</span><br><span class="line"><span class="keyword">int</span> count=<span class="built_in">strlen</span>(encrypt);</span><br><span class="line"><span class="keyword">char</span> key[<span class="number">512</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line">key[i]=encrypt[i]+i;  <span class="comment">//将字符串中的每个字符加上它在字符串中的位置以实现字符的偏移</span></span><br><span class="line">key[count]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"经过本程序加密后的密文："</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入需要解密的密文："</span>);</span><br><span class="line"><span class="keyword">char</span> decrypt[<span class="number">512</span>]=&#123;&#125;;  <span class="comment">//存放密文字符串 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;decrypt);</span><br><span class="line"><span class="keyword">int</span> count=<span class="built_in">strlen</span>(decrypt);</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">text</span>[<span class="number">512</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">text</span>[i]=decrypt[i]-i;  <span class="comment">//将字符串中的每个字符减去它在字符串中的位置以实现字符的偏移</span></span><br><span class="line"><span class="built_in">text</span>[count]=<span class="string">'\0'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"经过本程序解密后的明文："</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">text</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/0.png" alt></p><p><img src="/images/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/1.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>You-Get的安装</title>
      <link href="/2020/06/14/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/06/14/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>You-Get是一款基于Python 3开发的命令行下载工具，使用You-Get可以轻松下载Web上的视频、图片和音乐，支持国内外的主流站点例如YouTube、网易云音乐、bilibili（支持的站点可参考官方的<a href="https://you-get.org/#supported-sites" target="_blank" rel="noopener">完整列表</a>），本文记录了我在Windows 10上安装You-Get的过程。</p><a id="more"></a><h2 id="安装Python-3"><a href="#安装Python-3" class="headerlink" title="安装Python 3"></a>安装Python 3</h2><p>访问<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官网</a>下载Python 3的安装包，当前（2020/6/14）的最新版本为3.8.3</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/python.png" alt></p><p>安装在默认路径就可以了（最好记录下安装路径（〃｀ 3′〃））</p><p>需要勾选<code>Add Python 3.8 to PATH</code>，安装程序就会将Python 3.8的安装路径添加进系统的环境变量</p><p>安装完成后在CMD中输入<code>python -V</code>，若能列出版本号（如下图，我的是以前安装的），即表示Python 3安装成功</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/3.png" alt></p><h2 id="安装FFmpeg"><a href="#安装FFmpeg" class="headerlink" title="安装FFmpeg"></a>安装FFmpeg</h2><p>来自<a href="https://zh.wikipedia.org/wiki/FFmpeg" target="_blank" rel="noopener">维基百科</a>：FFmpeg 是一个开放源代码的自由软件，可以运行音频和视频多种格式的录影、转换、流功能。</p><p>FFmpeg在下载流式视频以及合并分块视频时需要用到，强烈建议安装。</p><h3 id="FFmpeg下载"><a href="#FFmpeg下载" class="headerlink" title="FFmpeg下载"></a>FFmpeg下载</h3><p>进入<a href="https://ffmpeg.org/" target="_blank" rel="noopener">官网</a>下载FFmpeg的压缩包并解压。把解压后的文件夹放在C盘的根目录下（也可以放到其它路径）。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>打开<code>此电脑</code>，依次点击<code>计算机</code>&gt;<code>属性</code></p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E5%B1%9E%E6%80%A7.png" alt></p><p>点击<code>高级系统设置</code></p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE.png" alt></p><p>点击<code>环境变量</code></p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt></p><p>在<code>系统变量</code>中选中<code>Path</code>，点击<code>编辑</code></p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F.png" alt></p><p>依次进入<code>FFmpeg的文件夹</code>&gt;<code>bin</code>，复制当前的路径</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E8%B7%AF%E5%BE%84.png" alt></p><p>回到<code>编辑环境变量</code>，点击<code>新建</code>，粘贴刚才复制的路径，点击<code>确定</code></p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/%E6%9C%80%E5%90%8E.png" alt></p><p>在CMD中输入<code>ffmpeg -version</code>，若出现如图所示的信息，则表明FFmpeg安装成功</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/ffmpeg.png" alt></p><h2 id="安装You-Get"><a href="#安装You-Get" class="headerlink" title="安装You-Get"></a>安装You-Get</h2><p><a href="https://github.com/soimort/you-get/archive/master.zip" target="_blank" rel="noopener">点击此处</a>从GitHub下载You-Get的分支，解压至Python38的目录下（这就是记下Python 3的安装路径的原因(*￣rǒ￣)）</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/python38.png" alt></p><p>在CMD中输入<code>you-get -V</code>，若出现以下信息，则表示You-Get安装成功</p><p><img src="/images/You-Get%E7%9A%84%E5%AE%89%E8%A3%85/you-get.png" alt></p><p>完成以上的步骤，就可以使用You-Get了︿(￣︶￣)︿，至于You-Get的使用，考完期末考试后再折腾（我可不想挂科╰(￣▽￣)╭）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> You-Get </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>top命令笔记</title>
      <link href="/2020/06/10/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/10/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>top命令是Linux下常用的用于显示进程信息的工具，可实时显示Linux中各个进程的资源使用情况，还可实时显示CPU和内存的使用情况。</p><a id="more"></a><h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span> <span class="selector-attr">[选项]</span></span><br></pre></td></tr></table></figure><h2 id="命令常用选项"><a href="#命令常用选项" class="headerlink" title="命令常用选项"></a>命令常用选项</h2><p><code>-c</code>：显示完整的命令</p><p><code>-n num</code>：设置信息更新次数为num，完成后将会退出top</p><p><code>-d num</code>：设置信息更新周期为num秒</p><p><code>-p &lt;进程号&gt;</code>：显示指定进程号的进程信息</p><p><code>-u &lt;用户名&gt;</code>：显示指定用户名的进程信息</p><p><code>-b</code>：批处理模式，当想要在文件中保存输出时是很有用的</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="显示进程信息"><a href="#显示进程信息" class="headerlink" title="显示进程信息"></a>显示进程信息</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="built_in">top</span></span><br></pre></td></tr></table></figure><p><img src="/images/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/top.png" alt></p><p>前五行是当前的系统资源使用情况</p><ul><li><p><code>17:39:00</code>：当前的系统时间为17:39:00</p></li><li><p><code>up 16 min</code>：系统已运行16分钟</p></li><li><p><code>1 user</code>：当前有1位用户登录系统</p></li><li><p><code>load average:0.00,0.05,0.14</code>：分别表示最近1分钟、5分钟、15分钟的CPU的平均负载情况。假设Linux运行在一台只搭载一个单核CPU的计算机上，当CPU完全空闲的时候，<code>load average</code>的值为0；当CPU满负荷运行的时候，<code>load average</code>的值等于或大于1（当且仅当<code>load average</code>的值等于1时，CPU刚好处于满负荷运行状态且没有进程待处理；当<code>load average</code>的值大于1时，CPU处于满负荷运行状态且有进程待处理）；在实际使用中，一般认为当最近15分钟的<code>load average</code>的值大于<code>0.7*CPU核心数</code>的值时，需要引起关注。</p></li><li><p><code>191 total</code>：系统当前共有191个进程</p></li><li><p><code>1 running</code>：运行进程有1个</p></li><li><p><code>190 sleeping</code>：睡眠进程有190个</p></li><li><p><code>0 stopped</code>：停止进程有0个</p></li><li><p><code>0 zombie</code>：僵尸进程有0个</p></li><li><p><code>0.8 us</code>：运行（未调整优先级的）用户进程所占的CPU时间百分比为0.8%</p></li><li><p><code>0.5 sy</code>：运行内核进程所占的CPU时间百分比为0.5%</p></li><li><p><code>0.0 ni</code>：运行已调整优先级的用户进程所占的CPU时间百分比为0</p></li><li><p><code>98.6 id</code>：CPU空闲时间的占比为98.6%</p></li><li><p><code>0.0 wa</code>：等待I/O完成的进程所占的CPU时间百分比为0</p></li><li><p><code>0.0 hi</code>：处理硬中断所占的CPU时间百分比为0</p></li><li><p><code>0.0 si</code>：处理软中断所占的CPU时间百分比为0</p></li><li><p>第四行为内存状态信息，单位为MB</p><ul><li><code>3936.2 total</code>：物理内存总量</li><li><code>2042.9 free</code>：空闲内存容量</li><li><code>935.2 used</code>：使用中的内存容量</li><li><code>958.1 buff/cache</code>：缓存容量</li></ul></li><li><p>第五行为交换分区状态信息，单位为MB</p><ul><li><code>2048.0 total</code>：交换分区总量</li><li><code>2048.0 free</code>：交换分区空闲的容量</li><li><code>0.0 used</code>：已使用的交换分区容量</li><li><code>2753.3 avail Mem</code>：用于缓冲的交换分区可用容量</li></ul></li></ul><p>各进程的状态监控信息如下：</p><p><code>PR</code>：进程的调度优先级</p><p><code>NI</code>：进程的静态优先级，越小的值意味着越高的优先级</p><p><code>VIRT</code>：进程使用的虚拟内存大小，单位为KB</p><p><code>RES</code>：进程使用的物理内存大小，单位为KB</p><p><code>SHR</code>：共享内存的大小，单位为KB</p><p><code>S</code>：进程状态，<code>D</code>=不可中断的睡眠态、<code>R</code>=运行态、<code>S</code>=睡眠态、<code>T</code>=被跟踪/已停止、<code>Z</code>=僵尸态</p><p><code>%CPU</code>：自上一次更新时到现在进程使用CPU时间的占比</p><p><code>%MEM</code>：进程占用的物理内存的百分比</p><p><code>TIME+</code>：进程启动后到现在所使用CPU的时间总计，精确到0.01秒</p><p><code>COMMAND</code>：运行进程所使用的命令</p><h3 id="设置信息更新次数"><a href="#设置信息更新次数" class="headerlink" title="设置信息更新次数"></a>设置信息更新次数</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">top -n <span class="number">3</span></span><br></pre></td></tr></table></figure><p>状态信息更新三次后，停止更新并退出top</p><h3 id="设置信息更新周期"><a href="#设置信息更新周期" class="headerlink" title="设置信息更新周期"></a>设置信息更新周期</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">top -d <span class="number">1</span></span><br></pre></td></tr></table></figure><p>状态信息更新周期为1秒</p><h3 id="显示指定的进程的信息"><a href="#显示指定的进程的信息" class="headerlink" title="显示指定的进程的信息"></a>显示指定的进程的信息</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">top -p <span class="number">1333</span></span><br></pre></td></tr></table></figure><p><img src="/images/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/1333.png" alt></p><p>显示进程号为1333的进程的信息</p><h2 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h2><h3 id="手动刷新信息"><a href="#手动刷新信息" class="headerlink" title="手动刷新信息"></a>手动刷新信息</h3><p>top命令刷新的周期默认为3秒，可以通过 <code>回车键</code> 或 <code>空格键</code> 手动刷新</p><h3 id="切换交替显示模式"><a href="#切换交替显示模式" class="headerlink" title="切换交替显示模式"></a>切换交替显示模式</h3><p>输入 <code>A</code> 可在全屏和交替模式间切换，在交替模式下会分别关注不同的字段</p><ol><li><p>Def（默认字段组）</p></li><li><p>Job（任务字段组）</p></li><li><p>Mem（内存字段组）</p></li><li><p>Usr（用户字段组）</p><p>4个窗口当中只有一个窗口是当前窗口，当前窗口的名称显示在左上方，只有当前窗口才会接受交互命令，可用 <code>a</code> 和 <code>w</code> 在4个窗口之间切换，也可用 <code>g</code> 和 <code>1~4当中的任一数字</code> 来切换窗口</p><p><img src="/images/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/A.png" alt></p></li></ol><h3 id="触发粗体显示"><a href="#触发粗体显示" class="headerlink" title="触发粗体显示"></a>触发粗体显示</h3><p>输入 <code>B</code> 可使一些重要信息以加粗字体显示</p><h3 id="设置刷新周期"><a href="#设置刷新周期" class="headerlink" title="设置刷新周期"></a>设置刷新周期</h3><p>输入 <code>d</code> 或 <code>s</code> 时，将被提示输入一个值，它会以输入的值作为信息的刷新周期，单位为秒</p><h3 id="反向排序"><a href="#反向排序" class="headerlink" title="反向排序"></a>反向排序</h3><p>输入 <code>R</code> </p><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>输入 <code>i</code> 切换显示空闲任务</p><h3 id="改变配色"><a href="#改变配色" class="headerlink" title="改变配色"></a>改变配色</h3><p>输入 <code>Z</code> ，根据提示可改变信息显示的颜色</p><p><img src="/images/top%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E9%80%89%E6%8B%A9%E9%A2%9C%E8%89%B2.png" alt></p><h3 id="最大显示进程数量"><a href="#最大显示进程数量" class="headerlink" title="最大显示进程数量"></a>最大显示进程数量</h3><p>输入 <code>n</code> 或 <code>#</code> ，再输入最大显示进程数量的值，即可按该值来最大显示进程数量</p><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>输入 <code>k</code> ，再输入进程号，可结束相应的进程</p><h3 id="退出top"><a href="#退出top" class="headerlink" title="退出top"></a>退出top</h3><p>输入 <code>q</code> </p><hr><p>第一次接触Linux性能监控相关的命令，对Linux的运行机制还不熟悉ρ(・ω・、)，如有错误，还请大佬在评论区留言，非常感谢ヽ(・×・´)ゞ。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>df，du命令笔记</title>
      <link href="/2020/06/04/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/04/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>df命令的功能是用来查看Linux的文件系统的磁盘空间占用情况，du命令则是对Linux的文件和目录的磁盘空间占用情况的查看。</p><a id="more"></a><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>命令功能： </p><p>df命令可显示当前被挂载的文件系统对磁盘空间的使用情况</p><p>命令使用： </p><p><code>df [选项] [文件]</code></p><h3 id="命令常用选项"><a href="#命令常用选项" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><p><code>-a</code>        显示所有文件系统的磁盘使用情况</p><p><code>-h</code>        以KB、MB、GB等方便阅读的单位显示，以<code>1024</code>为换算单位</p><p><code>-H</code>        以KB、MB、GB等方便阅读的单位显示，但以<code>1000</code>为换算单位</p><p><code>-i</code>        显示索引节点的信息</p><p><code>-l</code>        只显示本地文件系统</p><p><code>-T</code>        显示文件系统的类型</p><p><code>-B &lt;区块大小&gt;</code>        指定区块大小的单位</p><p><code>-t &lt;文件系统类型&gt;</code>        只显示指定类型的文件系统的磁盘空间使用情况</p><p><code>-x &lt;文件系统类型&gt;</code>        不显示指定类型的文件系统的磁盘空间使用情况</p><h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><p>显示当前被挂载的文件系统对磁盘空间的使用情况</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/df.png" alt></p><ul><li>第一列表示文件系统对应的设备文件的路径名（一般是硬盘上的分区）</li><li>第二列表示分区包含的数据块（1024字节）的数目</li><li>第三列表示已用的数据块的数目</li><li>第四列表示可用的数据块的数目</li></ul><p>第三、四列数据块的数目之和不等于第二列的数据块的数目，这是因为<strong>Linux中默认每个分区都留有少量空间供系统管理员使用</strong>。</p><p>显示指定的文件系统对磁盘空间的使用情况</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">df <span class="regexp">/dev/</span>loop0</span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt></p><p>以KB、MB、GB等方便阅读的单位显示</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df -h</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/h.png" alt></p><p>指定区块大小的单位为MB</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">df -B <span class="number">1</span>M</span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/B.png" alt></p><p>显示文件系统的类型</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df -T</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/T.png" alt></p><p>只显示指定类型的文件系统的磁盘空间使用情况</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df -t squashfs</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt></p><h2 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h2><p>命令功能： </p><p>du命令用于查看Linux中的文件和目录对磁盘空间的使用情况</p><p>命令使用： </p><p><code>df [选项] [文件]</code></p><h3 id="命令常用选项-1"><a href="#命令常用选项-1" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><p><code>-a</code>        显示目录中各文件的大小</p><p><code>-b</code>        显示目录中各文件的大小时，以字节为单位</p><p><code>-c</code>        除了显示目录中各文件的大小，还显示该目录的总用量（总大小）</p><p><code>-k</code>        显示目录中各文件的大小时，以KB为单位</p><p><code>-m</code>        显示目录中各文件的大小时，以MB为单位</p><p><code>-s</code>        仅显示目录的总用量（总大小）</p><p><code>-h</code>        以合适的单位显示目录中各文件的大小，以<code>1024</code>为换算单位</p><p><code>-L &lt;符号链接&gt;</code>        显示选项中所指定符号链接的源文件大小</p><p><code>-S</code>        显示各目录的大小，但不包含其子目录的大小</p><p><code>--exclude=&lt;文件&gt;</code>        略过指定的文件</p><p><code>-D</code>        显示指定符号链接的源文件大小</p><p><code>-H</code>        以合适的单位显示目录中各文件的大小，但是以<code>1000</code>为换算单位</p><h3 id="命令示例-1"><a href="#命令示例-1" class="headerlink" title="命令示例"></a>命令示例</h3><p>显示文件root对磁盘空间的使用情况</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">du root</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/du.png" alt></p><p>仅显示目录root的总用量（总大小）</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">du -s root</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/-s.png" alt></p><p>显示root各目录的大小，但不包含其子目录的大小</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">du -S root</span></span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E4%BB%85%E6%98%BE%E7%A4%BA.png" alt></p><p>略过指定的文件snap</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">du <span class="attribute">--exclude</span>=snap root</span><br></pre></td></tr></table></figure><p><img src="/images/df%EF%BC%8Cdu%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E7%95%A5%E8%BF%87.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whereis，locate，find命令笔记</title>
      <link href="/2020/05/31/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/31/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>whereis命令和locate命令都是通过检索数据库来实现文件的查找，但find命令则是通过遍历磁盘来实现文件的查找，所以，whereis命令和locate命令的效率比find命令高，但是，由于该数据库一般不会及时更新（默认每天自动更新一次），因此，使用find命令的搜索结果比使用whereis命令和locate命令的有更好的实时性。</p><a id="more"></a><h2 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h2><p>whereis命令主要用来定位一个命令（该命令的可执行文件、源代码文件和帮助文件）的路径，只能用于程序名的搜索，而且只搜索可执行文件（选项 -b ）、源代码文件（选项 -s ）和帮助文件（选项 -m ）。一般文件的定位要用locate命令。</p><p>命令用法： <code>whereis [选项] [文件名]</code></p><h3 id="命令常用选项"><a href="#命令常用选项" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-b  定位可执行文件</span></span><br><span class="line"><span class="deletion">-s  定位源代码文件</span></span><br><span class="line"><span class="deletion">-m  定位帮助文件</span></span><br><span class="line"><span class="deletion">-u  搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其他文件</span></span><br><span class="line"><span class="deletion">-B&lt;目录&gt;  在指定的目录下搜索可执行文件</span></span><br><span class="line"><span class="deletion">-S&lt;目录&gt;  在指定的目录下搜索源代码文件</span></span><br><span class="line"><span class="deletion">-M&lt;目录&gt;  在指定的目录下搜索帮助文件</span></span><br><span class="line"><span class="deletion">-l  查看whereis命令的搜索路径</span></span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>搜索ls命令的路径        <code>whereis ls</code></p><p>搜索ls命令的可执行文件的路径        <code>whereis -b ls</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/ls%E5%91%BD%E4%BB%A4.png" alt></p><p>查看whereis命令搜索的目录        <code>whereis -l</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/whereis%E5%91%BD%E4%BB%A4%E6%90%9C%E7%B4%A2%E7%9A%84%E7%9B%AE%E5%BD%95.png" alt></p><h2 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h2><p>locate命令除了可以搜索命令的可执行文件、源代码文件和帮助文件外，还可以搜索一般文件。</p><p>命令用法： <code>locate [选项] [文件名包含的信息]</code></p><h3 id="命令常用选项-1"><a href="#命令常用选项-1" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-a  输出所有匹配模式的文件</span></span><br><span class="line"><span class="deletion">-d  指定资料库的路径</span></span><br><span class="line"><span class="deletion">-n  显示n个输出查找到的文件</span></span><br><span class="line"><span class="deletion">-h  显示辅助信息</span></span><br><span class="line"><span class="deletion">-q  安静模式，不会显示任何错误信息</span></span><br></pre></td></tr></table></figure><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>搜索文件名中含有字符 <code>CPU</code> 的文件并列出来        <code>locate CPU</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/CPU.png" alt></p><p>搜索文件名中含有字符 <code>CPU</code> 的文件，并只列出前5个        <code>locate -n 5 CPU</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/5CPU.png" alt></p><p>搜索 <code>etc</code> 目录下所有以 <code>sh</code> 开头的文件        <code>locate /etc/sh</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/locate.png" alt></p><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>如果有大量的文件保存在许多不同的目录中，搜索它们就要用到find命令，可以按照文件名、文件类型、文件权限甚至是最后更新的时间来搜索文件，find命令的功能比whereis命令和locate命令都要强大，但效率较低且会消耗较多的资源。</p><p>命令用法： <code>find [搜索路径] [查找规则]</code></p><h3 id="命令常用选项-2"><a href="#命令常用选项-2" class="headerlink" title="命令常用选项"></a>命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-type查找某一类型的文件</span></span><br><span class="line"><span class="deletion">-name按照文件名查找文件</span></span><br><span class="line"><span class="deletion">-group按照文件所属的组来查找文件</span></span><br><span class="line"><span class="deletion">-user按照文件所有者来查找文件</span></span><br><span class="line"><span class="deletion">-printfind命令将匹配到的文件输出到标准输出</span></span><br><span class="line"><span class="deletion">-link按照文件的链接数来查找文件</span></span><br><span class="line"><span class="deletion">-size n : [c]查找文件长度为n块的文件，带有c时表示文件长度以字节计</span></span><br><span class="line"><span class="deletion">-newer file1 ! file2查找更改时间比文件file1新，但比文件file2旧的文件</span></span><br><span class="line"><span class="deletion">-perm按照文件权限来查找文件</span></span><br><span class="line"><span class="deletion">-depth在查找文件时，首先查找当前目录中的文件，然后在其子目录中查找</span></span><br><span class="line"><span class="deletion">-prune不在指定的目录中查找，若同时使用-depth选项，-prune将被忽略</span></span><br><span class="line"><span class="deletion">-nogroup查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在</span></span><br><span class="line"><span class="deletion">-nouser查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在</span></span><br><span class="line"><span class="deletion">-iname不区分字母的大小写</span></span><br></pre></td></tr></table></figure><h4 id="type选项参数"><a href="#type选项参数" class="headerlink" title="-type选项参数"></a>-type选项参数</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">b</span><span class="string">块设备文件</span></span><br><span class="line"><span class="attr">d</span><span class="string">目录</span></span><br><span class="line"><span class="attr">c</span><span class="string">字符设备文件</span></span><br><span class="line"><span class="attr">p</span><span class="string">管道文件</span></span><br><span class="line"><span class="attr">l</span><span class="string">符号链接文件</span></span><br><span class="line"><span class="attr">f</span><span class="string">普通文件</span></span><br></pre></td></tr></table></figure><h4 id="时间特征参数"><a href="#时间特征参数" class="headerlink" title="时间特征参数"></a>时间特征参数</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">amin <span class="built_in">n</span>查找<span class="built_in">n</span>分钟以内被访问过的所有文件</span><br><span class="line">atime <span class="built_in">n</span>查找<span class="built_in">n</span>天以内被访问过的所有文件</span><br><span class="line">cmin <span class="built_in">n</span>查找<span class="built_in">n</span>分钟以内文件状态被修改过的所有文件</span><br><span class="line">ctime <span class="built_in">n</span>查找<span class="built_in">n</span>天以内文件状态被修改过的所有文件</span><br><span class="line">mmin <span class="built_in">n</span>查找<span class="built_in">n</span>分钟以内文件内容被修改过的所有文件</span><br><span class="line">mtime <span class="built_in">n</span>查找<span class="built_in">n</span>天以内文件内容被修改过的所有文件</span><br></pre></td></tr></table></figure><h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><ul><li><p>知道了某个文件的文件名，但不知道其路径        <code>find / -name initrd.img</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/initrd.png" alt>        </p></li><li><p>根据部分文件名查找，当仅记得某个文件名包含几个特定的字符时，这时在查找文件名时可用通配符 <code>*</code> 或 <code>?</code> </p><p><code>find / -name *CPU*</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/findCPU.png" alt></p></li><li><p>知道了某个文件的大小小于1KB</p><p><code>find /bin -size -1000c</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/1KB.png" alt></p></li><li><p>查找/etc下，所有以f开头后面有四个字符的文件</p><p><code>find /etc -name &#39;f????&#39;</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/f.png" alt></p></li><li><p>查找以字母E~G（不区分大小写）开头的文件</p><p><code>find /bin -iname &quot;[E-G]*&quot;</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99.png" alt></p></li><li><p>根据文件权限查找文件，查找文件权限为777的文件</p><p><code>find /bin -perm 777</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/777.png" alt></p></li><li><p>根据时间查找文件，查找更改时间在5天内的文件</p><p><code>find /root -mtime -5</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/5%E5%A4%A9.png" alt></p></li><li><p>根据文件类型查找文件，查找目标目录下所有的目录文件</p><p><code>find /etc -type d</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6.png" alt></p></li><li><p>查找文件大小大于1MB的文件</p><p><code>find /bin -size +1000000c</code></p><p><img src="/images/whereis%EF%BC%8Clocate%EF%BC%8Cfind%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/1MB.png" alt></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tar，gzip，unzip命令笔记</title>
      <link href="/2020/05/26/tar%EF%BC%8Cgzip%EF%BC%8Cunzip%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/26/tar%EF%BC%8Cgzip%EF%BC%8Cunzip%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>新的一周，继续整理(´・ω・`)。</p><a id="more"></a><p>tar和gzip是Linux中常用的文件打包、压缩和解压命令。</p><hr><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>tar是Linux中最常用的打包程序。打包和压缩是两个不同的概念，打包是将若干个文件（包括目录）合并成一个文件；压缩是把一个文件通过压缩算法在不改变文件属性的前提下尽可能减少文件的字节数量和降低文件的占用空间。<strong>tar本身并不具有压缩功能，但它可以调用其他程序的压缩功能实现对文件的压缩。</strong></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件或目录]</span></span><br></pre></td></tr></table></figure><h3 id="tar命令常用选项"><a href="#tar命令常用选项" class="headerlink" title="tar命令常用选项"></a>tar命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-c  创建一个新的压缩文件</span></span><br><span class="line"><span class="deletion">-x  解压文件</span></span><br><span class="line"><span class="deletion">-z  使用gzip来压缩或解压文件，配合-c是压缩，配合-x是解压</span></span><br><span class="line"><span class="deletion">-f  指定压缩后的文件名</span></span><br><span class="line"><span class="deletion">-u  仅转换比压缩文件新的内容</span></span><br><span class="line"><span class="deletion">-v  显示操作过程</span></span><br><span class="line"><span class="deletion">-t  列出压缩文件的内容</span></span><br></pre></td></tr></table></figure><p>将文件practice0、practice1打包后压缩为.tar文件，并命名为PRACTICE</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">tar -<span class="built_in">cf</span> PRACTICE practice0 practice1</span><br></pre></td></tr></table></figure><p>将文件PRACTICE解压</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar -xf PRACTICE</span></span><br></pre></td></tr></table></figure><p>将文件practice0、practice1打包后压缩为.tar.gz文件，并命名为PRACTICE</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -czf PRACTICE practice0 practice1</span><br></pre></td></tr></table></figure><p>列出压缩文件PRACTICE中的内容</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar -tf PRACTICE</span></span><br></pre></td></tr></table></figure><p>解压.tar或.tar.gz内的部分文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xf</span> <span class="selector-attr">[压缩包]</span> <span class="selector-attr">[压缩包内需要解压的文件]</span></span><br></pre></td></tr></table></figure><h2 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h2><p>gzip是类Unix操作系统上的一种文件压缩和解压的程序，经gzip压缩后的文件格式为.gz，<strong>只压缩不打包</strong>。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gzip</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h3 id="gzip命令常用选项"><a href="#gzip命令常用选项" class="headerlink" title="gzip命令常用选项"></a>gzip命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-d  对.gz进行解压</span></span><br><span class="line"><span class="deletion">-f  强制压缩文件</span></span><br><span class="line"><span class="deletion">-l  列出压缩文件的相关信息</span></span><br><span class="line"><span class="deletion">-r  将指定目录下的所有文件及子目录一并处理</span></span><br><span class="line"><span class="deletion">-num  用数字num表示压缩比，1表示最低压缩比（但压缩速度最快）；9表示最高压缩比（但压缩速度最慢）；系统默认值为6</span></span><br><span class="line"><span class="deletion">-v  在处理过程中列出详细信息</span></span><br></pre></td></tr></table></figure><p>将当前目录下的每一个文件压缩成.gz（但对文件夹不进行处理）</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gzip</span> *</span><br></pre></td></tr></table></figure><p>用gzip程序对压缩文件practice.gz进行解压，并列出详细信息</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gzip</span> <span class="selector-tag">-dv</span> <span class="selector-tag">practice</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>列出压缩文件practice.gz的相关信息</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gzip</span> <span class="selector-tag">-l</span> <span class="selector-tag">practice</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>以最高压缩比对文件practice进行压缩</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gzip <span class="number">-9</span> practice</span><br></pre></td></tr></table></figure><p>对目录practice下的所有文件及子目录进行压缩</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gzip -r practice</span></span><br></pre></td></tr></table></figure><h2 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h2><p>unzip程序可用于解压.zip文件。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h3 id="unzip命令常用选项"><a href="#unzip命令常用选项" class="headerlink" title="unzip命令常用选项"></a>unzip命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-f更新现有的文件</span></span><br><span class="line"><span class="deletion">-l列出.zip文件内包含的文件</span></span><br><span class="line"><span class="deletion">-t检查.zip文件是否损坏</span></span><br><span class="line"><span class="deletion">-n解压时不要覆盖原有的文件</span></span><br><span class="line">&lt;.zip文件中的文件名&gt;指定处理.zip文件中的部分文件</span><br><span class="line"><span class="deletion">-d &lt;目录&gt;指定文件解压后存储的路径</span></span><br><span class="line"><span class="deletion">-x &lt;文件名&gt;指定不处理.zip文件中的部分文件</span></span><br></pre></td></tr></table></figure><hr><p>文章内容如有错误，请在评论区留言指正，非常感谢(^u^)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>touch，rm，mkdir，rmdir，cp，mv命令笔记</title>
      <link href="/2020/05/21/touch%EF%BC%8Crm%EF%BC%8Cmkdir%EF%BC%8Crmdir%EF%BC%8Ccp%EF%BC%8Cmv%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/21/touch%EF%BC%8Crm%EF%BC%8Cmkdir%EF%BC%8Crmdir%EF%BC%8Ccp%EF%BC%8Cmv%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>新的一天，继续整理学到的Linux命令ε٩(๑&gt; ₃ &lt;)۶з。</p><a id="more"></a><hr><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a><strong>touch命令</strong></h2><p>touch命令一般用来修改文件时间，或者创建新文件</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">touch practice           <span class="comment">//创建新文件practice</span></span><br></pre></td></tr></table></figure><p>若当前目录下已存在同名文件，则把该文件的时间（最近访问、最近更改、最近改动）修改为当前的系统时间</p><p>在某些情况下，如果新文件不存在，需要避免创建新文件，则可以使用<code>-c</code>选项</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch</span> -c<span class="meta"> [文件名]</span></span><br></pre></td></tr></table></figure><p>touch命令可同时创建多个文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touch</span> <span class="selector-attr">[A文件名]</span> <span class="selector-attr">[B文件名]</span> <span class="selector-attr">[C文件名]</span></span><br></pre></td></tr></table></figure><p>touch命令还可用于仅修改文件的<code>最近访问</code>时间和<code>最近更改</code>时间为当前的系统时间</p><ul><li><p>仅修改<code>最近访问</code>时间</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch</span> -a<span class="meta"> [文件名]</span></span><br></pre></td></tr></table></figure></li><li><p>仅修改<code>最近更改</code>时间</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch</span> -m<span class="meta"> [文件名]</span></span><br></pre></td></tr></table></figure></li></ul><p>还可以使用如下命令把一个文件的<code>最近访问</code>和<code>最近更改</code>时间修改为另一个文件的<code>最近访问</code>和<code>最近更改</code>时间</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">touch -r practice0 practice1     <span class="comment">//把practice1的“最近访问”和“最近更改”修改为practice0的</span></span><br></pre></td></tr></table></figure><p>touch命令还可通过选项<code>-t</code>使用自定义的时间创建或修改文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touch</span> <span class="selector-tag">-t</span> <span class="selector-tag">YYMMDDHHMM</span><span class="selector-class">.SS</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><p><code>YYMMDDHHMM.SS</code>为时间格式，例如： </p><p>2020年5月15日22时45分6秒则表示为<code>2005152245.06</code></p><p><code>-t</code>可以搭配<code>-a</code>和<code>-m</code>选项使用</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touch</span> <span class="selector-tag">-amt</span> <span class="selector-tag">YYMMDDHHMM</span><span class="selector-class">.SS</span> <span class="selector-attr">[文件名]</span>  <span class="comment">//将文件的“最近访问”和“最近更改”时间修改为指定时间</span></span><br></pre></td></tr></table></figure><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>在默认情况下，rm命令只能删除指定的文件而不能删除目录，如果要删除目录，必须使用选项<code>-r</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">rm</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件或目录]</span></span><br></pre></td></tr></table></figure><h3 id="rm命令常用选项"><a href="#rm命令常用选项" class="headerlink" title="rm命令常用选项"></a>rm命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-f  强制删除</span></span><br><span class="line"><span class="deletion">-i  在删除前需要确认</span></span><br><span class="line"><span class="deletion">-I  在删除超过3个文件时或在递归删除前需要确认</span></span><br><span class="line"><span class="deletion">-r  递归删除目录及其内容</span></span><br></pre></td></tr></table></figure><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mkdir</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[目录名]</span><span class="comment">//创建新目录</span></span><br></pre></td></tr></table></figure><ul><li><p>mkdir命令选项<code>-p</code></p><p>依次创建目录，需要时创建目标目录的上级目录</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p practice/practice0  <span class="comment">//创建目录practice及其子目录practice0</span></span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p practice/&#123;practice0,practice1&#125;  <span class="comment">//创建目录practice及其子目录practice0和practice1</span></span><br></pre></td></tr></table></figure></li><li><p>mkdir命令选项<code>-v</code></p><p>每次创建新目录都显示执行过程信息</p></li><li><p>mkdir命令选项<code>-m</code></p><p>在创建新目录的同时对其设置权限</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mkdir</span> <span class="selector-tag">-m</span> <span class="selector-attr">[参数]</span> <span class="selector-attr">[目录名]</span></span><br></pre></td></tr></table></figure><p>参数由<strong>三位数字</strong>组成，分别代表<strong>目录所有者的权限、组中其他人对目录的权限和系统中其他人对目录的权限</strong>，对目录的<strong>读权限是4、写权限是2、执行权限是1</strong>，<strong>三个数字的和</strong>表达了对该目录的权限。</p></li></ul><h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">rmdir</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[目录名]</span><span class="comment">//删除空目录</span></span><br></pre></td></tr></table></figure><ul><li><p>rmdir命令选项<code>-p</code></p><p>当子目录被删除后其父目录为空目录时，也一同被删除</p></li><li><p>rmdir命令选项<code>-v</code></p><p>每次删除目录都显示执行过程信息</p></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>把一个或多个文件复制到另一个目录或把一个文件的内容复制到另一个文件中（相当于输出重定向）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cp</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[源文件]</span> <span class="selector-attr">[目标目录]</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cp</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[源文件0]</span> <span class="selector-attr">[源文件1]</span> <span class="selector-attr">[源文件2]</span> <span class="selector-attr">[目标目录]</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cp</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[源文件]</span> <span class="selector-attr">[目标文件]</span></span><br></pre></td></tr></table></figure><p>把多个源文件复制到目标目录时，若目标目录不存在，则会报错。</p><h3 id="cp命令常用选项"><a href="#cp命令常用选项" class="headerlink" title="cp命令常用选项"></a>cp命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-i  覆盖前询问是否覆盖已存在的文件</span></span><br><span class="line"><span class="deletion">-R  复制所有文件及目录  //例如：cp -R [源目录] [源文件0] [源文件1] [目标目录]</span></span><br><span class="line"><span class="deletion">-n  不要覆盖已存在的文件</span></span><br><span class="line"><span class="deletion">-u  只在源文件比目标文件新或目标文件不存在时才进行复制</span></span><br></pre></td></tr></table></figure><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>将当前目录下的文件或子目录移入另一个目录；或者，对文件或目录重命名。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mv</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[源文件或目录]</span> <span class="selector-attr">[目标文件或目录]</span></span><br></pre></td></tr></table></figure><h3 id="mv命令常用选项"><a href="#mv命令常用选项" class="headerlink" title="mv命令常用选项"></a>mv命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-i  若目标文件已存在时，将会询问是否覆盖</span></span><br><span class="line"><span class="deletion">-n  不要覆盖已存在的文件</span></span><br><span class="line"><span class="deletion">-u  只在源文件比目标文件新或目标文件不存在时才进行移动</span></span><br><span class="line"><span class="deletion">-b  覆盖文件前先进行备份</span></span><br><span class="line"><span class="deletion">-f  强制覆盖已存在的目标文件</span></span><br></pre></td></tr></table></figure><p>可同时将多个源文件或源目录移入到另一个目录中，但不能同时对多个源文件或源目录重命名。</p><hr><p>如有错误，请在评论区留言，我会及时修正(`3´)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat，more，less，head和tail命令笔记</title>
      <link href="/2020/05/20/cat%EF%BC%8Cmore%EF%BC%8Cless%EF%BC%8Chead%E5%92%8Ctail%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/20/cat%EF%BC%8Cmore%EF%BC%8Cless%EF%BC%8Chead%E5%92%8Ctail%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文记录了我目前（2020/5/20）接触到的一些自己觉得比较常用的cat、more、less、head和tail命令，我还只是一个Linux命令初学者，希望大佬勿喷，若有建议请在评论区留言，非常感谢你的提议(*´∀`)~♥。</p><a id="more"></a><hr><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>cat命令可用于查看文件内容，以及将文件内容或输入内容重定向到其它文件。</p><h3 id="用cat命令查看文件内容"><a href="#用cat命令查看文件内容" class="headerlink" title="用cat命令查看文件内容"></a>用cat命令查看文件内容</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h4 id="cat命令常用选项"><a href="#cat命令常用选项" class="headerlink" title="cat命令常用选项"></a>cat命令常用选项</h4><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">n  由<span class="number">1</span>开始对所有输出的行数编号</span></span><br><span class="line"><span class="ruby">-b  和 -n 相似，但对于空白行不编号</span></span><br><span class="line"><span class="ruby">-s  当遇到有连续两行的空白行，就替换为一行的空白行</span></span><br><span class="line"><span class="ruby">-E  在每行结束处显示 $ 字符</span></span><br></pre></td></tr></table></figure><h3 id="把cat命令用于输出重定向和追加重定向"><a href="#把cat命令用于输出重定向和追加重定向" class="headerlink" title="把cat命令用于输出重定向和追加重定向"></a>把cat命令用于输出重定向和追加重定向</h3><ul><li>输出重定向和追加重定向分别用<code>&gt;</code>和<code>&gt;&gt;</code>来表示，若重定向的目标文件不存在，则新建一个文件</li><li><strong>输出重定向与追加重定向的区别</strong><ul><li><strong>输出重定向把目标文件的内容全部覆盖</strong></li><li><strong>追加重定向则把需要追加的内容放到目标文件内容的尾部</strong></li></ul></li></ul><p>将文件practice0的内容输出重定向到文件practice1</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> practice0 &gt; practice1</span><br></pre></td></tr></table></figure><p>将文件practice0和practice1的内容合并输出重定向到文件practice2</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> practice0 practice1 &gt; practice2</span><br></pre></td></tr></table></figure><p>将输入的内容输出重定向到文件practice</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> &gt; practice<span class="comment">//Ctrl + D退出编辑</span></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">cat &gt; practice &lt;&lt; <span class="built_in">EOF</span></span><br><span class="line">&gt; <span class="comment">//输入的内容</span></span><br><span class="line">&gt; <span class="built_in">EOF</span><span class="comment">//退出编辑</span></span><br></pre></td></tr></table></figure><p>将文件practice0的内容追加重定向到文件practice1</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> practice0 &gt;&gt; practice1</span><br></pre></td></tr></table></figure><p>将文件practice0和practice1的内容合并追加重定向到文件practice2</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> practice0 practice1 &gt;&gt; practice2</span><br></pre></td></tr></table></figure><p>将输入的内容追加重定向到文件practice</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> &gt;&gt; practice <span class="comment">//Ctrl + D退出编辑</span></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; practice &lt;&lt; <span class="built_in">EOF</span></span><br><span class="line">&gt; <span class="comment">//输入内容</span></span><br><span class="line">&gt; <span class="built_in">EOF</span><span class="comment">//退出编辑</span></span><br></pre></td></tr></table></figure><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>more命令用于分页显示文件的内容，有利于阅读；另外，more命令在启用时就加载整个文件。</p><h3 id="more命令用法"><a href="#more命令用法" class="headerlink" title="more命令用法"></a>more命令用法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">more</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h3 id="more命令常用选项"><a href="#more命令常用选项" class="headerlink" title="more命令常用选项"></a>more命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+n  从第n行开始显示</span></span><br><span class="line"><span class="deletion">-n  定义屏幕大小为n行</span></span><br><span class="line"><span class="deletion">-c  从顶部清屏，然后显示</span></span><br><span class="line"><span class="deletion">-d  提示“按空格键继续，“q”键退出。”</span></span><br><span class="line"><span class="deletion">-p  通过清除窗口而不是滚屏来对文件进行换页</span></span><br><span class="line"><span class="deletion">-s  把连续的多个空白行显示为一个空白行</span></span><br></pre></td></tr></table></figure><p>当使用more命令显示文件内容时，<code>Enter</code>键向下滚动一行，<code>Ctrl+F</code>组合键或<code>空格</code>键向下滚动一屏，<code>Ctrl+B</code>组合键返回上一屏，<code>=</code>键输出当前行的行号，<code>:F</code>组合键输出当前的文件名和当前行的行号，<code>Q</code>键退出more命令。</p><h2 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h2><p>使用less命令可以随意地向下或向上浏览文件内容，总的来说，less命令比more命令要用得舒服；另外，less命令在查看前不会加载整个文件。</p><h3 id="less命令用法"><a href="#less命令用法" class="headerlink" title="less命令用法"></a>less命令用法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">less</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h3 id="less命令常用选项"><a href="#less命令常用选项" class="headerlink" title="less命令常用选项"></a>less命令常用选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-f  强制打开例如外围设备代号、二进制文件等特殊文件</span></span><br><span class="line"><span class="deletion">-m  显示浏览进度的百分比</span></span><br><span class="line"><span class="deletion">-N  显示每行的行号</span></span><br><span class="line"><span class="deletion">-s  把连续多个空白行显示为一个空白行</span></span><br><span class="line"><span class="deletion">-i  搜索时不区分字母字符的大小写</span></span><br></pre></td></tr></table></figure><p>当使用less命令显示文件内容时，<code>pagedown</code>键或<code>Enter</code>键向下滚动一行，<code>pageup</code>键或<code>Y</code>键向上滚动一行，<code>/xxx</code>向上搜索字符串<code>xxx</code>，<code>?xxx</code>向下搜索字符串<code>xxx</code>，<code>Q</code>键退出less命令。</p><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>head命令用于显示文件内容开头的某个数量的区块。</p><h3 id="head命令用法"><a href="#head命令用法" class="headerlink" title="head命令用法"></a>head命令用法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">head</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件名]</span></span><br></pre></td></tr></table></figure><h3 id="head命令常用选项"><a href="#head命令常用选项" class="headerlink" title="head命令常用选项"></a>head命令常用选项</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">-n <span class="built_in">num</span>    显示前<span class="built_in">num</span>行；若<span class="built_in">num</span>为负数，则显示除最后<span class="built_in">num</span>行以外的内容</span><br><span class="line">-c <span class="built_in">num</span>    显示前<span class="built_in">num</span>个字节数；若<span class="built_in">num</span>为负数，则显示除最后<span class="built_in">num</span>个字节数以外的内容</span><br><span class="line">-v        显示文件名</span><br></pre></td></tr></table></figure><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><h3 id="tail命令用法"><a href="#tail命令用法" class="headerlink" title="tail命令用法"></a>tail命令用法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">tail -n <span class="built_in">num</span> [文件名]  显示文件最后<span class="built_in">num</span>行的内容</span><br><span class="line">tail -n +<span class="built_in">num</span> [文件名]  从文件内容的第<span class="built_in">num</span>行开始显示</span><br></pre></td></tr></table></figure><hr><p>如有错误，请在评论区留言，我会及时修正d(d＇∀＇)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针笔记</title>
      <link href="/2020/05/19/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/19/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>我挑了一些自己在学习C语言指针时觉得需要整理的细化知识点，将它们整理成以下的笔记。因为完全是自学的<del>别问我上C语言课程的时候在干什么，反正不是在偷懒&lt;(ˉ^ˉ)&gt;</del>，所以主要通过琢磨例题和实践编写来掌握和巩固细化的知识点(<em>/ω＼</em>)。</p><hr><h2 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a><strong>指针变量作为函数参数</strong></h2><p>例题：</p><p>输入两个不相等的整数，把这两个整数按照先大后小的顺序输出。用函数处理，而且用指针类型的数据作函数参数。</p><a id="more"></a><p>程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *X1,<span class="keyword">int</span> *Y1)</span></span>;  <span class="comment">//对swap函数进行声明 </span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入两个不相等的整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">int</span> *X2,*Y2;</span><br><span class="line">X2=&amp;x;</span><br><span class="line">Y2=&amp;y;</span><br><span class="line"><span class="keyword">if</span>(x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">swap(X2,Y2);  <span class="comment">//调用swap函数 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max=%d\nmin=%d\n"</span>,*X2,*Y2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *X1,<span class="keyword">int</span> *Y1)</span>  <span class="comment">//对swap函数进行定义 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp=*X1;</span><br><span class="line">*X1=*Y1;</span><br><span class="line">*Y1=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入两个不相等的整数：<span class="number">56</span> <span class="number">89</span></span><br><span class="line">max=<span class="number">89</span></span><br><span class="line">min=<span class="number">56</span></span><br></pre></td></tr></table></figure><p>在对swap函数进行定义的过程中，不能将temp定义为指针变量，即不能如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> swap(<span class="type">int</span> *X1,<span class="type">int</span> *Y1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *<span class="keyword">temp</span>;</span><br><span class="line">*<span class="keyword">temp</span>=*X1;</span><br><span class="line">*X1=*Y1;</span><br><span class="line">*Y1=*<span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为未给temp赋值，所以指针变量temp所指向的单元是不可预见的。</p><hr><h2 id="通过指针引用数组元素"><a href="#通过指针引用数组元素" class="headerlink" title="通过指针引用数组元素"></a><strong>通过指针引用数组元素</strong></h2><ul><li><p>在C语言中，数组名不代表整个数组，只代表该数组首元素的地址。</p></li><li><p>在<strong>指针已指向一个数组元素时</strong>，可以对指针进行以下运算：</p><ul><li>加一个整数（用+或+=），如p+1；</li><li>减一个整数（用-或-=），如p-1；</li><li>自加运算，如p++，++p；</li><li>自减运算，如p–，–p。</li><li>两个指针相减，如p1-p2（只有p1和p2都指向同一数组中的元素时才有意义）。</li></ul></li><li><p>两个指针不能相加，如p1+p2是无实际意义的。</p></li></ul><p>例题：</p><p>通过指针变量输出整型数组a的10个元素。</p><p>程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *x,i,a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入10个整数："</span>);</span><br><span class="line">x=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,x++);</span><br><span class="line">&#125;</span><br><span class="line">x=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,*(x++));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入<span class="number">10</span>个整数： <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span>       <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span></span><br></pre></td></tr></table></figure><hr><h2 id="用数组名作函数参数"><a href="#用数组名作函数参数" class="headerlink" title="用数组名作函数参数"></a><strong>用数组名作函数参数</strong></h2><ul><li><p>实参数组名代表该数组首元素的地址，而形参是用来接收从实参传递过来的数组首元素的地址。因此，形参是一个指针变量。实际上，C编译都是将形参数组名作为指针变量来处理的。</p></li><li><p>C语言调用函数时虚实结合的方法都是采用”值传递“方式，当用变量名作为函数参数时传递的是变量的值，当用数组名作为函数参数时传递的是地址。</p></li><li><p>实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。</p></li><li><p>在函数调用进行虚实结合后，形参的值就是实参数组首元素的地址。在函数执行期间，它可以再被赋值。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(arr[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*arr);</span><br><span class="line">arr+=<span class="number">3</span>;  <span class="comment">//形参数组名可以被赋值 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例题：</p><p>将一个数组中的所有元素按相反顺序排列。</p><p>程序：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">void</span> inv(<span class="built_in">int</span> p[],<span class="built_in">int</span> x);</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>&#125;;</span><br><span class="line">printf(<span class="string">"The original array:\n"</span>);</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%d\t"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">inv(a,<span class="number">10</span>);</span><br><span class="line">printf(<span class="string">"The array has been inverted:\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%d\t"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> inv(<span class="built_in">int</span> p[],<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> y;</span><br><span class="line"><span class="built_in">int</span> z=(x<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=z;y++)</span><br><span class="line">&#123;</span><br><span class="line">n=x<span class="number">-1</span>-y;</span><br><span class="line">temp=p[y];</span><br><span class="line">p[y]=p[n];</span><br><span class="line">p[n]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">The original <span class="built_in">array</span>:</span><br><span class="line"><span class="number">3</span>       <span class="number">7</span>       <span class="number">9</span>       <span class="number">11</span>      <span class="number">5</span>       <span class="number">21</span>      <span class="number">2</span>       <span class="number">1</span>       <span class="number">8</span>       <span class="number">4</span></span><br><span class="line">The <span class="built_in">array</span> has been inverted:</span><br><span class="line"><span class="number">4</span>       <span class="number">8</span>       <span class="number">1</span>       <span class="number">2</span>       <span class="number">21</span>      <span class="number">5</span>       <span class="number">11</span>      <span class="number">9</span>       <span class="number">7</span>       <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h2 id="指向二维数组元素的指针变量"><a href="#指向二维数组元素的指针变量" class="headerlink" title="指向二维数组元素的指针变量"></a><strong>指向二维数组元素的指针变量</strong></h2><ul><li><strong>在内存中，二维数组的分布是一维线性的</strong></li></ul><p>例题：</p><p>有一个3×4的二维数组，要求用指向元素的指针变量输出二维数组各元素的值。</p><p>程序：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p=a[<span class="number">0</span>];p&lt;a[<span class="number">0</span>]+<span class="number">12</span>;p++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((p-a[<span class="number">0</span>])%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d\t"</span>,*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">1 </span>      <span class="number">3</span>       <span class="number">5</span>       <span class="number">7</span></span><br><span class="line"><span class="symbol">9 </span>      <span class="number">11</span>      <span class="number">13</span>      <span class="number">15</span></span><br><span class="line"><span class="symbol">17 </span>     <span class="number">19</span>      <span class="number">21</span>      <span class="number">23</span></span><br></pre></td></tr></table></figure><hr><h2 id="指向由多个元素组成的一维数组的指针变量"><a href="#指向由多个元素组成的一维数组的指针变量" class="headerlink" title="指向由多个元素组成的一维数组的指针变量"></a><strong>指向由多个元素组成的一维数组的指针变量</strong></h2><p>例题：</p><p>输出二维数组任一行任一列元素的值。</p><p>程序：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>],i,j;  <span class="comment">//指针变量p指向包含4个整型元素的一维数组 </span></span><br><span class="line">printf(<span class="string">"输入行和列："</span>);</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line">p=a;</span><br><span class="line">printf(<span class="string">"a[%d,%d]=%d"</span>,i,j,*(*(p+i)+j));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入行和列：<span class="number">2</span> <span class="number">1</span></span><br><span class="line">a[<span class="number">2</span>,<span class="number">1</span>]=<span class="number">19</span></span><br></pre></td></tr></table></figure><p>从int (*p)[4]可以看出，p只能指向一个包含4个元素的一维数组，不能指向一维数组中的某一元素，p的值是该一维数组的起始地址。</p><hr><h2 id="通过指针引用字符串"><a href="#通过指针引用字符串" class="headerlink" title="通过指针引用字符串"></a><strong>通过指针引用字符串</strong></h2><ul><li>C语言对字符串常量是按字符数组处理的，在内存中开辟一个字符数组用来存放该字符串常量，但是这个字符数组使没有名字的，因此不能通过数组名来引用，只能通过指针变量来引用。</li><li><strong>在内存中，字符串的最后被自动加了’\0’。</strong></li></ul><p>例题：</p><p>将字符串a复制为字符串b，然后输出字符串b，用指针变量来处理。</p><p>程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"https://www.nimitiz.cn"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;*(a+i)!=<span class="string">'\0'</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">*(b+i)=*(a+i);</span><br><span class="line">&#125;</span><br><span class="line">*(b+i)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;b[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//www.nimitiz.cn</span></span><br></pre></td></tr></table></figure><hr><h2 id="字符指针作函数参数"><a href="#字符指针作函数参数" class="headerlink" title="字符指针作函数参数"></a><strong>字符指针作函数参数</strong></h2><p>例题：</p><p>用函数调用实现字符串的复制。</p><p>程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_string</span><span class="params">(<span class="keyword">char</span> from[],<span class="keyword">char</span> to[])</span></span>;</span><br><span class="line"><span class="keyword">char</span> a[]=<span class="string">"Linux"</span>;</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">"Unix"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"string a=%s\nstring b=%s\n"</span>,a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ncopy string a to string b:\n"</span>);</span><br><span class="line"><span class="keyword">char</span> *A=a;</span><br><span class="line"><span class="keyword">char</span> *B=b;</span><br><span class="line">copy_string(A,B);  <span class="comment">//实参为字符指针变量 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"string a=%s\nstring b=%s\n"</span>,a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_string</span><span class="params">(<span class="keyword">char</span> from[],<span class="keyword">char</span> to[])</span>  <span class="comment">//形参为字符数组 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(from[i]!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">to[i]=from[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">to[i]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="keyword">a</span>=Linux</span><br><span class="line"><span class="keyword">string</span> b=Unix</span><br><span class="line"></span><br><span class="line">copy <span class="keyword">string</span> <span class="keyword">a</span> <span class="built_in">to</span> <span class="keyword">string</span> b:</span><br><span class="line"><span class="keyword">string</span> <span class="keyword">a</span>=Linux</span><br><span class="line"><span class="keyword">string</span> b=Linux</span><br></pre></td></tr></table></figure><hr><h2 id="使用字符指针变量和字符数组的比较"><a href="#使用字符指针变量和字符数组的比较" class="headerlink" title="使用字符指针变量和字符数组的比较"></a><strong>使用字符指针变量和字符数组的比较</strong></h2><ul><li>字符数组由若干个元素组成，每个元素中存放一个字符，而字符指针变量中存放的是<strong>字符串第1个字符的地址</strong>。</li><li><strong>可以对字符指针变量赋值，但不能对数组名赋值。</strong></li><li>编译时为字符数组分配若干个存储单元以存放各元素的值，而对字符指针变量只分配一个存储单元。</li><li><strong>指针变量的值可以改变，而字符数组名代表数组首元素的地址，不能改变。</strong></li><li><strong>可以对字符数组中各元素再赋值，但不能对字符指针变量指向的字符串常量再赋值。</strong></li></ul><hr><h2 id="用函数指针变量调用函数"><a href="#用函数指针变量调用函数" class="headerlink" title="用函数指针变量调用函数"></a><strong>用函数指针变量调用函数</strong></h2><p>例题：</p><p>用函数求整数a和b中的大者。</p><p>程序：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;  <span class="comment">//对max函数进行声明</span></span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);  <span class="comment">//定义指向函数的指针变量p </span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">p=<span class="built_in">max</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入两个不相等的整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">c=(*p)(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max=%d"</span>,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  <span class="comment">//对max函数进行定义 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">z=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">z=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入两个不相等的整数：<span class="number">67</span> <span class="number">32</span></span><br><span class="line">max=<span class="number">67</span></span><br></pre></td></tr></table></figure><hr><h2 id="定义和使用指向函数的指针变量"><a href="#定义和使用指向函数的指针变量" class="headerlink" title="定义和使用指向函数的指针变量"></a><strong>定义和使用指向函数的指针变量</strong></h2><p>例题：</p><p>输入两个整数，然后选择0或1，选择0时调用max函数，输出二者中的大数；选择1时调用min函数，输出二者中的小数。</p><p>程序：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> Y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b,z,Z;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入两个不相等的整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"选择0或1："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z);</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=<span class="built_in">max</span>;</span><br><span class="line">Z=(*p)(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max=%d"</span>,Z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=<span class="built_in">min</span>;</span><br><span class="line">Z=(*p)(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"min=%d"</span>,Z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line"><span class="keyword">if</span>(X&gt;Y)</span><br><span class="line">&#123;</span><br><span class="line">K=X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">K=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> K;</span><br><span class="line"><span class="keyword">if</span>(x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">K=x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">K=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入两个不相等的整数：<span class="number">34</span> <span class="number">12</span></span><br><span class="line">选择<span class="number">0</span>或<span class="number">1</span>：<span class="number">0</span></span><br><span class="line">max=<span class="number">34</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入两个不相等的整数：<span class="number">45</span> <span class="number">12</span></span><br><span class="line">选择<span class="number">0</span>或<span class="number">1</span>：<span class="number">1</span></span><br><span class="line">min=<span class="number">12</span></span><br></pre></td></tr></table></figure><ul><li>对指向函数的指针变量不能进行算术运算，如p++、p–等运算是无意义的。</li></ul><hr><h2 id="返回指针值的函数"><a href="#返回指针值的函数" class="headerlink" title="返回指针值的函数"></a><strong>返回指针值的函数</strong></h2><p>例题：</p><p>有3个学生，每个学生有4门课程的成绩。要求在输入学生序号以后，输出该学生的全部成绩。用指针函数来实现。</p><p>程序：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> *search(<span class="built_in">int</span> (*pointer)[<span class="number">4</span>],<span class="built_in">int</span> n);</span><br><span class="line"><span class="built_in">int</span> source[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">89</span>,<span class="number">78</span>,<span class="number">80</span>,<span class="number">76</span>&#125;,&#123;<span class="number">67</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">70</span>&#125;,&#123;<span class="number">91</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">75</span>&#125;&#125;;</span><br><span class="line">printf(<span class="string">"输入学生序号："</span>);</span><br><span class="line"><span class="built_in">int</span> num;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="built_in">int</span> *p;</span><br><span class="line">p=search(source,num);</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%d\t"</span>,*(p+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> *search(<span class="built_in">int</span> (*pointer)[<span class="number">4</span>],<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> *pt;</span><br><span class="line">pt=*(pointer+n); </span><br><span class="line"><span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入学生序号：<span class="number">1</span></span><br><span class="line"><span class="number">67</span>      <span class="number">90</span>      <span class="number">56</span>      <span class="number">70</span></span><br></pre></td></tr></table></figure><hr><h2 id="定义和使用指针数组"><a href="#定义和使用指针数组" class="headerlink" title="定义和使用指针数组"></a><strong>定义和使用指针数组</strong></h2><p>指针数组中的每一个元素都存放一个地址，相当于一个指针变量。</p><p>指针数组比较适合用来指向若干个字符串，使字符串处理更加方便灵活。</p><p>例题：</p><p>将若干个字符串按字母顺序由小到大输出。</p><p>程序：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> sort(<span class="type">char</span> *<span class="type">name</span>[],<span class="type">int</span> n);</span><br><span class="line"><span class="type">void</span> print(<span class="type">char</span> *<span class="type">name</span>[],<span class="type">int</span> n);</span><br><span class="line"><span class="type">char</span> *<span class="type">name</span>[]=&#123;"Linux","Windows","Android","Unix"&#125;;  //定义指针数组，它的元素分别指向<span class="number">4</span>个字符串 </span><br><span class="line"><span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">sort(<span class="type">name</span>,n);  //调用sort函数，对字符串排序 </span><br><span class="line">print(<span class="type">name</span>,n);  //调用print函数，输出字符串 </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sort(<span class="type">char</span> *<span class="type">name</span>[],<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *<span class="keyword">temp</span>;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)  //用选择法排序 </span><br><span class="line">&#123;</span><br><span class="line">k=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strcmp(<span class="type">name</span>[k],<span class="type">name</span>[j])&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">k=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">temp</span>=<span class="type">name</span>[i];</span><br><span class="line"><span class="type">name</span>[i]=<span class="type">name</span>[k];</span><br><span class="line"><span class="type">name</span>[k]=<span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> print(<span class="type">char</span> *<span class="type">name</span>[],<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf("%s\n",<span class="type">name</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Android</span></span><br><span class="line"><span class="keyword">Linux</span></span><br><span class="line"><span class="keyword">Unix</span></span><br><span class="line"><span class="keyword">Windows</span></span><br></pre></td></tr></table></figure><hr><h2 id="指向指针数据的指针变量"><a href="#指向指针数据的指针变量" class="headerlink" title="指向指针数据的指针变量"></a><strong>指向指针数据的指针变量</strong></h2><p>例题：</p><p>有一个指针数组，其元素分别指向一个整型数组的元素，用指向指针数据的指针变量，输出整型数组各元素的值。</p><p>程序：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> *b[<span class="number">5</span>]=&#123;&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>],&amp;a[<span class="number">4</span>]&#125;;</span><br><span class="line"><span class="built_in">int</span> **p;</span><br><span class="line">p=b;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%d\t"</span>,**p);</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>      <span class="number">3</span>       <span class="number">5</span>       <span class="number">7</span>       <span class="number">9</span></span><br></pre></td></tr></table></figure><hr><p><strong>常见指针变量的定义</strong></p><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>int *p;</td><td>p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组</td></tr><tr><td>int **p;</td><td>p 为二级指针，指向 int * 类型的数据</td></tr><tr><td>int *p[n];</td><td>p 为指针数组，可以理解为 int *(p[n]);</td></tr><tr><td>int (*p)[n];</td><td>p 为二维数组指针</td></tr><tr><td>int *p();</td><td>p 是一个函数，它的返回值类型为 int *</td></tr><tr><td>int (*p)();</td><td>p 是一个函数指针</td></tr></tbody></table><ul><li><p>指针变量可以进行加减运算，例如 p++、 p+i、 p-=i。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。</p></li><li><p>使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就会崩溃。对于暂时没有指向的指针，应赋值 NULL。</p></li><li><p>两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。</p></li></ul><hr><p>在C语言指针方面，自己觉得需要整理的细化知识点就是这些了，如有错误，请在评论区多多指教o(^▽^)o。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ls命令笔记</title>
      <link href="/2020/05/17/ls%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/17/ls%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Linux是类Unix操作系统的一种，ls命令是Linux中使用频率较高的命令之一，既可列出指定目录的内容及其详细信息，也可列出指定文件的详细信息。</p><a id="more"></a><h3 id="ls命令使用"><a href="#ls命令使用" class="headerlink" title="ls命令使用"></a>ls命令使用</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> [选项]<span class="string">//</span>指定目录默认为当前目录</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-attr">[选项]</span> <span class="selector-attr">[目录名或文件名]</span></span><br></pre></td></tr></table></figure><h3 id="ls常用命令选项"><a href="#ls常用命令选项" class="headerlink" title="ls常用命令选项"></a>ls常用命令选项</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-A列出指定目录下的所有文件，包括隐藏文件（以”.“开头的文件和目录）</span></span><br><span class="line"><span class="deletion">-l使用长格式显示指定目录的内容的详细信息或指定文件的详细信息</span></span><br><span class="line"><span class="deletion">-i显示指定目录的内容或指定文件的索引节点号码（Unix/Linux内部使用索引节点号码来识别文件）</span></span><br><span class="line"><span class="deletion">-t将文件按照建立时间的先后次序列出</span></span><br><span class="line"><span class="deletion">-R递归显示目录，若目录下有文件，则以下的文件也会被依序列出</span></span><br><span class="line"><span class="deletion">-h配合“-l”使用，以合适的单位显示文件的大小</span></span><br><span class="line"><span class="deletion">-S根据文件大小排序（由大到小，若要由小到大排序，则再使用“-r”；在Linux中，所有目录的大小总为4096字节）</span></span><br><span class="line"><span class="deletion">-G不列出任何有关组的信息</span></span><br><span class="line"><span class="deletion">-g类似“-l”，但不列出所有者</span></span><br><span class="line"><span class="deletion">-o类似“-l”，但不列出组</span></span><br><span class="line"><span class="deletion">-p显示出目录（目录名结尾有“/”）</span></span><br><span class="line"><span class="deletion">-F显示出文件类型（“/”表示目录，“@”表示指向其它文件的符号链接，“*”表示可执行文件）</span></span><br></pre></td></tr></table></figure><ul><li><p>选项-l显示的详细信息的各列的含义</p><p><img src="/images/ls%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt></p><p>第一列表示是文件还是目录（d开头的为目录）</p><p>第二列，如果是目录，则是目录下的子目录和文件数目；如果是文件，则是文件的链接数</p><p>第三列表示文件的所有者名字</p><p>第四列表示文件的所属的组名字</p><p>第五列表示文件的字节数</p><p>第六~八列表示上一次修改的时间</p><p>第九列表示文件名</p></li><li><p>索引节点包含的信息（使用stat命令查看）： </p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">stat</span><span class="meta"> [文件名]</span></span><br></pre></td></tr></table></figure><p><img src="/images/ls%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF.png" alt></p><p>文件的大小（字节数），文件拥有者的User ID，文件的Group ID，文件的读、写、执行权限，文件的时间（最近访问、最近更改、最近改动），链接数（指向这个索引节点的文件名的数量），文件数据block（block是文件存取的最小单位）的位置</p><ul><li><p>在Unix/Linux中，表面上用户通过文件名打开文件，但这一过程在系统内部分为三步：<strong>1.</strong>  系统通过Directory（一种记录了文件名称对应的索引节点号码的文件）找到这个文件名对应的索引节点号码；<strong>2.</strong>  通过索引节点号码获取索引节点信息；<strong>3.</strong>  根据索引节点信息，找到文件数据所在的block来读取数据。</p></li><li><p>在Unix/Linux中，目录文件的读权限和写权限都是针对目录文件本身。由于目录文件内只有文件名和索引节点号码，所以如果只有读权限，则只能获取文件名，无法获取其他信息，因为其他信息都储存在索引节点中，而而获取索引节点包含的信息需要目录文件的执行权限。</p></li><li><p>由索引节点号码与文件名分离的机制而导致的一些Unix/Linux特有的现象： </p><ul><li>当文件名因包含特殊字符而无法删除文件的时候，可以通过直接删除索引节点来起到删除文件的作用。</li><li><strong>当一个文件被打开后，系统就以索引节点号码来识别这个文件，不再考虑文件名。</strong></li><li>可以在不关闭软件的情况下进行该软件的更新，因为系统以索引节点号码来识别运行中的文件，不再考虑文件名。更新的时候新文件可以以同样的文件名生成一个新的索引节点，不会影响到运行中的文件，等到下一次运行该软件的时候，文件名就自动指向新文件，旧文件的索引节点则被回收。</li><li>移动或重命名文件都不影响索引节点号码。</li></ul></li><li><p>索引节点也会占用硬盘空间。在硬盘格式化的时候，Unix/Linux自动将硬盘分为两个区域，一个区域用于存放文件数据；另一个区域是inode table，存放索引节点所包含的信息。<strong>索引节点的总数在硬盘格式化时就已经确定了</strong>，一般每1KB或每2KB就设置一个索引节点，每个索引节点的大小一般是128B或256B。</p><ul><li><p>查看索引节点总数和已使用的数量</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df -i</span></span><br></pre></td></tr></table></figure><p>由于每个文件都必须要有一个索引节点，因此有可能出现索引节点已用完，但硬盘空间未消耗完的情况，这时就无法在硬盘上新建文件。</p></li></ul></li></ul></li></ul><p>本人刚开始系统性地自学Linux，如有错误之处，请在评论区多多指教(*´∀`)~♥，我会及时修正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux入门（娱乐向）</title>
      <link href="/2020/04/28/Termux%E5%85%A5%E9%97%A8%EF%BC%88%E5%A8%B1%E4%B9%90%E5%90%91%EF%BC%89/"/>
      <url>/2020/04/28/Termux%E5%85%A5%E9%97%A8%EF%BC%88%E5%A8%B1%E4%B9%90%E5%90%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Termux是一款Android上的开源的模拟终端，能在Android上不需要root即可模拟出Linux环境，在终端内可实现与真实的Linux几乎无异的操作，但其运行原理我还不是很懂〒▽〒，应该不是虚拟机。emmmm，对于不折腾会死星人来说，又多了一件极（zhuang）客（bi）神器（○｀ 3′○）。</p><a id="more"></a><p>获取详细介绍可<a href="https://termux.com/" target="_blank" rel="noopener">前往官网</a></p><p>下载地址：</p><p><a href="https://play.google.com/store/apps/details?id=com.termux" target="_blank" rel="noopener">Google Play</a></p><p><a href="https://f-droid.org/packages/com.termux/" target="_blank" rel="noopener">F-Droid</a></p><p><a href="https://www.coolapk.com/apk/com.termux" target="_blank" rel="noopener">酷安</a></p><p>有条件的玩家推荐从Google Play或F-Droid下载，毕竟Google Play和F-Droid上的Termux更新比较快，至于酷安上的就emmmmm，算了不说了 ┌|*´∀｀|┘ 。</p><p>本文的部分内容整理自国光大佬的<a href="https://www.sqlsec.com/2018/05/termux.html#toc-heading-1" target="_blank" rel="noopener"> <strong>Termux 高级终端安装使用配置教程</strong> </a>和代码农上的文章<a href="http://www.daimanong.com/1303.html" target="_blank" rel="noopener">最详细、完整的基于安卓手机使用Termux搭建web服务器教程！</a>，因为我是从以上这两篇文章正式开始接触Termux (&gt;▽&lt;) 。</p><hr><h1 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a><strong>修改镜像源</strong></h1><p>因为Termux的默认镜像源在国外，国内访问的话一般情况下速度会比较感人 ╮（╯＿╰）╭ ，所以需要把Termux使用的镜像源修改为国内的，以提高访问速度，我把镜像源修改为清华大学开源软件镜像站。</p><p>Termux自带的默认编辑器为vi，所以就使用vi编辑镜像源的地址</p><p>输入以下命令进入文本</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">EDITOR</span>=vi</span><br><span class="line">apt edit-sources</span><br></pre></td></tr></table></figure><p>按 i 键进入编辑模式</p><p><img src="/images/Screenshot_2020-04-27-20-45-30-952_com.termux.jpg" alt></p><p>把以下内容用 # 注释</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">deb https:<span class="regexp">//</span>termux.org<span class="regexp">/packages/</span> stable main</span><br></pre></td></tr></table></figure><p>并在其下一行添加以下内容</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.tuna.tsinghua.edu.cn/termux stable main</span></span><br></pre></td></tr></table></figure><p>然后点击编辑器的辅助按键（在输入键盘的上方）的 ESC 键，再输入英文状态下的 : 字符，接着输入wq，最后回车，即保存并退出vi</p><p><img src="/images/Screenshot_2020-04-27-20-52-53-395_com.termux.jpg" alt></p><hr><h1 id="SSH的配置"><a href="#SSH的配置" class="headerlink" title="SSH的配置"></a><strong>SSH的配置</strong></h1><p>SSH（全称Secure Shell，安全外壳协议）是一种加密的网络传输协议，可用于传输命令行界面和命令；同时借助SFTP或SCP协议，SSH也可用于传输文件。使用PC上的SSH客户端连接Termux（<strong>手机和PC在同一局域网内</strong>），能获得更好的使用体验。</p><p>首先，安装OpenSSH</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> openssh</span><br></pre></td></tr></table></figure><p>安装完成后，配置密码</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd</span></span><br></pre></td></tr></table></figure><p>接着，查看用户名和IP地址</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">whoami</span>  <span class="comment">#查看用户名</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span>  <span class="comment">#查看IP地址</span></span><br></pre></td></tr></table></figure><p>然后手动启动OpenSSH的服务进程sshd，并在电脑上用PuTTY登录</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sshd</span></span><br></pre></td></tr></table></figure><p>Host Name中输入查询得到的IP地址</p><p>（<strong>端口（Port）必须改为OpenSSH的默认端口8022</strong>）</p><p><img src="/images/Snipaste_2020-04-27_21-11-31.png" alt></p><p>然后在命令行界面分别输入查询得到的用户名和自己配置的密码</p><p>登录成功后就会有balabala的一堆东西</p><p><img src="/images/Snipaste_2020-04-27_21-07-16.png" alt></p><p>至此，就可以在电脑上操作Termux了</p><p>(#｀-_ゝ-)我接触SSH没多久，所以点亮的技能点比较少 <del>才不是因为我懒</del>，大佬勿喷（○｀ 3′○）</p><hr><h1 id="Aria2的安装和使用"><a href="#Aria2的安装和使用" class="headerlink" title="Aria2的安装和使用"></a><strong>Aria2的安装和使用</strong></h1><p>Aria2是一款适用于Linux，Windows，Mac OS X的跨平台命令行下载工具，其支持的下载协议有HTTP、HTTPS、FTP、SFTP、BitTorrent和Metalink（此下载协议国内好像不怎么用得到）；由于支持多线程和多源或多协议下载文件，因此Aria2具备真正的高速下载能力；同时Aria2占用的CPU和内存资源少，因此其可以运行于现今几乎所有的计算机设备。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> aria2 <span class="comment">#安装Aria2</span></span><br></pre></td></tr></table></figure><p><strong>使用Aria2</strong></p><p>一般下载：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> 链接</span><br></pre></td></tr></table></figure><p>下载限速（ x 为正整数，代表此次任务的最大下载速度，例如速度限制为100KB/s，则设置为100k）</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">aria2c </span><span class="built_in">--max-download-limit=xk</span> 链接 <span class="comment">#单个文件下载限速</span></span><br><span class="line"><span class="string">aria2c </span><span class="built_in">--max-overall-download-limit=xk</span> 链接 <span class="comment">#整体下载限速</span></span><br></pre></td></tr></table></figure><p>断点续传下载文件</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> -<span class="keyword">c</span> 之前下载文件的链接</span><br></pre></td></tr></table></figure><p>下载并重命名文件</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> -o 文件名 链接</span><br></pre></td></tr></table></figure><p>下载多个文件</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">aria2c -Z 链接<span class="number">1</span> 链接<span class="number">2</span></span><br></pre></td></tr></table></figure><p>分段下载（可提高大文件的下载速度）</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> -<span class="keyword">x</span> <span class="keyword">x</span> 链接 #使用<span class="keyword">x</span>个链接来下载该文件（第二个<span class="keyword">x</span>为整数，介于<span class="number">1</span>~<span class="number">5</span>之间）</span><br></pre></td></tr></table></figure><p>BT下载</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> 种子文件</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> 磁力链接</span><br></pre></td></tr></table></figure><p>列出种子文件的内容</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> -S 种子文件</span><br></pre></td></tr></table></figure><p>下载种子文件内编号为x，y的文件（x，y为顺序编号）</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">aria<span class="number">2</span><span class="keyword">c</span> --<span class="keyword">select</span>-file=<span class="keyword">x</span>,y 种子文件</span><br></pre></td></tr></table></figure><p>(￣ ‘i ￣;)现在自己点亮的的Aria2技能点比较少 <del>当然不是因为我懒啦</del>，大佬勿喷(￣┰￣*)</p><hr><h1 id="视（zhuang）觉（bi）特（wan）效（fa）"><a href="#视（zhuang）觉（bi）特（wan）效（fa）" class="headerlink" title="视（zhuang）觉（bi）特（wan）效（fa）"></a><strong>视（zhuang）觉（bi）特（wan）效（fa）</strong></h1><p><del>好像这才是本文的重点(&gt;▽&lt;)</del></p><p>有些视觉特效需要使用“Ctrl + C”组合键退出</p><p>以下演示均在电脑上通过SSH连接Termux</p><p>cmatrix</p><p>《黑客帝国》的代码雨视觉特效</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> cmatrix  <span class="comment">#安装</span></span><br><span class="line">cmatrix  <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-06-58.png" alt></p><p>hollywood</p><p>假装自己是一名黑客&lt;(ˉ^ˉ)&gt;</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> hollywood  <span class="comment">#安装</span></span><br><span class="line">hollywood  <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-13-11.png" alt></p><p><img src="/images/Snipaste_2020-04-28_22-13-35.png" alt></p><p>neofetch</p><p>显示设备部分的软硬件信息（比较少）</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> neofetch  <span class="comment">#安装</span></span><br><span class="line">neofetch  <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-17-58.png" alt></p><p>nyancat</p><p>彩虹猫</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> nyancat  <span class="comment">#安装</span></span><br><span class="line">nyancat  <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-25-53.png" alt></p><p>screenfetch</p><p>显示设备部分的软硬件信息</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install </span><span class="keyword">screenfetch </span> <span class="comment">#安装</span></span><br><span class="line"><span class="keyword">screenfetch </span> <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-30-42.png" alt></p><p>显示Linux发行版的logo</p><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">screenfetch -<span class="keyword">A</span> 发行版</span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-35-22.png" alt></p><p>目前（2020/4/28）内置的Linux发行版logo</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ALDOS</span>, Alpine Linux, Amazon Linux, Antergos, Arch Linux (Old <span class="keyword">and </span>Current Logos), ArcoLinux, Artix Linux, <span class="keyword">blackPanther </span>OS, <span class="keyword">BLAG, </span><span class="keyword">BunsenLabs, </span>CentOS, Chakra, Chapeau, Chrome OS, Chromium OS, CrunchBang, CRUX, Debian, Deepin, DesaOS,Devuan, Dragora, elementary OS, EuroLinux, Evolve OS, Sulin, Exherbo, Fedora, Frugalware, Fuduntu, Funtoo, Fux, Gentoo, gNewSense, Guix System, Hyperbola GNU/Linux-libre, januslinux, Jiyuu Linux, Kali Linux, KaOS, KDE neon, Kogaion, Korora, LinuxDeepin, Linux Mint, LMDE, Logos, Mageia, Mandriva/Mandrake, Manjaro, Mer, Netrunner, NixOS, OBRevenge, openSUSE, OS Elbrus, Oracle Linux, Parabola GNU/Linux-libre, Pardus, Parrot Security, PCLinuxOS, PeppermintOS, Proxmox VE, PureOS, Qubes OS, Raspbian, Red Hat Enterprise Linux, ROSA, Sabayon, SailfishOS, Scientific Linux, Siduction, Slackware, Solus, Source Mage GNU/Linux, SparkyLinux, SteamOS, SUSE Linux Enterprise, SwagArch, TinyCore, Trisquel, Ubuntu, Viperr, Void <span class="keyword">and </span>Zorin OS <span class="keyword">and </span>EndeavourOS</span><br></pre></td></tr></table></figure><p>sl</p><p>火车呼啸而过</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pkg <span class="keyword">install</span> sl  <span class="comment">#安装</span></span><br><span class="line">sl  <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_22-41-23.png" alt></p><hr><h1 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a><strong>个人思考</strong></h1><p><strong>以下内容仅代表本人观点</strong></p><p>其实，我觉得Termux真正的使用价值在于可以把Android手机打造成一台移动便携性超强的mini服务器（以目前（2020年）主流手机的算力（骁龙675同等级SOC+4GB内存起步）足以胜任一些相对简单的Linux任务）。搭载了Termux的Android手机，不仅不会改变原有的全部功能，还可分担部分例如渗透测试（我这个小菜鸡还不会_〆(´Д｀ )）、网站管理等等的专业任务，在几乎任何地方都能投入工作<del>一部手机，娱乐、脱发两不误</del>而不受体积和便携性的影响，能给Android手机赋予新的定义。</p><p>目前（2020年4月下旬）国内的Termux玩家还比较小众（相较于Magisk、Xposed、黑苹果这类来说），希望在不久的将来国内有更多的玩家和技术大神能探索、折腾Termux，助力Termux项目不断发展，说不定哪一天Termux也会成为IT界一个声名显赫的存在(○´･д･)ﾉ。</p><hr><p>本文如有错误和疏漏，请大佬不惜赐教；大佬如果有什么建议，希望能在评论区留下你的宝贵提议。</p><p>万分感谢！＜（＾－＾）＞</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Linux </tag>
            
            <tag> Termux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB命令收录（非全部）</title>
      <link href="/2020/04/14/ADB%E5%91%BD%E4%BB%A4%E6%94%B6%E5%BD%95%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/"/>
      <url>/2020/04/14/ADB%E5%91%BD%E4%BB%A4%E6%94%B6%E5%BD%95%EF%BC%88%E9%9D%9E%E5%85%A8%E9%83%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前几天接触了一下ADB（全称为 Android Debug Bridge ，一种使Android设备与电脑（包括Windows、Linux和macOS）之间进行相互通信的命令行工具，常应用于Android开发），在折腾的过程中觉得有一些命令的可玩性比较强，可以用来写一些用于Android手机的连点器、按键控制之类的脚本 (&gt;▽&lt;) ，于是就打算写下这篇文章来记录一下，以后折腾应用程序开发的时候可能会用到。</p><hr><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> input text <span class="string">"xxx"</span></span></span><br></pre></td></tr></table></figure><p>向设备输入xxx字符（不能使用中文）</p><a id="more"></a><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> input tap x y</span></span><br></pre></td></tr></table></figure><p>模拟点击屏幕的点坐标（x，y）</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> input swipe x1 y1 x2 y2 t</span></span><br></pre></td></tr></table></figure><p>在t毫秒内模拟从屏幕的点坐标（x1，y1）滑动到（x2，y2）</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys battery</span></span><br></pre></td></tr></table></figure><p>列出电池状态</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys battery <span class="built_in">set</span> level x</span></span><br></pre></td></tr></table></figure><p>修改电池电量的百分比为x（x为整数）</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> dumpsys battery reset</span></span><br></pre></td></tr></table></figure><p>恢复电池电量的真实百分比</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> input keyevent x</span></span><br></pre></td></tr></table></figure><p>触发按键功能，x代表keycode</p><p>我个人认为在Android手机上比较实用的keycode及其对应的功能</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">7 </span>--&gt; 数字键“<span class="number">0</span>”</span><br><span class="line"><span class="symbol">8 </span>--&gt; 数字键“<span class="number">1</span>”</span><br><span class="line"><span class="symbol">9 </span>--&gt; 数字键“<span class="number">2</span>”</span><br><span class="line"><span class="symbol">10 </span>--&gt; 数字键“<span class="number">3</span>”</span><br><span class="line"><span class="symbol">11 </span>--&gt; 数字键“<span class="number">4</span>”</span><br><span class="line"><span class="symbol">12 </span>--&gt; 数字键“<span class="number">5</span>”</span><br><span class="line"><span class="symbol">13 </span>--&gt; 数字键“<span class="number">6</span>”</span><br><span class="line"><span class="symbol">14 </span>--&gt; 数字键“<span class="number">7</span>”</span><br><span class="line"><span class="symbol">15 </span>--&gt; 数字键“<span class="number">8</span>”</span><br><span class="line"><span class="symbol">16 </span>--&gt; 数字键“<span class="number">9</span>”</span><br><span class="line"></span><br><span class="line"><span class="symbol">29 </span>--&gt; 字母键“A”</span><br><span class="line"><span class="symbol">30 </span>--&gt; 字母键“B”</span><br><span class="line"><span class="symbol">31 </span>--&gt; 字母键“C”</span><br><span class="line"><span class="symbol">32 </span>--&gt; 字母键“D”</span><br><span class="line"><span class="symbol">33 </span>--&gt; 字母键“E”</span><br><span class="line"><span class="symbol">34 </span>--&gt; 字母键“F”</span><br><span class="line"><span class="symbol">35 </span>--&gt; 字母键“G”</span><br><span class="line"><span class="symbol">36 </span>--&gt; 字母键“H”</span><br><span class="line"><span class="symbol">37 </span>--&gt; 字母键“I”</span><br><span class="line"><span class="symbol">38 </span>--&gt; 字母键“J”</span><br><span class="line"><span class="symbol">39 </span>--&gt; 字母键“K”</span><br><span class="line"><span class="symbol">40 </span>--&gt; 字母键“L”</span><br><span class="line"><span class="symbol">41 </span>--&gt; 字母键“M”</span><br><span class="line"><span class="symbol">42 </span>--&gt; 字母键“N”</span><br><span class="line"><span class="symbol">43 </span>--&gt; 字母键“O”</span><br><span class="line"><span class="symbol">44 </span>--&gt; 字母键“P”</span><br><span class="line"><span class="symbol">45 </span>--&gt; 字母键“Q”</span><br><span class="line"><span class="symbol">46 </span>--&gt; 字母键“R”</span><br><span class="line"><span class="symbol">47 </span>--&gt; 字母键“S”</span><br><span class="line"><span class="symbol">48 </span>--&gt; 字母键“T”</span><br><span class="line"><span class="symbol">49 </span>--&gt; 字母键“U”</span><br><span class="line"><span class="symbol">50 </span>--&gt; 字母键“V”</span><br><span class="line"><span class="symbol">51 </span>--&gt; 字母键“W”</span><br><span class="line"><span class="symbol">52 </span>--&gt; 字母键“X”</span><br><span class="line"><span class="symbol">53 </span>--&gt; 字母键“Y”</span><br><span class="line"><span class="symbol">54 </span>--&gt; 字母键“Z”</span><br><span class="line"></span><br><span class="line"><span class="symbol">3 </span>--&gt; HOME 键</span><br><span class="line"><span class="symbol">4 </span>--&gt; BACK 键</span><br><span class="line"><span class="symbol">82 </span>--&gt; 菜单 键</span><br><span class="line"><span class="symbol">26 </span>--&gt; 电源 键</span><br><span class="line"><span class="symbol">24 </span>--&gt; 音量“+”</span><br><span class="line"><span class="symbol">25 </span>--&gt; 音量“-”</span><br><span class="line"><span class="symbol">164 </span>--&gt; 静音</span><br><span class="line"><span class="symbol">220 </span>--&gt; 降低屏幕亮度</span><br><span class="line"><span class="symbol">221 </span>--&gt; 提高屏幕亮度</span><br></pre></td></tr></table></figure><ul><li><p>文件传输</p><p>把电脑中的文件传输到Android手机</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">adb</span> <span class="keyword">push </span><span class="string">"电脑中的文件路径"</span> <span class="string">"Android手机中的目标路径"</span></span><br></pre></td></tr></table></figure><p>把Android手机中的文件传输到电脑</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> pull <span class="string">"Android手机中的文件路径"</span> <span class="string">"电脑中的文件路径"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>软件安装和卸载</p><p>把电脑中的APK安装到Android手机</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">install</span> <span class="string">"电脑中的APK路径"</span></span><br></pre></td></tr></table></figure><p>把电脑中的APK覆盖安装到Android手机</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">install</span> -r <span class="string">"电脑中的APK路径"</span></span><br></pre></td></tr></table></figure><p>卸载Android手机中的第三方软件</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> uninstall 应用包名</span><br></pre></td></tr></table></figure></li></ul><hr><p>这是我在自己搭建的第一个网站上写的第一篇文章，网站和文章如有不完善的地方，希望大佬勿喷，另外还希望大佬能指出不足之处，万分感谢(<em>^▽^</em>)，我定会及时改正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>(｡･∀･)ﾉﾞ关于我(′▽`〃)</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><strong>名字</strong>：小浣熊(&gt;▽&lt;)</p><p><strong>性别</strong>：当然是XY啦(っ*´Д`)っ</p><p><strong>破壳之日</strong>：2002 / 03 / 04</p><p><strong>性格</strong>：偏内向(．． )…，钢铁直男(ノへ￣、)</p><p><strong>特点</strong>：宅…..((/- -)/，喜欢数码产品（相机除外）(*╯3╰)</p><p><strong>原驻点</strong>：广东省江门市鹤山市</p><p><strong>学校</strong>：中山大学新华学院</p><p><strong>学历</strong>：</p><p>大一计算机专业萌新一枚╮(╯▽╰)╭（2019年9月 ~ 2020年6月）</p><p>大二计算机专业菜鸟一只 (つд⊂) （2020年9月 ~ 2021年6月）</p><p><strong>志向</strong>：毕业后打算从事硬件设计和开发(‾◡◝)</p><p><strong>爱好</strong>：</p><p>喜欢<del>玩机搞机</del>折腾计算机（涵盖软、硬件，包括但不限于电脑、手机）（´v｀）；偶尔玩玩Xboxヾ(≧▽≦*)o</p><p><strong>喜欢的游戏</strong>：</p><p>GTA5（R星的给他爱5，三人一狗，没什么好质疑的 ヾ(≧▽≦*)o ）</p><p>荒野大镖客2（见证主角亚瑟·摩根的救赎(ノへ￣、)，骑马、狩猎、旅游观光；人物、剧情、细节都达到近乎完美的神作(๑•̀ㅂ•́)و✧）</p><p>使命召唤系列（每个男生骨子里都刻着一杆枪ε٩(๑&gt; ₃ &lt;)۶з）</p><p><strong>建站初心</strong>：</p><p>本站主要记录自己玩机搞机的部分笔记(つд⊂)，即使没什么人访问也不会在意。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>(^u^)友情链接(ﾉ&gt;ω&lt;)ﾉ</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[<p>ヾ(≧∇≦<em>)ゝ欢迎来访(</em>^▽^*)</p><p><strong>友链声明</strong></p><ul><li>本站会主动保存您的 HTTPS 形式的头像图片链接</li><li>本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作</li><li>本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除</li></ul><p><strong>申请要求</strong></p><ul><li>内容以计算机技术类的话题为主，不接受软件资源收集&amp;分享站</li><li>持续更新且可以稳定访问</li><li>网页整洁无繁杂广告推广</li><li>博客主页被百度或谷歌等搜索引擎收录</li><li>头像能够快速加载</li><li>拥有独立域名</li></ul><p><strong>申请方式</strong></p><p>请先把本站的友链添加到贵站，相关信息如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">博客名称： 小浣熊的技术小站</span><br><span class="line">博客地址： <span class="string">https:</span><span class="comment">//nimitiz.cn/</span></span><br><span class="line">博客头像： <span class="string">https:</span><span class="comment">//ftp.bmp.ovh/imgs/2020/08/af2963980918097c.jpg</span></span><br><span class="line">博客介绍： 生命不息，折腾不止</span><br></pre></td></tr></table></figure><p>然后在本页的评论区留言贵站的友链信息，待博主添加贵站的友链。</p><h2 id="朋友们-▽"><a href="#朋友们-▽" class="headerlink" title="朋友们(^▽^)"></a>朋友们(<em>^▽^</em>)</h2><div id="links"><div class="links-content"><div class="link-navigation"><div class="card">  <a href="https://chengxuxiaohei.cn/" target="_blank">  <img class="ava" src="https://chengxuxiaohei.cn/img/favicon-32x32.png"></a>  <div class="card-header">  <div><a href="https://chengxuxiaohei.cn/" target="_blank">程序小黑</a>  <a href="https://chengxuxiaohei.cn/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="一个有科技感的个人博客">一个有科技感的个人博客</div>  </div></div><div class="card">  <a href="https://www.wonder1999.com/" target="_blank">  <img class="ava" src="https://pic.downk.cc/item/5e7d881e504f4bcb042d5542.png"></a>  <div class="card-header">  <div><a href="https://www.wonder1999.com/" target="_blank">wonder</a>  <a href="https://www.wonder1999.com/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="一个励志进入阿里巴巴的惨淡大学生，或许前路茫茫，但我仍会砥砺前行">一个励志进入阿里巴巴的惨淡大学生，或许前路茫茫，但我仍会砥砺前行</div>  </div></div><div class="card">  <a href="https://xuyiyang.com.cn/" target="_blank">  <img class="ava" src="https://i.loli.net/2020/08/27/STxnvNphVbtkgdI.jpg"></a>  <div class="card-header">  <div><a href="https://xuyiyang.com.cn/" target="_blank">徐艺扬的博客</a>  <a href="https://xuyiyang.com.cn/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="分享有趣、有用的内容。">分享有趣、有用的内容。</div>  </div></div><div class="card">  <a href="https://www.saroin.com" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/AJRECHO/WWW@master/uPic/user/ajrecho.jpg"></a>  <div class="card-header">  <div><a href="https://www.saroin.com" target="_blank">鲸一</a>  <a href="https://www.saroin.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="希望是件美好的事，也许是世间最美好的东西，而美好的事物永不消逝!">希望是件美好的事，也许是世间最美好的东西，而美好的事物永不消逝!</div>  </div></div><div class="card">  <a href="https://johnsonran.cn" target="_blank">  <img class="ava" src="https://q1.qlogo.cn/g?b=qq&nk=3546870850&s=640"></a>  <div class="card-header">  <div><a href="https://johnsonran.cn" target="_blank">Ran's Blog</a>  <a href="https://johnsonran.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="我永远喜欢莲华">我永远喜欢莲华</div>  </div></div><div class="card">  <a href="https://wch666.com" target="_blank">  <img class="ava" src="https://wch666.com/head.png"></a>  <div class="card-header">  <div><a href="https://wch666.com" target="_blank">心月云</a>  <a href="https://wch666.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="永远年轻，永远热泪盈眶">永远年轻，永远热泪盈眶</div>  </div></div><div class="card">  <a href="https://66ccff.work" target="_blank">  <img class="ava" src="https://gitee.com/hshx123/picplus/raw/master/1595119088132.png"></a>  <div class="card-header">  <div><a href="https://66ccff.work" target="_blank">杏铃の小本</a>  <a href="https://66ccff.work" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="一份分享教程&游戏的博客">一份分享教程&游戏的博客</div>  </div></div><div class="card">  <a href="https://leflacon.top/" target="_blank">  <img class="ava" src="https://tva1.sinaimg.cn/large/00831rSTly1gcsjn9y09kj30sg0sgmxr.jpg"></a>  <div class="card-header">  <div><a href="https://leflacon.top/" target="_blank">LeFlacon’s Blog</a>  <a href="https://leflacon.top/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="梦想做个靠谱的好人(:з」∠)">梦想做个靠谱的好人(:з」∠)</div>  </div></div><div class="card">  <a href="https://yunist.cn" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/cnyist/blog/img/avatar.svg"></a>  <div class="card-header">  <div><a href="https://yunist.cn" target="_blank">云玩家</a>  <a href="https://yunist.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="虽于果壳内, 我亦无限王.">虽于果壳内, 我亦无限王.</div>  </div></div><div class="card">  <a href="https://www.lianyiming.com" target="_blank">  <img class="ava" src="https://s1.ax1x.com/2020/08/29/d7YjeA.jpg"></a>  <div class="card-header">  <div><a href="https://www.lianyiming.com" target="_blank">廉一鸣的博客</a>  <a href="https://www.lianyiming.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="去他的真理无穷，进一寸有一寸的欢喜">去他的真理无穷，进一寸有一寸的欢喜</div>  </div></div><div class="card">  <a href="https://blog.inpan.top/" target="_blank">  <img class="ava" src="https://blog.inpan.top/IMG/tx.jpg"></a>  <div class="card-header">  <div><a href="https://blog.inpan.top/" target="_blank">槿畔博客</a>  <a href="https://blog.inpan.top/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="半夏彼岸 似水流年">半夏彼岸 似水流年</div>  </div></div><div class="card">  <a href="https://conimi.com" target="_blank">  <img class="ava" src="https://conimi.com/files/images/i.jpg"></a>  <div class="card-header">  <div><a href="https://conimi.com" target="_blank">Torrk's Blog</a>  <a href="https://conimi.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="记录，成为更好的自己">记录，成为更好的自己</div>  </div></div><div class="card">  <a href="https://blog.justlovesmile.top" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/image/logo.jpg"></a>  <div class="card-header">  <div><a href="https://blog.justlovesmile.top" target="_blank">MJ’s Blog</a>  <a href="https://blog.justlovesmile.top" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="醒亦念卿，梦亦念卿">醒亦念卿，梦亦念卿</div>  </div></div><div class="card">  <a href="https://typeboom.club/" target="_blank">  <img class="ava" src="https://s1.ax1x.com/2020/10/01/0M9COP.png"></a>  <div class="card-header">  <div><a href="https://typeboom.club/" target="_blank">typeboom</a>  <a href="https://typeboom.club/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="易燃易爆">易燃易爆</div>  </div></div><div class="card">  <a href="https://sakurasep.site/" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/sakurasep/images@1.1/important/touxiang.jpg"></a>  <div class="card-header">  <div><a href="https://sakurasep.site/" target="_blank">上杉九月的博客</a>  <a href="https://sakurasep.site/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="分享生活，探索未来">分享生活，探索未来</div>  </div></div><div class="card">  <a href="https://wenjinyu.me" target="_blank">  <img class="ava" src="https://i.loli.net/2019/04/04/5ca5531418852.png"></a>  <div class="card-header">  <div><a href="https://wenjinyu.me" target="_blank">温锦瑜的博客</a>  <a href="https://wenjinyu.me" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="先想想为什么，再考虑怎么做">先想想为什么，再考虑怎么做</div>  </div></div><div class="card">  <a href="https://www.lostfawn.cn" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/jack-bin183/cdn@1.7/img/custom/avatar.png"></a>  <div class="card-header">  <div><a href="https://www.lostfawn.cn" target="_blank">迷鹿</a>  <a href="https://www.lostfawn.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="等待也是约会的一部分嘛">等待也是约会的一部分嘛</div>  </div></div><div class="card">  <a href="https://www.weiaini.xyz" target="_blank">  <img class="ava" src="https://www.weiaini.xyz/avatar.png"></a>  <div class="card-header">  <div><a href="https://www.weiaini.xyz" target="_blank">阡陌的小窝</a>  <a href="https://www.weiaini.xyz" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="记录技术与人生感想的小窝">记录技术与人生感想的小窝</div>  </div></div><div class="card">  <a href="https://sheep7.cn" target="_blank">  <img class="ava" src="https://sheep7.cn/other/tx.jpg"></a>  <div class="card-header">  <div><a href="https://sheep7.cn" target="_blank">ChiHiro</a>  <a href="https://sheep7.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="永远相信美好的事情即将发生">永远相信美好的事情即将发生</div>  </div></div><div class="card">  <a href="https://zhangxiaocai.cn" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/small-rose/small-rose.github.io@master/medias/avatar.jpg"></a>  <div class="card-header">  <div><a href="https://zhangxiaocai.cn" target="_blank">Small-Rose</a>  <a href="https://zhangxiaocai.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="道虽迩，不行不至；事虽小，不为不成。">道虽迩，不行不至；事虽小，不为不成。</div>  </div></div><div class="card">  <a href="https://nekodeng.gitee.io" target="_blank">  <img class="ava" src="https://nekodeng.gitee.io/medias/avatar.jpg"></a>  <div class="card-header">  <div><a href="https://nekodeng.gitee.io" target="_blank">itsNekoDeng</a>  <a href="https://nekodeng.gitee.io" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="十万伏特皮卡丘，梦想是世界和平，想要发光发热">十万伏特皮卡丘，梦想是世界和平，想要发光发热</div>  </div></div><div class="card">  <a href="https://www.terry906.top" target="_blank">  <img class="ava" src="https://www.terry906.top/wp-content/uploads/2020/12/319551da81cb39db19aa6018de160924aa1830e3.png"></a>  <div class="card-header">  <div><a href="https://www.terry906.top" target="_blank">明赫IT大本营</a>  <a href="https://www.terry906.top" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="互联网技术分享">互联网技术分享</div>  </div></div><div class="card">  <a href="https://blog.kaygb.com" target="_blank">  <img class="ava" src="https://sdn.geekzu.org/avatar/4cc893d113dd74ceca73f9863f2c5446/"></a>  <div class="card-header">  <div><a href="https://blog.kaygb.com" target="_blank">风也雨忆笙</a>  <a href="https://blog.kaygb.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="编程与学习，自律与生活">编程与学习，自律与生活</div>  </div></div><div class="card">  <a href="https://caviar-x.top" target="_blank">  <img class="ava" src="https://caviar-x.top/images/avatar.png"></a>  <div class="card-header">  <div><a href="https://caviar-x.top" target="_blank">Caviar-X的blog</a>  <a href="https://caviar-x.top" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="TECH OTAKUS SAVE THE WORLD!">TECH OTAKUS SAVE THE WORLD!</div>  </div></div><div class="card">  <a href="https://clover1420.top" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/clover1420/tc@main/image/2020/12/tx.png"></a>  <div class="card-header">  <div><a href="https://clover1420.top" target="_blank">繁华如风的小站</a>  <a href="https://clover1420.top" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="灯火阑珊处">灯火阑珊处</div>  </div></div><div class="card">  <a href="https://xiaoyou66.com" target="_blank">  <img class="ava" src="https://img.xiaoyou66.com/images/2020/01/14/nUDD.jpg"></a>  <div class="card-header">  <div><a href="https://xiaoyou66.com" target="_blank">小游</a>  <a href="https://xiaoyou66.com" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="二次元技术宅">二次元技术宅</div>  </div></div><div class="card">  <a href="https://blog.libw.cc" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/Li-Zi-stu/Pictures@1.6/%E5%A4%B4%E5%83%8F/%E5%A4%B4%E5%83%8F.png"></a>  <div class="card-header">  <div><a href="https://blog.libw.cc" target="_blank">李本伟的博客</a>  <a href="https://blog.libw.cc" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="科学，是一种信仰，更是一种力量！">科学，是一种信仰，更是一种力量！</div>  </div></div><div class="card">  <a href="https://akilar.top/" target="_blank">  <img class="ava" src="https://akilar.top/img/siteicon/favicon.png"></a>  <div class="card-header">  <div><a href="https://akilar.top/" target="_blank">Akilarの糖果屋</a>  <a href="https://akilar.top/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="期待您的光临！">期待您的光临！</div>  </div></div><div class="card">  <a href="https://goopher.tk" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/Goopher97/tuchuang@master/img/18DAD281896408F73F4EF594111BECA2.jpg"></a>  <div class="card-header">  <div><a href="https://goopher.tk" target="_blank">GOOPHER's Blog</a>  <a href="https://goopher.tk" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="记录折腾的生活。">记录折腾的生活。</div>  </div></div><div class="card">  <a href="https://ahzoo.cn/" target="_blank">  <img class="ava" src="https://ahzoo.cn/img/avatar.jpg"></a>  <div class="card-header">  <div><a href="https://ahzoo.cn/" target="_blank">清梦</a>  <a href="https://ahzoo.cn/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="醉后不知天在水，满船清梦压星河">醉后不知天在水，满船清梦压星河</div>  </div></div><div class="card">  <a href="https://5ime.cn" target="_blank">  <img class="ava" src="https://cdn.jsdelivr.net/gh/5ime/img/avatar.jpg"></a>  <div class="card-header">  <div><a href="https://5ime.cn" target="_blank">I Am I</a>  <a href="https://5ime.cn" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="永远相信美好的事情即将发生">永远相信美好的事情即将发生</div>  </div></div><div class="card">  <a href="https://furrysp.top" target="_blank">  <img class="ava" src="https://sdn.geekzu.org/avatar/26fb4e9d679e499d8545df9f2aea519c?s=100"></a>  <div class="card-header">  <div><a href="https://furrysp.top" target="_blank">LonYJ’s blog</a>  <a href="https://furrysp.top" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="あなたは主人公になりたいですか?">あなたは主人公になりたいですか?</div>  </div></div><div class="card">  <a href="https://www.aprilcherryblossom.top/" target="_blank">  <img class="ava" src="https://secure.gravatar.com/avatar/d5cc65a361a1d5c42dcb0ab03c1e421f"></a>  <div class="card-header">  <div><a href="https://www.aprilcherryblossom.top/" target="_blank">Yのケイ</a>  <a href="https://www.aprilcherryblossom.top/" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="我喜欢下雨，因为它能够带来天空的味道。">我喜欢下雨，因为它能够带来天空的味道。</div>  </div></div><div class="card">  <a href="https://tianli-blog.club" target="_blank">  <img class="ava" src="https://img1.tianli0.top/logo.png"></a>  <div class="card-header">  <div><a href="https://tianli-blog.club" target="_blank">Tianli</a>  <a href="https://tianli-blog.club" target="_blank" rel="noopener"><span class="focus-links"><i class="fa fa-plus" aria-hidden="true"></i>&nbsp;关注</span></a></div>  <div class="info" title="惟其不可能，所以才相信。">惟其不可能，所以才相信。</div>  </div></div></div></div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
